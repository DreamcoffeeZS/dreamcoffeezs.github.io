<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/header.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/header.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/header.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"wuyubeichen.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="iOS Developer, Beijing China">
<meta property="og:type" content="website">
<meta property="og:title" content="梧雨北辰的博客">
<meta property="og:url" content="https://wuyubeichen.github.io/page/4/index.html">
<meta property="og:site_name" content="梧雨北辰的博客">
<meta property="og:description" content="iOS Developer, Beijing China">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Zhou Shuai">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://wuyubeichen.github.io/page/4/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>梧雨北辰的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="梧雨北辰的博客" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">梧雨北辰的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">天行健，君子以自强不息！</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wuyubeichen.github.io/2017/08/08/Swift%E5%AD%A6%E4%B9%A008-%E6%B3%9B%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Author">
      <meta itemprop="description" content="iOS Developer, Beijing China">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="梧雨北辰的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/08/08/Swift%E5%AD%A6%E4%B9%A008-%E6%B3%9B%E5%9E%8B/" class="post-title-link" itemprop="url">Swift学习08-泛型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-08-08 18:01:32" itemprop="dateCreated datePublished" datetime="2017-08-08T18:01:32+08:00">2017-08-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-29 09:39:32" itemprop="dateModified" datetime="2022-08-29T09:39:32+08:00">2022-08-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Swift/" itemprop="url" rel="index"><span itemprop="name">Swift</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>Swift泛型</strong>：允许根据自定义的需求，编写出适用于任意类型、灵活可重用的函数及类型。它能让你避免代码的重复，用一种清晰和抽象的方式来表达代码的意图；</p>
<p><strong>主要内容：</strong></p>
<ol>
<li>泛型解决的问题</li>
<li>泛型函数</li>
<li>泛型类型</li>
<li>扩展一个泛型类型</li>
<li>泛型的类型约束</li>
<li>关联类型</li>
</ol>
<h4 id="一、泛型解决的问题"><a href="#一、泛型解决的问题" class="headerlink" title="一、泛型解决的问题"></a>一、泛型解决的问题</h4><p><code>Swift</code>泛型代码让你能够根据自定义的需求，编写出适用于任意类型、灵活可重用的函数及类型。它能让你避免代码的重复，用一种清晰和抽象的方式来表达代码的意图。这种说法很模糊，下面我们结合一个示例来说明泛型的作用。</p>
<p>需求描述：使用函数来交换两个变量的值</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//互换两个整型</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">swapTwoInt</span>(<span class="params">a</span>:<span class="keyword">inout</span> <span class="type">Int</span> , <span class="params">b</span>:<span class="keyword">inout</span> <span class="type">Int</span>)&#123;</span><br><span class="line">    (a, b) <span class="operator">=</span> (b, a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//互换两个Double</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">swapTwoDouble</span>(<span class="params">a</span>:<span class="keyword">inout</span> <span class="type">Double</span>, <span class="params">b</span>:<span class="keyword">inout</span> <span class="type">Double</span>)&#123;</span><br><span class="line">    (a,b) <span class="operator">=</span> (b,a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码分析： <code>swapTwoInt</code>与<code>swapTwoDouble</code>两个函数功能相同，唯一的区别就是传入的变量类型不同。这样的代码看起来重复又累赘。在实际应用中，通常需要一个更实用更灵活的函数来交换两个任意类型的值，幸运的是，泛型代码帮你解决了这种问题。</p>
<h4 id="二、泛型函数"><a href="#二、泛型函数" class="headerlink" title="二、泛型函数"></a>二、泛型函数</h4><p>泛型函数可以适用于任何类型，下面的<code>swapTwoValues(_:_:)</code>函数是上面两个函数的泛型版本,可以交换任意类型的两个变量。</p>
<p>尖括号里声明一种通用类型T，参数列表里可以使用这种类型名表示通用类型</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">SwapTwoThing</span>&lt;<span class="type">T</span>&gt;(<span class="params">a</span>:<span class="keyword">inout</span> <span class="type">T</span>, <span class="params">b</span>:<span class="keyword">inout</span> <span class="type">T</span>)&#123;</span><br><span class="line">    (a, b) <span class="operator">=</span> (b, a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a <span class="operator">=</span> <span class="number">100</span></span><br><span class="line"><span class="keyword">var</span> b <span class="operator">=</span> <span class="number">200</span></span><br><span class="line">swapTwoInt(a: <span class="operator">&amp;</span>a , b: <span class="operator">&amp;</span>b)</span><br><span class="line">a  <span class="comment">//200</span></span><br><span class="line">b  <span class="comment">//100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> string1 <span class="operator">=</span> <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="keyword">var</span> string2 <span class="operator">=</span> <span class="string">&quot;world&quot;</span></span><br><span class="line"><span class="type">SwapTwoThing</span>(a: <span class="operator">&amp;</span>string1, b: <span class="operator">&amp;</span>string2)</span><br><span class="line">string1  <span class="comment">//world</span></span><br><span class="line">string2  <span class="comment">//hello</span></span><br></pre></td></tr></table></figure>

<p>总结泛型函数的使用：</p>
<ol>
<li>使用了占位类型名(<code>T</code>)，来替换实际类型名<code>(Int，Double)</code>；</li>
<li>占位类型符并不指定<code>T</code>必须是什么类型，但是却限制了参数<code>a</code>和<code>b</code>必须是同一种类型T；</li>
<li>只有<code>SwapTwoValues&lt;T&gt;(_:_)</code>函数在调用时，才能根据所传入的实际类型决定<code>T</code>所代表的类型；</li>
<li><code>T</code>只是一个符号，可以使用大写字母开头的驼峰命名法（例如<code>T</code>和<code>MyTypeParameter</code>)来为类型参数命名，以表明它们是占位类型，而不是一个值。</li>
</ol>
<h4 id="三、泛型类型"><a href="#三、泛型类型" class="headerlink" title="三、泛型类型"></a>三、泛型类型</h4><h5 id="3-1-系统类型使用到的泛型"><a href="#3-1-系统类型使用到的泛型" class="headerlink" title="3.1.系统类型使用到的泛型"></a>3.1.系统类型使用到的泛型</h5><p>事实上，泛型类型的使用贯穿了<code>Swift</code>语言。例如，<code>Swift</code>的<code>Array</code>和<code>Dictionary</code>都是泛型集合。你可以创建一个<code>Int</code>数组，也可创建一个<code>String</code>数组。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr <span class="operator">=</span> <span class="type">Array</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line"><span class="keyword">let</span> dict <span class="operator">=</span> <span class="type">Dictionary</span>&lt;<span class="type">String</span>,<span class="type">Int</span>&gt;()</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">set</span>  <span class="operator">=</span> <span class="type">Set</span>&lt;<span class="type">Float</span>&gt;()</span><br></pre></td></tr></table></figure>

<h5 id="3-2-自定义泛型类型：实现一个栈结构体"><a href="#3-2-自定义泛型类型：实现一个栈结构体" class="headerlink" title="3.2.自定义泛型类型：实现一个栈结构体"></a>3.2.自定义泛型类型：实现一个栈结构体</h5><p>除了泛型函数，Swift还允许你定义泛型类型；这些自定义类、结构体和枚举可以适用于任何类型，类似于Array和 Dictionary。下面的示例就是创建一个具有栈功能的结构体，适用于各种类型。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Stack</span>&lt;<span class="title class_">Element</span>&gt;&#123;</span><br><span class="line">    <span class="comment">//存放栈中变量的数组</span></span><br><span class="line">    <span class="keyword">var</span> items <span class="operator">=</span> <span class="type">Array</span>&lt;<span class="type">Element</span>&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//入栈：向栈中添加一个新元素</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">push</span>(<span class="params">item</span>:<span class="type">Element</span>)&#123;</span><br><span class="line">        items.append(item)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//出栈：删除栈顶元素,并返回此元素</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">pop</span>() -&gt;<span class="type">Element</span>?&#123;</span><br><span class="line">        <span class="keyword">return</span> items.removeLast()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> stack <span class="operator">=</span> <span class="type">Stack</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line">stack.push(item: <span class="number">11</span>)</span><br><span class="line">stack.push(item: <span class="number">22</span>)</span><br><span class="line">stack.pop()   <span class="comment">//22</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> stack1 <span class="operator">=</span> <span class="type">Stack</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line">stack1.push(item:<span class="string">&quot;aaa&quot;</span>)</span><br><span class="line">stack1.push(item:<span class="string">&quot;bbb&quot;</span>)</span><br><span class="line">stack1.pop()  <span class="comment">//“bbb&quot;</span></span><br></pre></td></tr></table></figure>

<h5 id="3-3-自定义泛型类型：多个占位符"><a href="#3-3-自定义泛型类型：多个占位符" class="headerlink" title="3.3.自定义泛型类型：多个占位符"></a>3.3.自定义泛型类型：多个占位符</h5><p>自定义泛型类型可以设置多个类型占位符，下面就是自定义了一个泛型类型Pair，它具有两个占位类型符。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Pair</span>&lt;<span class="title class_">T1</span>, <span class="title class_">T2</span>&gt;&#123;</span><br><span class="line">    <span class="keyword">var</span> t1:<span class="type">T1</span></span><br><span class="line">    <span class="keyword">var</span> t2:<span class="type">T2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> pair1 <span class="operator">=</span> <span class="type">Pair</span>(t1: <span class="string">&quot;hello&quot;</span>, t2: <span class="string">&quot;hi&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(pair1)   <span class="comment">//Pair&lt;String, String&gt;(t1: &quot;hello&quot;, t2: &quot;hi&quot;)</span></span><br><span class="line"><span class="keyword">var</span> pair2:<span class="type">Pair</span>&lt;<span class="type">String</span>, <span class="type">Int</span>&gt; <span class="operator">=</span> <span class="type">Pair</span>(t1:<span class="string">&quot;hello&quot;</span>,t2: <span class="number">123</span>)</span><br><span class="line"><span class="built_in">print</span>(pair2)   <span class="comment">//Pair&lt;String, Int&gt;(t1: &quot;hello&quot;, t2: 123)</span></span><br></pre></td></tr></table></figure>

<h4 id="四、扩展一个泛型类型"><a href="#四、扩展一个泛型类型" class="headerlink" title="四、扩展一个泛型类型"></a>四、扩展一个泛型类型</h4><p>扩展一个泛型类型，可以直接使用原始类型定义中声明的类型参数列表，并且这些来自原始类型中的参数名称会被用作原始定义中类型参数的引用。 比如，我们现在扩展泛型类型Stack，为其添加计算型属性topItem，用于获取栈顶元素，代码示例如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Stack</span> &#123;</span><br><span class="line">    <span class="comment">//返回当前栈顶元素而不会将其从栈中移除</span></span><br><span class="line">    <span class="keyword">var</span> topItem: <span class="type">Element</span>? &#123;</span><br><span class="line">        <span class="keyword">return</span> items.isEmpty <span class="operator">?</span> <span class="literal">nil</span> : items[items.count <span class="operator">-</span> <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> stack3 <span class="operator">=</span> <span class="type">Stack</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line">stack3.push(item:<span class="number">1</span>)</span><br><span class="line">stack3.push(item:<span class="number">2</span>)</span><br><span class="line">stack3.push(item: <span class="number">3</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> topItem <span class="operator">=</span> stack3.topItem&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;栈顶元素:<span class="subst">\(topItem)</span>&quot;</span>)   <span class="comment">//栈顶元素:3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：扩展中的占位类型符需要与原始类保持一致，所以这里用的还是Element。</p>
<h4 id="五、泛型的类型约束"><a href="#五、泛型的类型约束" class="headerlink" title="五、泛型的类型约束"></a>五、泛型的类型约束</h4><p><code>swapTwoValues(_:_:)</code>函数和<code>Stack</code>类型可以作用于任何类型。但如果可以为泛型函数和泛型类型的类型添加一个特定的类型约束，将会是非常有用的。 通常情况下，我们设置泛型类型约束的时候，会指定一个类型参数必须继承自指定类，或者符合一个特定的协议或协议组合。</p>
<h5 id="5-1-类型约束语法"><a href="#5-1-类型约束语法" class="headerlink" title="5.1.类型约束语法"></a>5.1.类型约束语法</h5><p>对泛型函数添加类型约束的基本语法如下所示(作用于泛型类型时的语法与之相同)。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在一个类型参数名后面放置一个类名或者协议名，并用冒号进行分隔，来定义类型约束</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">someFunction</span>&lt;<span class="type">T</span>: <span class="type">SomeClass</span>, <span class="type">U</span>: <span class="type">SomeProtocol</span>&gt;(<span class="params">someT</span>: <span class="type">T</span>, <span class="params">someU</span>: <span class="type">U</span>) &#123;</span><br><span class="line">    <span class="comment">// 这里是泛型函数的函数体部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-2-泛型类型约束实践"><a href="#5-2-泛型类型约束实践" class="headerlink" title="5.2.泛型类型约束实践"></a>5.2.泛型类型约束实践</h5><p>下面的泛型函数用于查找数组中某个元素的索引位置；但由于for循环里用到了对象比较”&#x3D;&#x3D;”，要确保所有的类型都适用，所以在泛型函数的中添加了类型约束，使用此泛型函数的参数必须遵循<code>Equatable</code>协议。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">findIndex</span>&lt;<span class="type">T</span>: <span class="type">Equatable</span>&gt;(<span class="params">of</span> <span class="params">valueToFind</span>: <span class="type">T</span>, <span class="params">in</span> <span class="params">array</span>:[<span class="type">T</span>]) -&gt; <span class="type">Int</span>? &#123;</span><br><span class="line">    <span class="keyword">for</span> (index, value) <span class="keyword">in</span> array.enumerated() &#123;</span><br><span class="line">        <span class="keyword">if</span> value <span class="operator">==</span> valueToFind &#123;</span><br><span class="line">            <span class="keyword">return</span> index</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> doubleIndex <span class="operator">=</span> findIndex(of: <span class="number">9.3</span>, in: [<span class="number">3.14159</span>, <span class="number">0.1</span>, <span class="number">0.25</span>])  <span class="comment">//nil</span></span><br><span class="line"><span class="keyword">let</span> stringIndex <span class="operator">=</span> findIndex(of: <span class="string">&quot;Andrea&quot;</span>, in: [<span class="string">&quot;Mike&quot;</span>, <span class="string">&quot;Malcolm&quot;</span>, <span class="string">&quot;Andrea&quot;</span>]) <span class="comment">//2</span></span><br></pre></td></tr></table></figure>

<p>注意：Swift标准库定义了Equatable协议，该协议要求任何遵循该协议的类型必须实现等式符（&#x3D;&#x3D;）及不等符(!&#x3D;)。从而能对该类型的任意两个值进行比较。所有的Swift标准类型自动支持 Equatable 协议</p>
<h4 id="六、关联类型"><a href="#六、关联类型" class="headerlink" title="六、关联类型"></a>六、关联类型</h4><p>关联类型是在为协议中的某个类型提供一个占位名，其所代表的实际类型会在协议被采纳时才会被指定。这里涉及到两个关键字，其作用就是给一个类型起一个别名，首先来说明一下：</p>
<ul>
<li><strong>associatedtype</strong>：协议声明中使用</li>
<li><strong>typealias</strong>：协议实现中使用</li>
</ul>
<p>下面通过一个示例来理解关联类型的作用：定义一个可称重的协议，其中使用了泛型关联类型。这种方式可以更大程度的使用协议，具体实现协议的时候再决定类型。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">WeightCaclulable</span>&#123;</span><br><span class="line">    <span class="comment">//associatedtype设置别名，即关联类型</span></span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">WeightType</span></span><br><span class="line">    <span class="keyword">var</span> weight:<span class="type">WeightType</span>&#123;<span class="keyword">get</span>&#125; <span class="comment">//返回重量属性，其类型是WeightType</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//iphone7:手机较轻，表示重量时会有小数点，所以使用Double描述</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Iphone7</span>:<span class="title class_">WeightCaclulable</span>&#123;</span><br><span class="line">    <span class="comment">//实现的时候用的是typealias</span></span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">WeightType</span>  <span class="operator">=</span> <span class="type">Double</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> weight: <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.114</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Ship:轮船较重,表示重量可以忽略小数，所以使用Int描述</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ship</span>:<span class="title class_">WeightCaclulable</span>&#123;</span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">WeightType</span> <span class="operator">=</span> <span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> weight: <span class="type">WeightType</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">weight</span>:<span class="type">WeightType</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.weight <span class="operator">=</span> weight</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> iphone7 <span class="operator">=</span> <span class="type">Iphone7</span>()</span><br><span class="line"><span class="built_in">print</span>(iphone7.weight)  <span class="comment">//0.114</span></span><br><span class="line"><span class="keyword">let</span> ship <span class="operator">=</span> <span class="type">Ship</span>(weight: <span class="number">100000</span>)</span><br><span class="line"><span class="built_in">print</span>(ship.weight)     <span class="comment">//100000</span></span><br></pre></td></tr></table></figure>

<h5 id="6-1-关联类型添加约束"><a href="#6-1-关联类型添加约束" class="headerlink" title="6.1.关联类型添加约束"></a>6.1.关联类型添加约束</h5><p>协议中存在关联类型，我们也可以为其添加约束，下面是一个<code>Container</code>协议，我们设置其关联类型<code>Item</code>遵循了协议<code>Equatable</code>，具体代码如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">Container</span> &#123;</span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Item</span>: <span class="type">Equatable</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">append</span>(<span class="keyword">_</span> <span class="params">item</span>: <span class="type">Item</span>)</span><br><span class="line">    <span class="keyword">var</span> count: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">subscript</span>(<span class="params">i</span>: <span class="type">Int</span>) -&gt; <span class="type">Item</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wuyubeichen.github.io/2017/08/07/Swift%E5%AD%A6%E4%B9%A007-%E5%8F%AF%E9%80%89%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Author">
      <meta itemprop="description" content="iOS Developer, Beijing China">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="梧雨北辰的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/08/07/Swift%E5%AD%A6%E4%B9%A007-%E5%8F%AF%E9%80%89%E5%9E%8B/" class="post-title-link" itemprop="url">Swift学习07-可选型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-08-07 18:14:55" itemprop="dateCreated datePublished" datetime="2017-08-07T18:14:55+08:00">2017-08-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-29 09:39:32" itemprop="dateModified" datetime="2022-08-29T09:39:32+08:00">2022-08-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Swift/" itemprop="url" rel="index"><span itemprop="name">Swift</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>顾名思义，可选类型表示一个变量可能有值，也可能没有值（nil），但是它的用法却与OC中的nil完全不同</strong></p>
<p>主要内容：</p>
<ol>
<li>可选型使用要点</li>
<li>可选型解包</li>
<li>可选链 <code>Option chaining</code></li>
<li>空合并运算符<code>nil coalesce</code></li>
<li>隐式可选型</li>
<li>可选型使用的其他示例</li>
<li>最后小结</li>
</ol>
<h4 id="一、可选型使用要点"><a href="#一、可选型使用要点" class="headerlink" title="一、可选型使用要点"></a>一、可选型使用要点</h4><ol>
<li>可选类型类似于<code>OC</code>指针的<code>nil</code>值，但是<code>OC</code>中的<code>nil</code>只对类有用，而可选择型中<code>nil</code>对所有类型都可用，更安全</li>
<li>可选型的声明的方式是<code>“数据类型+问号”</code>。如：<code>var errorCode :Int? = 404</code></li>
<li>当要使用一个可选类型的变量时，要在后面加感叹号<code>“!”</code>或者<code>“?”</code>。</li>
<li>不能把一个可选型便量赋值给非可选型的变量, 如：<code>let tempValue = nil</code>，这样会报错；</li>
<li>可选型数据一般都是可变的，所以可选型的数据也通常是变量；</li>
<li>声明一个可选型的时候，必须是添加？,swift不能隐式的自动推断可选型；</li>
</ol>
<p><code>swift</code>不能用同类中的一个特殊值代表无或者没有，在<code>Swift</code>中，<code>nil</code>代表着没有，但是它却不能直接使用，示例如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> errorCode :<span class="type">Int</span> <span class="operator">=</span> <span class="number">404</span></span><br><span class="line">errorCode <span class="operator">=</span> <span class="literal">nil</span> <span class="comment">//报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//改：使用Int?  声明一个整型可选型</span></span><br><span class="line"><span class="keyword">var</span> errorCode :<span class="type">Int</span>? <span class="operator">=</span> <span class="number">404</span></span><br><span class="line">errorCode <span class="operator">=</span> <span class="literal">nil</span> <span class="comment">//将其声明为为可选型变量才能赋值为nil</span></span><br></pre></td></tr></table></figure>

<h4 id="二、可选型解包"><a href="#二、可选型解包" class="headerlink" title="二、可选型解包"></a>二、可选型解包</h4><p>一个可选型数据，就意味着其值是可以为<code>nil</code>的，这样的数据不可以直接使用，所以将可选型解包后再使用是十分重要的操作。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接使用</span></span><br><span class="line"><span class="keyword">var</span> errorCode: <span class="type">String</span>? <span class="operator">=</span> <span class="string">&quot;404&quot;</span></span><br><span class="line"><span class="built_in">print</span>(errorCode)</span><br><span class="line"></span><br><span class="line"><span class="comment">//&quot;The errorCode is&quot; +errorCode //直接使用显式可选型会编译不通过，报错</span></span><br></pre></td></tr></table></figure>

<h5 id="1-解包方法1：普通的if判断，但不方便"><a href="#1-解包方法1：普通的if判断，但不方便" class="headerlink" title="1.解包方法1：普通的if判断，但不方便"></a>1.解包方法1：普通的if判断，但不方便</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(errorCode <span class="operator">!=</span> <span class="literal">nil</span>)&#123;</span><br><span class="line">    <span class="string">&quot;The errorCode is &quot;</span> <span class="operator">+</span> errorCode<span class="operator">!</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="string">&quot;No error&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-解包方法2：强制解包，使用感叹号“-”，存在错误风险"><a href="#2-解包方法2：强制解包，使用感叹号“-”，存在错误风险" class="headerlink" title="2.解包方法2：强制解包，使用感叹号“!”，存在错误风险"></a>2.解包方法2：强制解包，使用感叹号“!”，存在错误风险</h5><p>一般情况下，我们在确定使用的可选型变量不会是nil，才通过!强制解包并使用</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> errorCode: <span class="type">String</span>? <span class="operator">=</span> <span class="string">&quot;404&quot;</span></span><br><span class="line"><span class="string">&quot;The errorCode is &quot;</span> <span class="operator">+</span> errorCode<span class="operator">!</span></span><br></pre></td></tr></table></figure>

<h5 id="3-解包方法3：尝试解包，使用问号“？”，较为安全"><a href="#3-解包方法3：尝试解包，使用问号“？”，较为安全" class="headerlink" title="3.解包方法3：尝试解包，使用问号“？”，较为安全"></a>3.解包方法3：尝试解包，使用问号“？”，较为安全</h5><p>当不确定使用的可选型变量是否是nil,通过?执行调用方法等操作，意味着不为nil时才可以执行成功</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> errorCode: <span class="type">String</span>? <span class="operator">=</span> <span class="string">&quot;404&quot;</span></span><br><span class="line"><span class="string">&quot;The errorCode is &quot;</span> <span class="operator">+</span> errorCode？</span><br></pre></td></tr></table></figure>

<h5 id="4-解包方法4：if-let解包-当我们希望在可选型为nil时候，执行别的代码，此时更适合使用if-let方式解包"><a href="#4-解包方法4：if-let解包-当我们希望在可选型为nil时候，执行别的代码，此时更适合使用if-let方式解包" class="headerlink" title="4.解包方法4：if-let解包, 当我们希望在可选型为nil时候，执行别的代码，此时更适合使用if-let方式解包"></a>4.解包方法4：if-let解包, 当我们希望在可选型为nil时候，执行别的代码，此时更适合使用if-let方式解包</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> unwrappedErrorCode <span class="operator">=</span> errorCode&#123;</span><br><span class="line">    <span class="comment">//unwrappedErrorCode 是经过解包的数据，得到非nil值</span></span><br><span class="line">    <span class="string">&quot;The errorCode is&quot;</span> <span class="operator">+</span> unwrappedErrorCode</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">------------</span>优美的分割线<span class="operator">-----------------</span></span><br><span class="line"> <span class="comment">//if-let解包方法的改进：可以使用原来的变量名</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> errorCode <span class="operator">=</span> errorCode&#123;</span><br><span class="line">    <span class="comment">//errorCode 是经过解包的数据，得到非nil值</span></span><br><span class="line">    <span class="comment">//括号内的errorCode 只在此括号内使用</span></span><br><span class="line">    <span class="string">&quot;The errorCode is&quot;</span> <span class="operator">+</span> errorCode</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//处理nil情况</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-解包时注意事项："><a href="#5-解包时注意事项：" class="headerlink" title="5.解包时注意事项："></a>5.解包时注意事项：</h5><p>隐式声明的可选型不需要解包，但是这样可能因为nil报错（详情请看第五部分）</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> blog:<span class="type">String</span>! <span class="operator">=</span> <span class="string">&quot;helloWord&quot;</span></span><br><span class="line"><span class="comment">//blog = nil </span></span><br><span class="line"><span class="string">&quot;My blog is&quot;</span> <span class="operator">+</span> blog</span><br></pre></td></tr></table></figure>

<p>if-let可以同时解包多个变量，而且因为使用了if，也可以增加判断逻辑</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> errorCode <span class="operator">=</span> errorCode, errorMessage <span class="operator">=</span> </span><br><span class="line">                  errorMessage <span class="keyword">where</span> errorCode <span class="operator">==</span> <span class="string">&quot;404&quot;</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Page not found&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;No error&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="三、可选链-Option-chaining"><a href="#三、可选链-Option-chaining" class="headerlink" title="三、可选链 Option chaining"></a>三、可选链 Option chaining</h4><p>可选链的使用简化了可选型的使用。在某些情况下可以避免<code>if-let</code> 解包的使用，而是通过尝试解包（使用问号<code>？</code>）或者强制解包（感叹号<code>!</code>）来使用操作对象 示例：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> errorCodeStr: <span class="type">String</span>? <span class="operator">=</span> <span class="string">&quot;Hello, playground&quot;</span></span><br><span class="line"><span class="comment">//errorCodeStr.uppercaseString ; errorCodeStr是可选型不能直接使用，需要解包如下：</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> errorCodeStr <span class="operator">=</span> errorCodeStr&#123;</span><br><span class="line">    errorCodeStr.uppercaseString</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码使用可选链简化，如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//推荐写法:使用？尝试解包，如果成功就会将字符串大写</span></span><br><span class="line">errorCodeStr<span class="operator">?</span>.uppercaseString</span><br><span class="line"><span class="comment">//不安全写法，当errorCode为nil时报错，除非我们确保errorCodeStr不为nil才能这样写</span></span><br><span class="line">errorCodeStr<span class="operator">!</span>.uppercaseString</span><br></pre></td></tr></table></figure>

<p>基于这样的使用，可能会出现类似 <code>Person?.address?.addressName</code> 的使用，这就构成了可选链,调用链中任何一个节点为<code>nil</code>,整个调用都会失败，返回<code>nil</code>，使用<code>？</code>是安全的;</p>
<h4 id="四、空合并运算符nil-coalesce"><a href="#四、空合并运算符nil-coalesce" class="headerlink" title="四、空合并运算符nil coalesce"></a>四、空合并运算符nil coalesce</h4><p>使用空合并运算符，可以解决解包之后的存值问题</p>
<h5 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> uppperCaseErrorStr <span class="operator">=</span> errorCodeStr<span class="operator">?</span>.uppercaseString</span><br><span class="line"><span class="comment">//uppperCaseErrorStr此时是一个可选型变量，不需要显示声明，因为后面的表达式是可选型</span></span><br><span class="line"><span class="comment">//实现解包同时实现了大写</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> errorCodeStr  <span class="operator">=</span> errorCodeStr<span class="operator">?</span>.uppercaseString&#123;</span><br><span class="line">    errorCodeStr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> errorMessage: <span class="type">String</span>? <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line"><span class="keyword">let</span> message: <span class="type">String</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> errorMessage <span class="operator">=</span> errorMessage&#123;</span><br><span class="line">    message <span class="operator">=</span> errorMessage</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    message <span class="operator">=</span> <span class="string">&quot;no error&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="改进示例2：使用三目运算符"><a href="#改进示例2：使用三目运算符" class="headerlink" title="改进示例2：使用三目运算符"></a>改进示例2：使用三目运算符</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message2 <span class="operator">=</span> errorMessage <span class="operator">==</span> <span class="literal">nil</span> <span class="operator">?</span> <span class="string">&quot;no errror&quot;</span> :errorMessage;</span><br></pre></td></tr></table></figure>

<p>改进示例2:使用空合并运算符??，如果errorMessage有值，使用errorMessage!赋值</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//？？是空和并运算符</span></span><br><span class="line"><span class="keyword">let</span> message3 <span class="operator">=</span> errorMessage <span class="operator">??</span> <span class="string">&quot;no error&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="五、隐式可选型"><a href="#五、隐式可选型" class="headerlink" title="五、隐式可选型"></a>五、隐式可选型</h4><ol>
<li>区别于显式可选型的创建：类型+<code>？</code>，创建隐式可选型使用：类型+<code>！</code></li>
<li>隐式可选型变量使用时，相当于其后面自带了一个感叹号，可以直接赋值给一个非可选型变量，但是隐式可选型依然保持可选型的特性，可以被赋值为<code>nil</code>，这就体现出来隐式可选类型的优点,即可用被赋值为<code>nil</code>，也可以不用每次显式的解包</li>
<li>隐式解析可选类型还可以在类中做属性，解决循环引用问题</li>
</ol>
<p>示例：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> errorMessage: <span class="type">String</span>! <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line">errorMessage <span class="operator">=</span> <span class="string">&quot;not found&quot;</span></span><br><span class="line"><span class="comment">//这里errorMessage是隐式可选型，使用时候不需要显式的解包，但是如果errorMessage为nil就会报错</span></span><br><span class="line"><span class="string">&quot;The error is &quot;</span> <span class="operator">+</span> errorMessage</span><br></pre></td></tr></table></figure>

<h4 id="六、可选型使用的其他示例"><a href="#六、可选型使用的其他示例" class="headerlink" title="六、可选型使用的其他示例"></a>六、可选型使用的其他示例</h4><h5 id="示例1"><a href="#示例1" class="headerlink" title="示例1."></a>示例1.</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> error1:(errorCode: <span class="type">Int</span>, errorMessage: <span class="type">String</span>?) <span class="operator">=</span> (<span class="number">404</span> , <span class="string">&quot;page not found&quot;</span>)</span><br><span class="line">error1.errorMessage <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line"><span class="comment">//error1 = nil 整个元组并非可选型，不能使用nil赋值</span></span><br></pre></td></tr></table></figure>

<h5 id="示例2"><a href="#示例2" class="headerlink" title="示例2."></a>示例2.</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ageInt: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;xyz&quot;</span></span><br><span class="line"><span class="comment">//使用强制转换之后，age是可选型，需要按照可选型的规则去使用</span></span><br><span class="line"><span class="keyword">var</span> age <span class="operator">=</span> <span class="type">Int</span>(ageInt)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> age <span class="operator">=</span> age <span class="keyword">where</span> age <span class="operator">&lt;</span> <span class="number">20</span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;you are a tennager!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="示例3"><a href="#示例3" class="headerlink" title="示例3."></a>示例3.</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> greeting <span class="operator">=</span> <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="comment">//rangeString 返回一个可选型，需要按照可选型的规则去使用</span></span><br><span class="line">greeting.rangeOfString(<span class="string">&quot;ll&quot;</span>) <span class="comment">//2..&lt;4</span></span><br><span class="line">greeting.rangeOf3String(<span class="string">&quot;oo&quot;</span>)<span class="comment">//nil</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="七、最后小结"><a href="#七、最后小结" class="headerlink" title="七、最后小结"></a>七、最后小结</h4><ol>
<li>有了可选型，你在声明隐式可选变量或特性的时候就不用指定初始值，因为它有缺省值nil。尤其是在一个创建一个类的属性的时候。</li>
<li>由于隐式解析可选的值会在使用时自动解析，所以没必要使用操作符!来解析它。但是有可能运行时报错。</li>
<li>使用可选链会选择性的执行隐式解析可选表达式上的某一个操作。如果值为nil，就不会执行任何操作，因此也不会产生运行错误。</li>
<li>非可选型的变量或者常量不可能赋值为nil，所以不能使用：notOptioalValue !&#x3D; nil,判断是否nil。这是可选型和非可选型数据的一个明显区别</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wuyubeichen.github.io/2017/08/06/Swift%E5%AD%A6%E4%B9%A006-%E6%9E%84%E9%80%A0%E5%99%A8(%E4%B8%8B)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Author">
      <meta itemprop="description" content="iOS Developer, Beijing China">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="梧雨北辰的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/08/06/Swift%E5%AD%A6%E4%B9%A006-%E6%9E%84%E9%80%A0%E5%99%A8(%E4%B8%8B)/" class="post-title-link" itemprop="url">Swift学习06-构造器(下)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-08-06 18:15:09" itemprop="dateCreated datePublished" datetime="2017-08-06T18:15:09+08:00">2017-08-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-29 09:39:32" itemprop="dateModified" datetime="2022-08-29T09:39:32+08:00">2022-08-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Swift/" itemprop="url" rel="index"><span itemprop="name">Swift</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>主要内容：</strong></p>
<ol>
<li>可失败的构造器</li>
<li>枚举类型可失败的构造器</li>
<li>构造失败的传递</li>
<li>重写一个可失败的构造器</li>
<li>可失败构造器<code>init!</code></li>
<li>必要构造器</li>
<li>通过闭包或函数设置属性的默认值</li>
</ol>
<h4 id="一、可失败的构造器"><a href="#一、可失败的构造器" class="headerlink" title="一、可失败的构造器"></a>一、可失败的构造器</h4><p>顾名思义，这是用于我们构造过程可能失败情况的构造器。失败的原因可能是给构造器传入无效的参数值，或缺少某种所需的外部资源，又或是不满足某种必要的条件等。一个可失败构造器示例如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可失败构造器语法是init关键字后面添加问号即(init?) </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> name :<span class="type">String</span></span><br><span class="line">    <span class="keyword">init?</span>(<span class="params">name</span>:<span class="type">String</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> name.isEmpty &#123;</span><br><span class="line">            <span class="comment">//其实Swift构造器并不支持返回值，因为构造器本来就是要确保对象能被正确构造。</span></span><br><span class="line">            <span class="comment">//所以这里使用return nil只是为了表明可失败构造器构造失败。          </span></span><br><span class="line">             <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//参数不为空，继续构造器得到可用的实例</span></span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>： </p>
<ol>
<li>可失败构造器的参数名和参数类型，不能与其它非可失败构造器的参数名，及其参数类型相同;</li>
<li>可失败构造器其实是在构造失败时创建一个类型为自身类型的可选类型的对象;</li>
</ol>
<h4 id="二、枚举类型可失败的构造器"><a href="#二、枚举类型可失败的构造器" class="headerlink" title="二、枚举类型可失败的构造器"></a>二、枚举类型可失败的构造器</h4><p>通过枚举类型可失败构造器获取枚举类型中特定的枚举成员，完成构造任务。如果提供的参数无法匹配任何枚举成员则构造失败。使用示例如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">TestNum</span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">First</span>, <span class="type">Second</span>, <span class="type">Third</span></span><br><span class="line">    <span class="keyword">init?</span>(<span class="params">number</span> : <span class="type">Character</span>)&#123;</span><br><span class="line">        <span class="keyword">switch</span> number&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;1&quot;</span>:</span><br><span class="line">            <span class="keyword">self</span> <span class="operator">=</span> .<span class="type">First</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;2&quot;</span>:</span><br><span class="line">            <span class="keyword">self</span> <span class="operator">=</span> .<span class="type">Second</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;3&quot;</span>:</span><br><span class="line">            <span class="keyword">self</span> <span class="operator">=</span> .<span class="type">Third</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不同于以上的写法，swift中还可以使用带原始值的枚举类型可失败构造器。带原始值的枚举类型会自带一个可失败构造器init?(rawValue:)，这里名为rawValue的参数，其类型和枚举类型的原始值类型一致， 如果该参数的值能够和某个枚举成员的原始值匹配，则该构造器会构造相应的枚举成员，否则构造失败。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">TestNum2</span>:<span class="title class_">Character</span>&#123;</span><br><span class="line">    <span class="comment">//枚举值自带原始值</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">First</span> <span class="operator">=</span> <span class="string">&quot;1&quot;</span>, <span class="type">Second</span> <span class="operator">=</span> <span class="string">&quot;2&quot;</span>, <span class="type">Third</span> <span class="operator">=</span> <span class="string">&quot;3&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> number <span class="operator">=</span> <span class="type">TestNum2</span>(rawValue: <span class="string">&quot;6&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> number <span class="operator">==</span> <span class="literal">nil</span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;枚举类型构造失败&quot;</span>)<span class="comment">//此句被打印</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="三、构造失败的传递"><a href="#三、构造失败的传递" class="headerlink" title="三、构造失败的传递"></a>三、构造失败的传递</h4><p>与普通的构造器相似，可失败构造器也是可以代理的。这里包括类、结构体、枚举中的横向代理，也包括子类和父类之间的向上代理。</p>
<ol>
<li>无论是向上代理还是横向代理，如果你代理到的其他可失败构造器触发构造失败，整个构造过程将立即终止，接下来的任何构造代码不会再被执行。</li>
<li>可失败构造器也可以代理到其它的非可失败构造器。通过这种方式，你可以增加一个可能的失败状态到现有的构造过程中；</li>
</ol>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span>!</span><br><span class="line">    <span class="keyword">init?</span>(<span class="params">name</span>: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> name.isEmpty &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CartItem</span>: <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> quantity: <span class="type">Int</span>!</span><br><span class="line">    <span class="keyword">init?</span>(<span class="params">name</span>: <span class="type">String</span>, <span class="params">quantity</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (quantity <span class="operator">&lt;</span> <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//验证quantity不符合要求，就立刻终止构造器，返回nil对象，剩余代码也不再执行</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(name: name)</span><br><span class="line">        <span class="keyword">self</span>.quantity <span class="operator">=</span> quantity</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="四、重写一个可失败的构造器"><a href="#四、重写一个可失败的构造器" class="headerlink" title="四、重写一个可失败的构造器"></a>四、重写一个可失败的构造器</h4><p>既然是重写，这里主要是应用于类中。这里包括两种情况:</p>
<ol>
<li>用子类的可失败构造器重写父类的可失败构造器（这种情况针对于可能子类增加了更多的可失败处理）</li>
<li>用子类的非可失败构造器重写一个父类的可失败构造器。</li>
</ol>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重写一个可失败的构造器一个示例如下：</span></span><br><span class="line"><span class="comment">//父类Person:要求其name属性必须是非空字符串或者nil</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name:<span class="type">String</span>?</span><br><span class="line">    <span class="comment">//该构造器可创建name属性是nil的Person实例</span></span><br><span class="line">    <span class="keyword">init</span>()&#123;&#125;</span><br><span class="line">    <span class="comment">//父类的可失败构造器，当传入参数为空的时候，不能创建有效实例</span></span><br><span class="line">    <span class="keyword">init?</span>(<span class="params">name</span> :<span class="type">String</span>)&#123;</span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">        <span class="keyword">if</span> name.isEmpty&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类Student:</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:<span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>()&#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> <span class="string">&quot;匿名&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//子类的非可失败构造器init(name:)重写了父类的可失败构造器init?(name:)。</span></span><br><span class="line">    <span class="comment">//因为这里很好的处理了空字符串的情况，无论传入参数是否是空字符串，都将创建有效实例</span></span><br><span class="line">    <span class="comment">//注意：可以用非可失败构造器重写可失败构造器，但反过来却不行。</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line">        <span class="keyword">if</span> name.isEmpty&#123;</span><br><span class="line">            <span class="keyword">self</span>.name <span class="operator">=</span> <span class="string">&quot;匿名&quot;</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子类：Teacher:</span></span><br><span class="line"><span class="comment">//我们也可以在子类的非可失败构造器中使用强制解包来调用父类的可失败构造器，具体使用如下:</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span>:<span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(name: <span class="string">&quot;匿名&quot;</span>)<span class="operator">!</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里子类的非可失败构造器重写父类的可失败构造器</span></span><br><span class="line">    <span class="comment">//向上代理到父类的可失败构造器，并对父类的可失败构造器的返回值进行强制解包</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> name.isEmpty&#123;</span><br><span class="line">            <span class="keyword">super</span>.<span class="keyword">init</span>(name: <span class="string">&quot;匿名&quot;</span>)<span class="operator">!</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.<span class="keyword">init</span>(name: name)<span class="operator">!</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="五、可失败构造器init"><a href="#五、可失败构造器init" class="headerlink" title="五、可失败构造器init!"></a>五、可失败构造器init!</h4><p>区别于init?方式的可失败构造器，init!形式的可失败构造器器将创建一个对应类型的隐式解包可选型对象 init?和init!可以相互代理，也可以相互重写。我们也可以用init代理到init!,但是一旦init!构造失败，将触发断言</p>
<h4 id="六、必要构造器"><a href="#六、必要构造器" class="headerlink" title="六、必要构造器"></a>六、必要构造器</h4><p>在类的构造器前添加required修饰符表明所有该类的子类都必须实现该构造器。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SuperClass</span> &#123;</span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="comment">// 构造器的实现代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubClass</span>: <span class="title class_">SuperClass</span> &#123;</span><br><span class="line">    <span class="comment">//1.子类重写父类的必要构造器，构造器前也必须添加required修饰符，表明该构造器要求也应用于继承链后面的子类。</span></span><br><span class="line">    <span class="comment">//2.但是这里虽然重写父类中必要的指定构造器时，却不需要添加override修饰符：</span></span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="comment">//构造器的实现代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="七、通过闭包或函数设置属性的默认值"><a href="#七、通过闭包或函数设置属性的默认值" class="headerlink" title="七、通过闭包或函数设置属性的默认值"></a>七、通过闭包或函数设置属性的默认值</h4><p>在构造过程中，我们可以使用闭包或全局函数为某个存储型属性提供定制的默认值。 在新实例被创建时，对应的闭包或函数会被调用，其返回值会当做默认值赋值给这个属性, 具体的时候用如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Weather</span> &#123;</span><br><span class="line">    <span class="comment">//常见的一些天气</span></span><br><span class="line">    <span class="keyword">let</span> commonWeather: [<span class="type">String</span>] <span class="operator">=</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> weather <span class="operator">=</span> [<span class="string">&quot;sunny&quot;</span>, <span class="string">&quot;cloud&quot;</span>,<span class="string">&quot;rain&quot;</span>,<span class="string">&quot;snow&quot;</span>];</span><br><span class="line">        <span class="keyword">return</span> weather</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="comment">//打印</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">printCommonWeather</span>()&#123;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span> <span class="operator">..&lt;</span> commonWeather.count &#123;</span><br><span class="line">            <span class="built_in">print</span>(commonWeather[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> weather <span class="operator">=</span> <span class="type">Weather</span>()<span class="comment">//同时初始化了默认属性</span></span><br><span class="line">weather.printCommonWeather()</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wuyubeichen.github.io/2017/08/05/Swift%E5%AD%A6%E4%B9%A005-%E6%9E%84%E9%80%A0%E5%99%A8(%E4%B8%AD)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Author">
      <meta itemprop="description" content="iOS Developer, Beijing China">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="梧雨北辰的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/08/05/Swift%E5%AD%A6%E4%B9%A005-%E6%9E%84%E9%80%A0%E5%99%A8(%E4%B8%AD)/" class="post-title-link" itemprop="url">Swift学习05-构造器(中)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-08-05 18:15:21" itemprop="dateCreated datePublished" datetime="2017-08-05T18:15:21+08:00">2017-08-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-29 09:39:32" itemprop="dateModified" datetime="2022-08-29T09:39:32+08:00">2022-08-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Swift/" itemprop="url" rel="index"><span itemprop="name">Swift</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>主要内容：</strong></p>
<ol>
<li>构造器简介</li>
<li>指定构造器和便利构造器</li>
<li>类的构造器的使用</li>
</ol>
<h4 id="一、构造器简介"><a href="#一、构造器简介" class="headerlink" title="一、构造器简介"></a>一、构造器简介</h4><p>本篇继续对<code>Swift</code>中的构造器进行介绍，这里主要说到类的继承和构造。 作为引用类型的类具有的继承特性，这使得类的构造过程较为复杂一些，因为涉及到很多细节性的问题。在使用之前，我们需要了解一些基本的问题：</p>
<ol>
<li>类中所有存储属性，包括继承父类的属性，都要在构造过程中设置初值</li>
<li><code>Swift</code>类的构造器分为指定构造器和便利构造器，确保完成构造过程</li>
</ol>
<h4 id="二、指定构造器和便利构造器"><a href="#二、指定构造器和便利构造器" class="headerlink" title="二、指定构造器和便利构造器"></a>二、指定构造器和便利构造器</h4><h5 id="指定构造器："><a href="#指定构造器：" class="headerlink" title="指定构造器："></a>指定构造器：</h5><ul>
<li>类的主要构造器，负责初始化类中所有属性，在继承关系中可调用父类链中的父类构造器;</li>
<li>每个类至少一个指定构造器。但是某些情况下，许多类是通过继承父类的指定构造器来满足这个条件;</li>
</ul>
<h5 id="便利构造器："><a href="#便利构造器：" class="headerlink" title="便利构造器："></a>便利构造器：</h5><ul>
<li>辅助类型的构造器，调用同一个类中的指定构造器完成类的初始化操作;</li>
<li>便利构造器需要在<code>init</code>关键字之前添加<code>convenience</code>关键字，使用空格分开;</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FatherClass</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> valueOne: <span class="type">Int</span></span><br><span class="line">    <span class="comment">//指定构造器</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">valueOne</span>: <span class="type">Int</span>)&#123;</span><br><span class="line">        <span class="keyword">self</span>.valueOne <span class="operator">=</span> valueOne</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChildClass</span>: <span class="title class_">FatherClass</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> valueTwo:<span class="type">Int</span> <span class="comment">//子类的新引入属性</span></span><br><span class="line">    <span class="comment">//指定构造器</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">valueOne</span>: <span class="type">Int</span> , <span class="params">valueTwo</span>:<span class="type">Int</span>)&#123;</span><br><span class="line">        <span class="keyword">self</span>.valueTwo <span class="operator">=</span> valueTwo</span><br><span class="line">        <span class="comment">//先初始化新引入属性，再初始化超类</span></span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(valueOne: valueOne)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//便利构造器</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">convenience</span> <span class="keyword">init</span>(<span class="params">valueOne</span>: <span class="type">Int</span>)&#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(valueOne: valueOne);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="三、类的构造器的使用"><a href="#三、类的构造器的使用" class="headerlink" title="三、类的构造器的使用"></a>三、类的构造器的使用</h4><p>关于类的构造器的使用在使用的时候，细节方面需要要注意很多，通过查找一些资料，现总结如下：</p>
<h5 id="1-指定构造器和便利构造器的基本使用原则："><a href="#1-指定构造器和便利构造器的基本使用原则：" class="headerlink" title="1. 指定构造器和便利构造器的基本使用原则："></a>1. 指定构造器和便利构造器的基本使用原则：</h5><ul>
<li>  当前类存在父类时，指定构造器器必须调用其直接父类的指定构造器，为保证继承的属性得以初始化;</li>
<li>  便利构造器必须调用同一类中定义的其他构造器。而且最终会导致一个指定构造器被调用;</li>
</ul>
<h5 id="2-Swift两段式构造过程"><a href="#2-Swift两段式构造过程" class="headerlink" title="2. Swift两段式构造过程"></a>2. Swift两段式构造过程</h5><p><code>Swift</code> 中类的构造过程包含两个阶段，被称为是二段式构造:</p>
<ol>
<li>第一阶段：每个存储型的值指定一个初值;</li>
<li>第二阶段：给当前类一个机会，在新实例准备使用之前进一步修改定制存储型的属性;</li>
</ol>
<p><strong>与OC的区别</strong>：<code>Swift</code>与<code>OC</code>的构造过程相似，区别在于阶段一，<code>OC</code>给每个属性赋值为<code>0</code>或者空值，但是<code>Swift</code>更为灵活，允许开发者指定自己所需的初始值(默认值);</p>
<h5 id="3-两段式构造需要注意的事项"><a href="#3-两段式构造需要注意的事项" class="headerlink" title="3. 两段式构造需要注意的事项"></a>3. 两段式构造需要注意的事项</h5><ul>
<li>指定构造器必须保证当前类新引入所有属性初始化完成之后，才能将其构造器任务继续向上代理给父类的构造器。</li>
<li>指定构造器必须先向上代理调用父类构造器，然后再为其继承的属性设置新值，否则，指定构造器赋予的新值将被父类中的构造器所覆盖。</li>
<li>便利构造器必须先代理调用同一类中的其它构造器，然后再为任意属性赋新值。否则，便利构造器赋予的新值将被同一类中其它指定构造器所覆盖。</li>
<li>构造器在第一阶段构造完成之前，不能调用任何实例方法，不能读取任何实例属性的值，不能引用self 作为一个值，因为此时还没构造有效实例。</li>
</ul>
<h5 id="4-总结两段式构造的详细流程"><a href="#4-总结两段式构造的详细流程" class="headerlink" title="4. 总结两段式构造的详细流程"></a>4. 总结两段式构造的详细流程</h5><p>第一阶段：</p>
<ul>
<li>某个指定构造器或便利构造器被调用。</li>
<li>完成新实例内存的分配，但此时内存还没有被初始化。</li>
<li>指定构造器确保其所在类引入的所有存储型属性都已赋初值。存储型属性所属的内存完成初始化。</li>
<li>指定构造器将调用父类的构造器，完成父类属性的初始化。这个调用父类构造器的过程沿着构造器链一直往上执行，直到到达构造器链的最顶部。</li>
<li>当到达了构造器链最顶部，且已确保所有实例包含的存储型属性都已经赋值，这个实例的内存被认为已经完全初始化。此时阶段 1 完成。</li>
</ul>
<p>第二阶段：</p>
<ol>
<li>从顶部构造器链一直往下，每个构造器链中类的指定构造器都有机会进一步定制实例。构造器此时可以访问self、修改它的属性并调用实例方法等等;</li>
<li>最终，任意构造器链中的便利构造器可以有机会定制实例和使用self;</li>
</ol>
<h4 id="四、构造器的继承与重写"><a href="#四、构造器的继承与重写" class="headerlink" title="四、构造器的继承与重写"></a>四、构造器的继承与重写</h4><p>与<code>OC</code>不同，<code>Swift</code>中的子类默认情况不会自动继承父类的构造器，这是因为子类可能有更多新增属性，直接调用父类的构造器，可能会有一些属性无法初始化为出现错误;         如果我们希望子类拥有一个或多个与父类相同的构造器，那么这相当于子类重写了父类的构造器，需要在重写方法前添加override修饰符。（override的作用是提示编译器去检查父类中是否有相匹配的指定构造器，并验证构造器参数是否正确）</p>
<p>注意：</p>
<ol>
<li>重写系统自带的默认构造器（虽然不是显式的），也要带上override修饰符;</li>
<li>重写父类指定构造器必须带上override，即使你的子类将父类的指定构造器重写成了便利构造器;</li>
<li>子类编写和父类便利构造器相匹配的子类构造器时，由于子类不能直接调用父类的便利构造器，并不能看做是对父类构造器的重写。所以子类中“重写”父类便利构造器时，不需要加override修饰符;</li>
</ol>
<h4 id="五、构造器的自动继承"><a href="#五、构造器的自动继承" class="headerlink" title="五、构造器的自动继承"></a>五、构造器的自动继承</h4><p>子类在默认情况下不会继承父类的构造器。但是如果满足特定条件，父类构造器还是是可以被自动继承的;</p>
<p>构造器的自动继承需要满足前提条件是：子类中引入的所有新属性都提供了默认值。</p>
<p>然后可分为两种情况：</p>
<h5 id="情况1-子类没有定义任何指定构造器，它将自动继承所有父类的指定构造器。"><a href="#情况1-子类没有定义任何指定构造器，它将自动继承所有父类的指定构造器。" class="headerlink" title="情况1:子类没有定义任何指定构造器，它将自动继承所有父类的指定构造器。"></a>情况1:子类没有定义任何指定构造器，它将自动继承所有父类的指定构造器。</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SuperClass</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> valueOne: <span class="type">Int</span></span><br><span class="line">    <span class="comment">//指定构造器</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">valueOne</span>: <span class="type">Int</span>)&#123;</span><br><span class="line">        <span class="keyword">self</span>.valueOne <span class="operator">=</span> valueOne</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubClass</span>: <span class="title class_">SuperClass</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> valueTwo:<span class="type">Int</span>  <span class="operator">=</span> <span class="number">100</span> <span class="comment">//子类的新引入属性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自动继承了父类的构造器,这里被使用创建子类，子类新属性使用默认值</span></span><br><span class="line"><span class="keyword">let</span> subClass <span class="operator">=</span> <span class="type">SubClass</span>(valueOne: <span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;subClass：(<span class="subst">\(subClass.valueOne)</span>) valueTwo(<span class="subst">\(subClass.valueTwo)</span>)&quot;</span>)</span><br></pre></td></tr></table></figure>

<h5 id="情况2：子类提供了所有父类指定构造器的实现-通过情况1继承过来的或者子类自定义实现-，此时子类将自动继承所有父类的便利构造器。"><a href="#情况2：子类提供了所有父类指定构造器的实现-通过情况1继承过来的或者子类自定义实现-，此时子类将自动继承所有父类的便利构造器。" class="headerlink" title="情况2：子类提供了所有父类指定构造器的实现(通过情况1继承过来的或者子类自定义实现)，此时子类将自动继承所有父类的便利构造器。"></a>情况2：子类提供了所有父类指定构造器的实现(通过情况1继承过来的或者子类自定义实现)，此时子类将自动继承所有父类的便利构造器。</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name:<span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> age: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">name</span>:<span class="type">String</span>, <span class="params">age</span>:<span class="type">Int</span>)&#123;</span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">        <span class="keyword">self</span>.age <span class="operator">=</span> age</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//父类的便利构造器</span></span><br><span class="line">    <span class="keyword">convenience</span> <span class="keyword">init</span>(<span class="params">name</span>:<span class="type">String</span>)&#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(name:name, age:<span class="number">10</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>: <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> nickName:<span class="type">String</span>!</span><br><span class="line">    <span class="comment">//实现了父类中的指定构造器</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>(<span class="params">name</span>:<span class="type">String</span>, <span class="params">age</span>:<span class="type">Int</span>)&#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(name:name, age:age)</span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">        <span class="keyword">self</span>.age <span class="operator">=</span> age <span class="operator">+</span> <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> ps <span class="operator">=</span> <span class="type">Person</span>(name: <span class="string">&quot;zs&quot;</span>, age: <span class="number">18</span>)</span><br></pre></td></tr></table></figure>

<p>自动继承注意：</p>
<ol>
<li>即使你在子类中添加了更多的便利构造器，这两条规则仍然适用。</li>
<li>对于情况 2，子类可以将父类的指定构造器实现为便利构造器。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wuyubeichen.github.io/2017/08/04/Swift%E5%AD%A6%E4%B9%A004-%E6%9E%84%E9%80%A0%E5%99%A8(%E4%B8%8A)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Author">
      <meta itemprop="description" content="iOS Developer, Beijing China">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="梧雨北辰的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/08/04/Swift%E5%AD%A6%E4%B9%A004-%E6%9E%84%E9%80%A0%E5%99%A8(%E4%B8%8A)/" class="post-title-link" itemprop="url">Swift学习04-构造器(上)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-08-04 18:15:31" itemprop="dateCreated datePublished" datetime="2017-08-04T18:15:31+08:00">2017-08-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-29 09:39:32" itemprop="dateModified" datetime="2022-08-29T09:39:32+08:00">2022-08-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Swift/" itemprop="url" rel="index"><span itemprop="name">Swift</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>主要内容：</strong></p>
<ol>
<li>构造器简介</li>
<li>默认构造器 - 最简单的构造器</li>
<li>逐一成员构造器：类中不存在，适用于结构体</li>
<li>可选型属性在构造器中的使用</li>
<li>构造器代理</li>
</ol>
<h4 id="一、构造器简介"><a href="#一、构造器简介" class="headerlink" title="一、构造器简介"></a>一、构造器简介</h4><p>Swift赋予自定义类型更加丰富的功能，一个显著地方就是构造过程。Swift可以为自定义类型设置构造器来初始化一个实例。有关Swift构造器的使用特点可以总结如下：</p>
<ol>
<li>构造器适用于类、结构体、枚举。是新的实例可用之前必须执行的一个过程</li>
<li>构造器具体的操作包括：必须保证所有存储型属性有合适初始值，执行其他必须的设置</li>
<li>构造器无需返回值，区别于OC</li>
<li>类的实例可以定义析构器，在实例释放之前执行特定的清除工作</li>
<li>存储型属性设置默认值和构造器中为其设置初始值，这种不会触发任何属性观察器</li>
</ol>
<h4 id="二、默认构造器-最简单的构造器"><a href="#二、默认构造器-最简单的构造器" class="headerlink" title="二、默认构造器 - 最简单的构造器"></a>二、默认构造器 - 最简单的构造器</h4><p>默认构造器原理：返回一个所有属性都使用其原有默认值的一个实例</p>
<p>存在默认构造器的条件:</p>
<ol>
<li>定义变量的时候，就可以保证所有属性都有可用的值。</li>
<li>没有自定义的构造器</li>
</ol>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span>  <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span>?</span><br><span class="line">    <span class="keyword">var</span> age <span class="operator">=</span> <span class="number">18</span></span><br><span class="line">    <span class="keyword">var</span> gender <span class="operator">=</span> <span class="string">&quot;男&quot;</span></span><br><span class="line">    <span class="comment">//如果存在schoolName，那就必须添加一个构造器来确保没有默认值的schoolName也能赋值</span></span><br><span class="line">    <span class="comment">//let schoolName:String</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> ps <span class="operator">=</span> <span class="type">Person</span>() <span class="comment">//使用了默认构造器</span></span><br></pre></td></tr></table></figure>

<h4 id="二、逐一成员构造器：类中不存在，适用于结构体"><a href="#二、逐一成员构造器：类中不存在，适用于结构体" class="headerlink" title="二、逐一成员构造器：类中不存在，适用于结构体"></a>二、逐一成员构造器：类中不存在，适用于结构体</h4><p>结构体不会像类一样，对构造器给予限制，必须保证每个属性都可用，因为除了默认构造器，结构体还有逐一成员构造器，可以对每个属性进行设置;</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Size</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> width <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">var</span> height:<span class="type">Int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//let size = Size() //此时不满足默认构造器条件1，不能使用</span></span><br><span class="line"><span class="keyword">let</span> size1 <span class="operator">=</span> <span class="type">Size</span>(width: <span class="number">10</span>, height: <span class="number">10</span>) <span class="comment">//使用逐一成员构造器</span></span><br></pre></td></tr></table></figure>

<h4 id="三、自定义构造器：输入参数的形式构造实例，满足多种情况的需要"><a href="#三、自定义构造器：输入参数的形式构造实例，满足多种情况的需要" class="headerlink" title="三、自定义构造器：输入参数的形式构造实例，满足多种情况的需要"></a>三、自定义构造器：输入参数的形式构造实例，满足多种情况的需要</h4><ol>
<li>常量只能被赋值一次，所有如果定义常量时有默认值，即使是构造函数也不能修改此值</li>
<li>对于类的实例，它的常量属性只能在定义它的类的构造函数中修改，不能在子类中修改</li>
</ol>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> type <span class="operator">=</span> <span class="string">&quot;学生&quot;</span></span><br><span class="line">    <span class="keyword">let</span> name :<span class="type">String</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">name</span> :<span class="type">String</span>)&#123;</span><br><span class="line">        <span class="comment">//self.type = &quot;教师&quot;  //不能修改已经有默认值的常量属性</span></span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> name  <span class="comment">//构造函数必须保证所有值可用，此处赋值操作必须有</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="四、可选型属性在构造器中的使用"><a href="#四、可选型属性在构造器中的使用" class="headerlink" title="四、可选型属性在构造器中的使用"></a>四、可选型属性在构造器中的使用</h4><p>使用可选型是因为在业务逻辑上允许此属性为<code>nil</code>，包括两种情况如下：</p>
<ol>
<li>初始化的时候无法为其赋值,只能默认<code>nil</code>；</li>
<li>在后续使用中需要将其赋值为<code>nil</code>；</li>
</ol>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name:<span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> age:<span class="type">Int</span>?</span><br><span class="line">    <span class="keyword">init</span>(<span class="params">name</span>:<span class="type">String</span>)&#123;</span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">        <span class="comment">//以为age是可选型，存在默认值nil,所以构造函数不为其设置值也不报错</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="五、构造器代理"><a href="#五、构造器代理" class="headerlink" title="五、构造器代理"></a>五、构造器代理</h4><p>构造器通过调用其他构造器来完成实例的部分构造，被称为构造器代理,实现减少代码重复，构造器代理分为两种：</p>
<ul>
<li>值类型构造器代理：适用于值类型（结构体&#x2F;枚举），没有继承等复杂过程，较为简单</li>
<li>类构造器代理：因为有涉及到继承，需要保证所有继承属性也能正确的初始化（也即是便利构造器，见下篇）</li>
</ul>
<p>注意：</p>
<ol>
<li>对于值类型，可以在自定义构造器中使用self.init来调用其他构造器</li>
<li>如果值类型定义了自定义构造器将不能使用默认构造器和逐一成员构造器。解决办法：将自定义构造器写在扩展里，而不是值类型的原始定义中</li>
</ol>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">NewSize</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> width <span class="operator">=</span> <span class="number">0.0</span> , height <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="operator">=</span> <span class="number">0.0</span>, y <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rect</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> origin <span class="operator">=</span> <span class="type">Point</span>()</span><br><span class="line">    <span class="keyword">var</span> size <span class="operator">=</span> <span class="type">NewSize</span>()</span><br><span class="line">    <span class="comment">//构造器1：与默认构造函数一样，全部使用默认值</span></span><br><span class="line">    <span class="keyword">init</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器2: 与逐一成员构造器一样</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">origin</span>:<span class="type">Point</span>, <span class="params">size</span>:<span class="type">NewSize</span>)&#123;</span><br><span class="line">        <span class="keyword">self</span>.origin <span class="operator">=</span> origin</span><br><span class="line">        <span class="keyword">self</span>.size  <span class="operator">=</span> size</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器3：调用了构造器2方法</span></span><br><span class="line">    <span class="comment">//如果我们不去实现构造器2，将不能调用与其功能相似的逐一成员构造器</span></span><br><span class="line">    <span class="comment">//所以我们可以参考扩展，将自定义方法写在扩展中，就不必这样麻烦了</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">center</span>: <span class="type">Point</span>, <span class="params">size</span>: <span class="type">NewSize</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> originX <span class="operator">=</span> center.x <span class="operator">-</span> (size.width <span class="operator">/</span> <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">let</span> originY <span class="operator">=</span> center.y <span class="operator">-</span> (size.height <span class="operator">/</span> <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(origin: <span class="type">Point</span>(x: originX, y: originY), size: size)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wuyubeichen.github.io/2017/08/03/Swift%E5%AD%A6%E4%B9%A003-%E9%97%AD%E5%8C%85/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Author">
      <meta itemprop="description" content="iOS Developer, Beijing China">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="梧雨北辰的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/08/03/Swift%E5%AD%A6%E4%B9%A003-%E9%97%AD%E5%8C%85/" class="post-title-link" itemprop="url">Swift学习03-闭包</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-08-03 18:12:53" itemprop="dateCreated datePublished" datetime="2017-08-03T18:12:53+08:00">2017-08-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-29 09:39:32" itemprop="dateModified" datetime="2022-08-29T09:39:32+08:00">2022-08-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Swift/" itemprop="url" rel="index"><span itemprop="name">Swift</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>闭包</strong>：是自包含的函数代码块，可以在代码中被传递和使用。<code>Swift</code>中的闭包与<code>C</code>和 <code>Objective-C</code>中的代码块(<code>blocks</code>)以及其他一些编程语言中的匿名函数比较相似；</p>
<p><strong>主要内容：</strong></p>
<ol>
<li>闭包表达式</li>
<li>闭包的使用与优化</li>
<li>值捕获</li>
<li>逃逸闭包</li>
<li>自动闭包</li>
</ol>
<h4 id="一、闭包表达式"><a href="#一、闭包表达式" class="headerlink" title="一、闭包表达式"></a>一、闭包表达式</h4><p><code>Swift</code>闭包的三种存在形式：</p>
<ol>
<li>全局函数是一个有名字但不会捕获任何值的闭包</li>
<li>嵌套函数是一个有名字并可以捕获其封闭函数域内值的闭包</li>
<li>闭包表达式是一个利用轻量级语法所写的可以捕获其上下文中变量或常量值的匿名闭包 闭包表达式的语法一般有如下的一般形式:</li>
</ol>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; (parameters) -&gt; returnType <span class="keyword">in</span></span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明:</strong></p>
<ol>
<li>闭包的外层是一个大括号，先写的参数和返回值，然后操作部分之前使用<code>in</code>；</li>
<li>闭包就相当于<code>OC</code>中的<code>block</code>, 也可以看做是匿名函数；</li>
<li>闭包表达式参数可以是<code>in-out</code>参数，但不能设定默认值；</li>
<li>闭包的函数体部分由关键字<code>in</code>引入，该关键字表示闭包参数和返回值类型已经完成，闭包函数体开始；</li>
</ol>
<h4 id="二、闭包的使用与优化"><a href="#二、闭包的使用与优化" class="headerlink" title="二、闭包的使用与优化"></a>二、闭包的使用与优化</h4><p>下面，我们使用<code>Swift</code>标准库中的<code>sorted(by:)</code>方法来测试闭包的使用。</p>
<p><code>sorted(by:)</code>方法允许外部传入一个用于排序的闭包函数，将已知类型数组中的值进行排序，完成排序之后，该方法会返回一个与原数组大小相同，包含同类型元素已正确排序的新数组:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个整型数组</span></span><br><span class="line"><span class="keyword">var</span> someInts: [<span class="type">Int</span>] <span class="operator">=</span> [<span class="number">5</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line"><span class="comment">//定义一个排序函数</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">biggerNumFirst</span>(<span class="params">num1</span>:<span class="type">Int</span>, <span class="params">num2</span>:<span class="type">Int</span>) -&gt; <span class="type">Bool</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 <span class="operator">&gt;</span> num2</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//普通用法：将biggerNumFirst函数传入sorted函数，实现排序</span></span><br><span class="line"><span class="keyword">var</span> sortInts <span class="operator">=</span> someInts.sorted(by: biggerNumFirst)</span><br><span class="line"><span class="built_in">print</span>(sortInts)     <span class="comment">//[9, 7, 5, 3, 1, 0]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//闭包用法：为sorted函数参数传入一个闭包，实现排序</span></span><br><span class="line">sortInts <span class="operator">=</span> someInts.sorted(by:&#123; (a:<span class="type">Int</span>, b:<span class="type">Int</span>) -&gt; <span class="type">Bool</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> a <span class="operator">&gt;</span> b</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">print</span>(sortInts)     <span class="comment">//[9, 7, 5, 3, 1, 0]</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：因为闭包不会在其他地方调用，所以不使用外部参数名</strong></p>
<p>闭包使用起来十分灵活，我们可以在某些特定情况下对齐进行优化，下面是对上述闭包的优化：</p>
<h5 id="2-1-根据上下文推断类型，省略参数类型与括号"><a href="#2-1-根据上下文推断类型，省略参数类型与括号" class="headerlink" title="2.1.根据上下文推断类型，省略参数类型与括号"></a>2.1.根据上下文推断类型，省略参数类型与括号</h5><p>由于排序闭包函数是作为<code>sorted(by:)</code>方法的参数传入的，<code>Swift</code>可以推断其类型和返回值类型。所以<code>sorted(by:)</code>方法被一个<code>Int</code>类型的数组调用，其参数必定是<code>(Int,Int)-&gt;Bool</code>类型的函数。</p>
<p>最后，根据上下文推断类型，我们可以省略参数类型和参数周围的括号：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sortInts <span class="operator">=</span> someInts.sorted(by: &#123;a,b <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> a <span class="operator">&gt;</span> b</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">print</span>(sortInts)</span><br></pre></td></tr></table></figure>

<h5 id="2-2-对于不会发生歧义的闭包，可将其写成一行"><a href="#2-2-对于不会发生歧义的闭包，可将其写成一行" class="headerlink" title="2.2.对于不会发生歧义的闭包，可将其写成一行"></a>2.2.对于不会发生歧义的闭包，可将其写成一行</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sortInts <span class="operator">=</span> someInts.sorted(by:&#123;a,b <span class="keyword">in</span> <span class="keyword">return</span> a <span class="operator">&gt;</span> b&#125;)</span><br><span class="line"><span class="built_in">print</span>(sortInts)</span><br></pre></td></tr></table></figure>

<h5 id="2-3-单行闭包表达式，省略return关键字"><a href="#2-3-单行闭包表达式，省略return关键字" class="headerlink" title="2.3.单行闭包表达式，省略return关键字"></a>2.3.单行闭包表达式，省略return关键字</h5><p>省略<code>return</code>关键字的条件：</p>
<ol>
<li><code>sorted(by:)</code>方法的参数类型明确了闭包必须返回一个<code>Bool</code>类型值；</li>
<li>单行闭包表达式中，其返回值类型没有歧义；</li>
</ol>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sortInts <span class="operator">=</span> someInts.sorted(by: &#123;a,b <span class="keyword">in</span> a <span class="operator">&gt;</span> b&#125;)</span><br><span class="line"><span class="built_in">print</span>(sortInts)</span><br></pre></td></tr></table></figure>

<h5 id="2-4-使用参数名缩写-不推荐使用"><a href="#2-4-使用参数名缩写-不推荐使用" class="headerlink" title="2.4.使用参数名缩写(不推荐使用)"></a>2.4.使用参数名缩写(不推荐使用)</h5><p><code>Swift</code>自动为内联闭包提供了参数名称缩写功能，你可以直接通过<code>$0</code>，<code>$1</code>，<code>$2</code> 来顺序调用闭包的参数，以此类推；</p>
<p>如果我们在闭包表达式中使用参数名称缩写， 我们就可以在闭包定义中省略参数列表，并且对应参数名称缩写的类型会通过函数类型进行推断。<code>in</code>关键字也同样可以被省略，因为此时闭包表达式完全由闭包函数体构成：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sortInts <span class="operator">=</span> someInts.sorted(by: &#123;<span class="variable">$0</span><span class="operator">&gt;</span><span class="variable">$1</span>&#125;)</span><br><span class="line"><span class="built_in">print</span>(sortInts)</span><br></pre></td></tr></table></figure>

<h5 id="2-5-使用运算符简化闭包-不推荐使用"><a href="#2-5-使用运算符简化闭包-不推荐使用" class="headerlink" title="2.5.使用运算符简化闭包(不推荐使用)"></a>2.5.使用运算符简化闭包(不推荐使用)</h5><p><code>Swift</code>的<code>Int</code>类型定义了关于大于号（<code>&gt;</code>）的字符串实现，其作为一个函数接受两个<code>Int</code>类型的参数并返回<code>Bool</code>类型的值。而这正好与<code>sorted(by:)</code>方法的参数需要的函数类型相符合。可以使用大于号来代替闭包</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sortInts <span class="operator">=</span> someInts.sorted(by: <span class="operator">&gt;</span>)</span><br><span class="line"><span class="built_in">print</span>(sortInts)</span><br></pre></td></tr></table></figure>

<h5 id="2-6-尾随闭包，解决长闭包的书写问题"><a href="#2-6-尾随闭包，解决长闭包的书写问题" class="headerlink" title="2.6.尾随闭包，解决长闭包的书写问题"></a>2.6.尾随闭包，解决长闭包的书写问题</h5><p>定义：将一个很长的闭包表达式作为最后一个参数传递给函数，可以使用尾随闭包来增强函数的可读性；</p>
<p>写法：将闭包书写在函数括号之后，函数会支持将其作为最后一个参数调用，使用尾随闭包，不需要写出它的参数标签；</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">someFunctionThatTakesAClosure</span>(<span class="params">closure</span>: () -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    <span class="comment">//函数体部分</span></span><br><span class="line">    closure(); <span class="comment">//调用闭包</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不使用尾随闭包进行函数调用</span></span><br><span class="line">someFunctionThatTakesAClosure(closure: &#123;</span><br><span class="line">    <span class="comment">//闭包主体部分</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用尾随闭包进行函数调用</span></span><br><span class="line">someFunctionThatTakesAClosure() &#123;</span><br><span class="line">    <span class="comment">//闭包主体部分</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意：如果闭包表达式是函数或方法的唯一参数，则当你使用尾随闭包时，你甚至可以把 () 省略掉：</span></span><br><span class="line">someFunctionThatTakesAClosure &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello World!&quot;</span>)    <span class="comment">//打印：Hello World!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结<code>Swift</code>闭包主要的四种优化方法：</p>
<ol>
<li>利用上下文推断参数和返回值类型，省略参数类型与括号；</li>
<li>隐式返回单表达式闭包，即单表达式闭包可以省略<code>return</code>关键字；</li>
<li>参数名称缩写；</li>
<li>尾随闭包语法；</li>
</ol>
<h4 id="三、值捕获"><a href="#三、值捕获" class="headerlink" title="三、值捕获"></a>三、值捕获</h4><p>闭包可以在其被定义的上下文中捕获常量或变量。即使定义这些常量和变量的原作用域已经不存在，闭包仍然可以在闭包函数体内引用和修改这些值。<code>Swift</code>会为你管理在捕获过程中涉及到的所有内存操作；</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">makeIncrementer</span>(<span class="params">forIncrement</span> <span class="params">amount</span>: <span class="type">Int</span>) -&gt; () -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> runningTotal <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">incrementer</span>() -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        runningTotal <span class="operator">+=</span> amount</span><br><span class="line">        <span class="keyword">return</span> runningTotal</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> incrementer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码分析：</p>
<ol>
<li><code>makeIncrementer</code>函数以<code>amount</code>为参数，以<code>()-&gt;Int</code>作为返回值类型，其函数体中还嵌套了另一个函数<code>incrementer</code>；</li>
<li>如果我们把<code>incrementer</code>单独拿出来，会发现其中<code>runingTotal</code>和<code>amount</code>变量都无法使用，因为这两个变量的引用是<code>incrementer</code>从外部捕获的；</li>
<li><code>Swift</code>会负责被捕获变量的所有内存管理工作，包括对捕获的一份值拷贝，也包括释放不再需要的变量；</li>
</ol>
<p>现在再来测试<code>makeIncrementer</code>函数的使用:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> incrementByTen <span class="operator">=</span> makeIncrementer(forIncrement: <span class="number">10</span>)</span><br><span class="line">incrementByTen();    <span class="comment">//10</span></span><br><span class="line">incrementByTen();    <span class="comment">//20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> incrementBySeven <span class="operator">=</span> makeIncrementer(forIncrement: <span class="number">7</span>)</span><br><span class="line">incrementBySeven()   <span class="comment">//7</span></span><br><span class="line">incrementBySeven();  <span class="comment">//14</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> alsoIncrementByTen <span class="operator">=</span> incrementByTen</span><br><span class="line">alsoIncrementByTen() <span class="comment">//30</span></span><br></pre></td></tr></table></figure>

<p>代码分析:</p>
<ol>
<li><code>incrementByTen</code>与<code>incrementBySeven</code>，是通过<code>makeIncrementer</code>函数传入不同的增量参数<code>amount</code>而创建的；</li>
<li>两个函数都有属于各自的引用，其中的<code>runningTotal</code>变量都是从<code>makeIncrementer</code>中捕获的，但是已经各自没有关系；</li>
<li>函数和闭包都是引用类型，将其赋值给变量或者常量，都只是操作的它们的引用，而不会改变闭包或者函数本身；</li>
</ol>
<h4 id="四、逃逸闭包"><a href="#四、逃逸闭包" class="headerlink" title="四、逃逸闭包"></a>四、逃逸闭包</h4><p>当一个闭包作为参数传到一个函数中，但是这个闭包在<strong>函数返回之后才被执行</strong>，我们称该闭包从函数中逃逸。</p>
<p>逃逸闭包：在定义接受闭包作为参数的函数时，我们需要在参数名之前标注<code>@escaping</code>，以此表明这个闭包是允许”逃逸”出这个函数的。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> completionHandlers: [() -&gt; <span class="type">Void</span>] <span class="operator">=</span> []</span><br><span class="line"><span class="keyword">func</span> <span class="title function_">someFunctionWithEscapingClosure</span>(<span class="params">completionHandler</span>: <span class="keyword">@escaping</span> () -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    <span class="comment">//代码1：执行闭包，不需要添加@escaping</span></span><br><span class="line">    <span class="comment">//completionHandler();</span></span><br><span class="line">    <span class="comment">//代码2：函数外部对闭包进行了操作</span></span><br><span class="line">    completionHandlers.append(completionHandler)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>代码分析： <code>someFunctionWithEscapingClosure(_:)</code> 函数接受一个闭包作为参数，该闭包被添加到一个函数外定义的数组中。如果不将这个参数标记为<code>@escaping</code>，就会得到一个编译错误。</p>
<h5 id="4-1-逃逸闭包的使用"><a href="#4-1-逃逸闭包的使用" class="headerlink" title="4.1.逃逸闭包的使用"></a>4.1.逃逸闭包的使用</h5><p>逃逸闭包和非逃逸闭包在使用上有所不同。将一个闭包标记为<code>@escaping</code>(即逃逸闭包)后，在调用这个闭包时就必须在闭包中显式地引用 <code>self</code>。一个示例如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个带有非逃逸闭包参数的函数</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">someFunctionWithNonescapingClosure</span>(<span class="params">closure</span>: () -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    closure()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个可以使用闭包的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SomeClass</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="operator">=</span> <span class="number">10</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">doSomething</span>() &#123;</span><br><span class="line">        <span class="comment">//调用逃逸闭包：必须在闭包中显式引用self</span></span><br><span class="line">        someFunctionWithEscapingClosure &#123; <span class="keyword">self</span>.x <span class="operator">=</span> <span class="number">100</span> &#125;</span><br><span class="line">        <span class="comment">//调用非逃逸闭包：可以隐式引用self</span></span><br><span class="line">        someFunctionWithNonescapingClosure &#123; x <span class="operator">=</span> <span class="number">200</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance <span class="operator">=</span> <span class="type">SomeClass</span>()</span><br><span class="line">instance.doSomething()</span><br><span class="line"><span class="built_in">print</span>(instance.x)         <span class="comment">//打印出 &quot;200”</span></span><br></pre></td></tr></table></figure>

<h4 id="五、自动闭包"><a href="#五、自动闭包" class="headerlink" title="五、自动闭包"></a>五、自动闭包</h4><p><strong>自动闭包：</strong>一种自动创建的闭包，用与包装传递给函数作为参数的表达式；</p>
<ol>
<li>自动闭包不接受任何参数；</li>
<li>自动闭包被调用的时候，会返回被包装在其中的表达式的值；</li>
<li>自动闭包是用一个普通的表达式来代替显式的闭包，能够省略闭包的花括号；</li>
</ol>
<p>其实，我们经常调用采用自动闭包的函数，但是却少去实现这样的函数，<code>assert</code>函数就是其中之一：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">assert</span>(condition:, message:)</span><br></pre></td></tr></table></figure>

<p><code>assert</code>函数中：</p>
<ol>
<li><code>condition</code>参数可以接受自动闭包作为值，<code>condition</code>参数仅会在<code>debug</code>模式下被求值；</li>
<li>在<code>condidtion</code>被调用返回值为<code>false</code>时，<code>message</code>参数将被使用。</li>
</ol>
<h5 id="5-1-自动闭包的基本使用"><a href="#5-1-自动闭包的基本使用" class="headerlink" title="5.1.自动闭包的基本使用"></a>5.1.自动闭包的基本使用</h5><p>自动闭包能够实现延迟求值，直到调用这个闭包时，代码才会被执行。这对于有副作用或者高计算成本的代码来说是有益处的;下面的代码展示了自动闭包实现延时求值的具体做法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> customersInLine <span class="operator">=</span> [<span class="string">&quot;Chris&quot;</span>, <span class="string">&quot;Alex&quot;</span>, <span class="string">&quot;Ewa&quot;</span>, <span class="string">&quot;Barry&quot;</span>, <span class="string">&quot;Daniella&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(customersInLine.count)    <span class="comment">//打印出 “5&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//自动闭包不接受参数，只是一个表达式</span></span><br><span class="line"><span class="keyword">let</span> customerProvider <span class="operator">=</span> &#123; customersInLine.remove(at: <span class="number">0</span>) &#125;</span><br><span class="line"><span class="built_in">print</span>(customersInLine.count)    <span class="comment">//打印出 “5&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//调用自动闭包</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Now serving <span class="subst">\(customerProvider())</span>!&quot;</span>)   <span class="comment">// Prints &quot;Now serving Chris!&quot;</span></span><br><span class="line"><span class="built_in">print</span>(customersInLine.count)               <span class="comment">//打印出 &quot;4”</span></span><br></pre></td></tr></table></figure>

<p>代码分析：闭包实现了移除第一元素的功能，但是在闭包被调用之前，这个元素是不会被移除的。这就实现了延迟的作用</p>
<h5 id="5-2-自动闭包在函数中的使用"><a href="#5-2-自动闭包在函数中的使用" class="headerlink" title="5.2.自动闭包在函数中的使用"></a>5.2.自动闭包在函数中的使用</h5><p>现在将闭包作为参数传递给一个函数，同样可以实现延时求值行为。下面的<code>serve</code>函数接受了一个闭包参数(具有删除第一个元素且返回这个元素的功能)；</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//customersInLine is [&quot;Alex&quot;, &quot;Ewa&quot;, &quot;Barry&quot;, &quot;Daniella&quot;]</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">serve</span>(<span class="params">customer</span> <span class="params">customerProvider</span>: () -&gt; <span class="type">String</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Now serving <span class="subst">\(customerProvider())</span>!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以闭包的形式传入参数</span></span><br><span class="line">serve(customer: &#123; customersInLine.remove(at: <span class="number">0</span>) &#125; )  <span class="comment">//打印出&quot;Now serving Alex!”</span></span><br></pre></td></tr></table></figure>

<p>现在使用自动闭包来实现上述函数功能，使用<code>@autoclosure</code>关键字，标明参数使用的是自动闭包，具体示例如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// customersInLine is [&quot;Ewa&quot;, &quot;Barry&quot;, &quot;Daniella&quot;]</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">serve</span>(<span class="params">customer</span> <span class="params">customerProvider</span>: <span class="keyword">@autoclosure</span> () -&gt; <span class="type">String</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Now serving <span class="subst">\(customerProvider())</span>!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//由于标明了自动闭包，这里直接省略了闭包的花括号</span></span><br><span class="line">serve(customer: customersInLine.remove(at: <span class="number">0</span>))  <span class="comment">//打印出&quot;Now serving Ewa!\n&quot;</span></span><br></pre></td></tr></table></figure>

<p>注意：<strong>过度使用 autoclosures 会让你的代码变得难以理解。上下文和函数名应该能够清晰地表明求值是被延迟执行的。</strong></p>
<h5 id="5-3-可”逃逸”的自动闭包"><a href="#5-3-可”逃逸”的自动闭包" class="headerlink" title="5.3.可”逃逸”的自动闭包"></a>5.3.可”逃逸”的自动闭包</h5><p>一个自动闭包可以“逃逸”，这时候应该同时使用<code>@autoclosure</code> 和 <code>@escaping</code> 属性，下面举例说明：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// customersInLine is [&quot;Barry&quot;, &quot;Daniella&quot;]</span></span><br><span class="line"><span class="keyword">var</span> customerProviders: [() -&gt; <span class="type">String</span>] <span class="operator">=</span> []</span><br><span class="line"><span class="keyword">func</span> <span class="title function_">collectCustomerProviders</span>(<span class="keyword">_</span> <span class="params">customerProvider</span>: <span class="keyword">@autoclosure</span> <span class="keyword">@escaping</span> () -&gt; <span class="type">String</span>) &#123;</span><br><span class="line">    customerProviders.append(customerProvider)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用collectCustomerProviders，向数组中追加闭包</span></span><br><span class="line">collectCustomerProviders(customersInLine.remove(at: <span class="number">0</span>))</span><br><span class="line">collectCustomerProviders(customersInLine.remove(at: <span class="number">0</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Collected <span class="subst">\(customerProviders.count)</span> closures.&quot;</span>)   <span class="comment">//打印 &quot;Collected 2 closures.&quot;</span></span><br><span class="line"><span class="comment">//循环数组中闭包，并且执行</span></span><br><span class="line"><span class="keyword">for</span> customerProvider <span class="keyword">in</span> customerProviders &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Now serving <span class="subst">\(customerProvider())</span>!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 &quot;Now serving Barry!&quot;</span></span><br><span class="line"><span class="comment">// 打印 &quot;Now serving Daniella!”</span></span><br></pre></td></tr></table></figure>

<p>代码分析：</p>
<ol>
<li>作为逃逸闭包：<code>collectCustomerProviders</code>函数中，闭包<code>customerProvider</code>被追加到<code>customerProviders</code>中，而这个数据是定义在函数作用域范围之外的，这意味数组内的闭包能够在函数返回之后被调用，所以<code>customerProvider</code>必须允许”逃逸”出函数作用域；</li>
<li>作为自动闭包：调用<code>collectCustomerProviders</code>函数时，传入的闭包是表达式的形式，自动闭包省略了闭包花括号；</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wuyubeichen.github.io/2017/08/02/Swift%E5%AD%A6%E4%B9%A002-%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Author">
      <meta itemprop="description" content="iOS Developer, Beijing China">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="梧雨北辰的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/08/02/Swift%E5%AD%A6%E4%B9%A002-%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">Swift学习02-函数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-08-02 18:14:31" itemprop="dateCreated datePublished" datetime="2017-08-02T18:14:31+08:00">2017-08-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-29 09:39:32" itemprop="dateModified" datetime="2022-08-29T09:39:32+08:00">2022-08-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Swift/" itemprop="url" rel="index"><span itemprop="name">Swift</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>函数</strong>：是一段完成特定任务的独立代码片段。你可以通过给函数命名来标识某个函数的功能，这个名字可以被用来在需要的时候”调用”这个函数来完成它的任务；</p>
<p><strong>主要内容：</strong></p>
<ol>
<li>函数的定义与调用</li>
<li>函数参数与返回值</li>
<li>函数外部参数名和参数名称</li>
<li>默认参数</li>
<li>可变参数</li>
<li>输入输出参数</li>
<li>函数类型</li>
<li>函数类型</li>
</ol>
<h1 id="一、函数的定义与调用"><a href="#一、函数的定义与调用" class="headerlink" title="一、函数的定义与调用"></a>一、函数的定义与调用</h1><p>下面演示了在Swift中，定义函数和调用函数的基本操作：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义函数</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">greet</span>(<span class="params">person</span>: <span class="type">String</span>) -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> greeting <span class="operator">=</span> <span class="string">&quot;Hello, &quot;</span> <span class="operator">+</span> person <span class="operator">+</span> <span class="string">&quot;!&quot;</span></span><br><span class="line">    <span class="keyword">return</span> greeting</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用函数</span></span><br><span class="line"><span class="built_in">print</span>(greet(person: <span class="string">&quot;Anna&quot;</span>))         <span class="comment">// 打印 &quot;Hello, Anna!”</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">greetAgain</span>(<span class="params">person</span>: <span class="type">String</span>) -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello again, &quot;</span> <span class="operator">+</span> person <span class="operator">+</span> <span class="string">&quot;!&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(greetAgain(person: <span class="string">&quot;Anna&quot;</span>))    <span class="comment">// 打印 &quot;Hello again, Anna!”</span></span><br></pre></td></tr></table></figure>

<h1 id="二、函数参数与返回值"><a href="#二、函数参数与返回值" class="headerlink" title="二、函数参数与返回值"></a>二、函数参数与返回值</h1><h4 id="2-1-无参，有返回值函数"><a href="#2-1-无参，有返回值函数" class="headerlink" title="2.1.无参，有返回值函数"></a>2.1.无参，有返回值函数</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">sayHi</span>() -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hi！&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(sayHi())</span><br></pre></td></tr></table></figure>

<h4 id="2-2-多参，有返回值函数"><a href="#2-2-多参，有返回值函数" class="headerlink" title="2.2.多参，有返回值函数"></a>2.2.多参，有返回值函数</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">sayHi</span>(<span class="params">person</span>: <span class="type">String</span>, <span class="params">greet</span>: <span class="type">String</span>) -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> greetString <span class="operator">=</span> greet  <span class="operator">+</span> person</span><br><span class="line">    <span class="keyword">return</span> greetString</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(sayHi(person: <span class="string">&quot;zhoushuai&quot;</span>, greet: <span class="string">&quot;Hi！&quot;</span>))</span><br></pre></td></tr></table></figure>

<h4 id="2-3-无返回值函数"><a href="#2-3-无返回值函数" class="headerlink" title="2.3.无返回值函数"></a>2.3.无返回值函数</h4><p>严格意义上，虽然没有返回值，但是sayHello函数依然返回了值。没有定义返回类型的函数会返回一个特殊的Void值。它其实是一个空的元组(tuple)，没有任何元素，可以写成()</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">sayHi</span>(<span class="params">person</span>: <span class="type">String</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hi-Hi, <span class="subst">\(person)</span>!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">sayHi(person: <span class="string">&quot;Tom”)  //打印 &quot;</span><span class="type">Hi</span><span class="operator">-</span><span class="type">Hi</span>, <span class="type">Tom</span>!”</span><br><span class="line"></span><br><span class="line"><span class="comment">//sayHello函数与下面的两个函数，会被Swift识别为同一种函数，进而报错重复定义。</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">func sayHi(person: String) -&gt;()&#123;</span></span><br><span class="line"><span class="comment">    print(&quot;Hello, \(person)!&quot;)</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">func sayHi(person: String) -&gt;Void &#123;</span></span><br><span class="line"><span class="comment">    print(&quot;Hello, \(person)!&quot;)</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="2-4-多重返回值函数"><a href="#2-4-多重返回值函数" class="headerlink" title="2.4.多重返回值函数"></a>2.4.多重返回值函数</h4><p>可以用元组（tuple）类型让多个值作为一个复合值从函数中返回,即返回多个参数</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">findMaxMin</span>(<span class="params">array</span>:[<span class="type">Int</span>]) -&gt;(max:<span class="type">Int</span>,min:<span class="type">Int</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> max <span class="operator">=</span> array.max()</span><br><span class="line">    <span class="keyword">let</span> min <span class="operator">=</span> array.min()</span><br><span class="line">    <span class="keyword">return</span> (max<span class="operator">!</span>,min<span class="operator">!</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> bounds <span class="operator">=</span> findMaxMin(array: [<span class="number">8</span>, <span class="operator">-</span><span class="number">6</span>, <span class="number">2</span>, <span class="number">109</span>, <span class="number">3</span>, <span class="number">71</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;min is <span class="subst">\(bounds.min)</span> and max is <span class="subst">\(bounds.max)</span>&quot;</span>)</span><br><span class="line"><span class="comment">//打印 &quot;min is -6 and max is 109</span></span><br></pre></td></tr></table></figure>

<h4 id="2-5-可选返回值类型"><a href="#2-5-可选返回值类型" class="headerlink" title="2.5.可选返回值类型"></a>2.5.可选返回值类型</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">findMaxMin2</span>(<span class="params">array</span>:[<span class="type">Int</span>]) -&gt;(max:<span class="type">Int</span>,min:<span class="type">Int</span>)<span class="operator">?</span>&#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="operator">!</span>array.isEmpty <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> maxVlaue <span class="operator">=</span> array[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">var</span> minValue <span class="operator">=</span> array[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> number <span class="keyword">in</span> array&#123;</span><br><span class="line">        maxVlaue <span class="operator">=</span> maxVlaue <span class="operator">&gt;</span> number <span class="operator">?</span> maxVlaue : number</span><br><span class="line">        minValue <span class="operator">=</span> minValue <span class="operator">&lt;</span> number <span class="operator">?</span> minValue : number</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回的类型是可选型，因为结果有可能是nil</span></span><br><span class="line">    <span class="keyword">return</span> (maxVlaue, minValue)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> bounds2 <span class="operator">=</span> findMaxMin2(array: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;min is <span class="subst">\(bounds2.min)</span> and max is <span class="subst">\(bounds2.max)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：可选元组类型如 (Int, Int)? 与元组包含可选类型如 (Int?, Int?) 是不同的.可选的元组类型，整个元组是可选的，而不只是元组中的每个元素值。</p>
<h4 id="2-6-无参，无返回值函数"><a href="#2-6-无参，无返回值函数" class="headerlink" title="2.6.无参，无返回值函数"></a>2.6.无参，无返回值函数</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">sayHiHi</span>()&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;sayHiHi:无参五返回值的函数！&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">sayHiHi()</span><br></pre></td></tr></table></figure>

<h1 id="三、函数外部参数名和参数名称"><a href="#三、函数外部参数名和参数名称" class="headerlink" title="三、函数外部参数名和参数名称"></a>三、函数外部参数名和参数名称</h1><p>每个函数参数都有一个外部参数名(参数标签)以及参数名称，只不过默认情况下，函数参数直接使用参数名来作为它们的外部参数名。下面来总结函数外部参数名的各种用法。</p>
<h4 id="3-1-指定外部参数名，让函数表意更明确"><a href="#3-1-指定外部参数名，让函数表意更明确" class="headerlink" title="3.1.指定外部参数名，让函数表意更明确"></a>3.1.指定外部参数名，让函数表意更明确</h4><p>函数外部参数名的使用能够让一个函数在调用时更有表达力，更类似自然语言，并且仍保持了函数内部的可读性以及清晰的意图。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正常写法：</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">sayHelloTo</span>(<span class="params">name</span>: <span class="type">String</span> , <span class="params">greeting</span>: <span class="type">String</span>) -&gt; <span class="type">String</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;<span class="subst">\(greeting)</span>, <span class="subst">\(name)</span>!&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(sayHelloTo(name: <span class="string">&quot;风恣&quot;</span>, greeting: <span class="string">&quot;Hello”)) </span></span><br><span class="line"><span class="string">//打印：&quot;</span><span class="type">Hello，风恣！</span><span class="string">&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//改进上面的函数，为第二个参数指定外部参数名，让表意更加明确</span></span><br><span class="line"><span class="string">func sayHelloTo(name: String, withGreetingWord greeting:String) -&gt; String&#123;</span></span><br><span class="line"><span class="string">    return &quot;</span>\(greeting),\(name)<span class="string">&quot;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">print(sayHelloTo(name: &quot;</span><span class="type">FengZi</span><span class="string">&quot;, withGreetingWord: &quot;</span><span class="type">Hello</span><span class="string">&quot;))</span></span><br><span class="line"><span class="string">//打印：&quot;</span><span class="type">Hello，FengZi</span><span class="string">&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>特别说明</strong>： <strong>一般情况下，第一个参数不设置外部参数名，因为第一个参数的外部参数名是隐藏在函数名中的。</strong></p>
<h4 id="3-2-忽略参数标签"><a href="#3-2-忽略参数标签" class="headerlink" title="3.2.忽略参数标签"></a>3.2.忽略参数标签</h4><p>有时候，使用外部参数名反而会使函数更加繁琐，这又需要隐藏外部参数名：这时候使用下划线**”_“**来代替一个明确的参数标签。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正常写法：</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">mutipleOf</span>(<span class="params">num1</span>: <span class="type">Int</span>, <span class="params">and</span> <span class="params">num2</span>:<span class="type">Int</span>)-&gt; <span class="type">Int</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 <span class="operator">*</span> num2</span><br><span class="line">&#125;</span><br><span class="line">mutipleOf(num1: <span class="number">1</span>, and: <span class="number">6</span>)    <span class="comment">//6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//改进1：忽略参数标签</span></span><br><span class="line"><span class="keyword">func</span>  <span class="title function_">mutipleOf</span>(<span class="params">num1</span>:<span class="type">Int</span> , <span class="params">num2</span>:<span class="type">Int</span>) -&gt; <span class="type">Int</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 <span class="operator">*</span> num2;</span><br><span class="line">&#125;</span><br><span class="line">mutipleOf(num1: <span class="number">1</span>, num2: <span class="number">6</span>)   <span class="comment">//6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//改进2:彻底不使用参数名,使用下划线省略</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">mutiply</span>(<span class="keyword">_</span> <span class="params">num1</span>:<span class="type">Int</span>, <span class="keyword">_</span> <span class="params">num2</span>:<span class="type">Int</span>) -&gt; <span class="type">Int</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 <span class="operator">*</span> num2</span><br><span class="line">&#125;</span><br><span class="line">mutiply(<span class="number">1</span>, <span class="number">6</span>)                <span class="comment">//6</span></span><br></pre></td></tr></table></figure>

<h1 id="四、默认参数"><a href="#四、默认参数" class="headerlink" title="四、默认参数"></a>四、默认参数</h1><p>定义函数的时候，可以给某些参数设置默认值(Deafult Value)，当默认值被定义后，调用这个函数时可以忽略这个参数。 下面的函数包括两个默认参数，而且设置的默认参数都要在非默认参数后面。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">playMusic</span>(<span class="params">name</span>: <span class="type">String</span>, <span class="params">instrument</span>:<span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;drum&quot;</span>, <span class="params">sound</span>:<span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;咚咚咚。。。&quot;</span>) -&gt; <span class="type">String</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> scene <span class="operator">=</span> name <span class="operator">+</span> <span class="string">&quot; play the &quot;</span> <span class="operator">+</span> instrument <span class="operator">+</span> <span class="string">&quot;,&quot;</span> <span class="operator">+</span> sound;</span><br><span class="line">    <span class="built_in">print</span>(scene)</span><br><span class="line">    <span class="keyword">return</span> scene;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用了默认参数的参数, 相关的默认参数可以不用传值</span></span><br><span class="line">playMusic(name: <span class="string">&quot;zhoushuai”)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//对于默认参数，可以有选择的传入值</span></span><br><span class="line"><span class="string">playMusic(name: &quot;</span>zhoushuai<span class="string">&quot;, instrument: &quot;</span>panio<span class="string">&quot;)</span></span><br><span class="line"><span class="string">playMusic(name: &quot;</span>zhoushuai<span class="string">&quot;, instrument: &quot;</span>panio<span class="string">&quot; ,sound: &quot;</span>lingling<span class="operator">~</span><span class="string">&quot;)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//测试打印：</span></span><br><span class="line"><span class="string">//zhoushuai play the drum,咚咚咚。。。</span></span><br><span class="line"><span class="string">//zhoushuai play the panio,咚咚咚。。。</span></span><br><span class="line"><span class="string">//zhoushuai play the panio,lingling~</span></span><br></pre></td></tr></table></figure>

<h1 id="五、可变参数"><a href="#五、可变参数" class="headerlink" title="五、可变参数"></a>五、可变参数</h1><p>一个可变参数可以接受零个或多个值。函数调用时，你可以用可变参数来指定函数参数传入不确定数量的输入值。通过在变量类型名后面加入（…）的方式来定义可变参数。下面的算术平均函数演示了可变参数的用法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">arithmeticMean</span>(<span class="keyword">_</span> <span class="params">numbers</span>: <span class="type">Double</span>...) -&gt; <span class="type">Double</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> total: <span class="type">Double</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> number <span class="keyword">in</span> numbers &#123;</span><br><span class="line">        total <span class="operator">+=</span> number</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total <span class="operator">/</span> <span class="type">Double</span>(numbers.count)</span><br><span class="line">&#125;</span><br><span class="line">arithmeticMean(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)   <span class="comment">//返回3.0, 是这5个数的平均数。</span></span><br><span class="line"></span><br><span class="line">arithmeticMean(<span class="number">3</span>, <span class="number">8.25</span>, <span class="number">18.75</span>)  <span class="comment">//返回10.0, 是这3个数的平均数。</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：一个函数只能拥有一个可变参数</strong></p>
<h1 id="六、输入输出参数"><a href="#六、输入输出参数" class="headerlink" title="六、输入输出参数"></a>六、输入输出参数</h1><p>函数参数默认是常量形参，所以我们在函数中对其修改都不会对参数的原值产生影响。为了解决这个问题，我们可以将这些需要修改的参数定义为输入输出参数。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> somInt <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="comment">//普通函数:报错，因为num是常量，不能被再次修改</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">func modifyNum(num:Int)&#123;</span></span><br><span class="line"><span class="comment">    num = num * 2;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//带有输入输出函数的函数</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">modifyNum2</span>(<span class="params">num</span>:<span class="keyword">inout</span> <span class="type">Int</span>)&#123;</span><br><span class="line">    num <span class="operator">=</span> num <span class="operator">*</span> <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">modifyNum2(num: <span class="operator">&amp;</span>somInt)</span><br><span class="line"><span class="built_in">print</span>(somInt)           <span class="comment">//20，someIn被修改</span></span><br></pre></td></tr></table></figure>

<p>注意： 1.只能传递变量给输入输出参数，而不能是常量或者字面量，因为这些量是不能被修改的； 2.传入参数作为输入输出参数时，需要在参数名前添加&amp;符号，表示这个值可以被修改；</p>
<h1 id="七、函数类型"><a href="#七、函数类型" class="headerlink" title="七、函数类型"></a>七、函数类型</h1><p>如同参数有整型，布尔型等参数类型一样，每个函数都有种特定的函数类型。函数的类型由函数的参数类型和返回值类型组成。下面举例说明：</p>
<h4 id="1-以下两个函数具有相同的函数类型：（Int-Int）-gt-Int"><a href="#1-以下两个函数具有相同的函数类型：（Int-Int）-gt-Int" class="headerlink" title="1.以下两个函数具有相同的函数类型：（Int,Int）-&gt;Int"></a>1.以下两个函数具有相同的函数类型：（Int,Int）-&gt;Int</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">addTwoInts</span>(<span class="keyword">_</span> <span class="params">a</span>: <span class="type">Int</span>, <span class="keyword">_</span> <span class="params">b</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a <span class="operator">+</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">multiplyTwoInts</span>(<span class="keyword">_</span> <span class="params">a</span>: <span class="type">Int</span>, <span class="keyword">_</span> <span class="params">b</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a <span class="operator">*</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-没有参数也没有返回值的函数类型：-gt-Void"><a href="#2-没有参数也没有返回值的函数类型：-gt-Void" class="headerlink" title="2.没有参数也没有返回值的函数类型：()-&gt;Void"></a>2.没有参数也没有返回值的函数类型：()-&gt;Void</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">printHelloWorld</span>() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello, world&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-使用函数类型"><a href="#3-使用函数类型" class="headerlink" title="3.使用函数类型"></a>3.使用函数类型</h4><h5 id="3-1定义一个函数类型的变量或常量，然后可以使用适当函数为其赋值"><a href="#3-1定义一个函数类型的变量或常量，然后可以使用适当函数为其赋值" class="headerlink" title="3.1定义一个函数类型的变量或常量，然后可以使用适当函数为其赋值"></a>3.1定义一个函数类型的变量或常量，然后可以使用适当函数为其赋值</h5><p>下面的mathFunction变量，经过赋值之后，指向了addTwoInts函数，所以它也可以当做addTwoInts函数使用</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mathFunction:(<span class="type">Int</span>,<span class="type">Int</span>)-&gt;<span class="type">Int</span> <span class="operator">=</span> addTwoInts</span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值了加法函数：addTwoInts</span></span><br><span class="line"><span class="built_in">print</span>(mathFunction(<span class="number">3</span>,<span class="number">4</span>))         <span class="comment">//7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值了乘法函数：multiplyTwoInts</span></span><br><span class="line">mathFunction <span class="operator">=</span> multiplyTwoInts;</span><br><span class="line"><span class="built_in">print</span>(mathFunction(<span class="number">3</span>,<span class="number">4</span>))         <span class="comment">//12</span></span><br></pre></td></tr></table></figure>

<h5 id="3-2函数类型做为参数类型"><a href="#3-2函数类型做为参数类型" class="headerlink" title="3.2函数类型做为参数类型"></a>3.2函数类型做为参数类型</h5><p>函数类型也可以作为另一个函数的参数类型，这样我们就可以将函数的一部分实现留给函数的调用者来提供。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试1：</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">printMathResult</span>(<span class="keyword">_</span> <span class="params">mathFunction</span>: (<span class="type">Int</span>, <span class="type">Int</span>) -&gt; <span class="type">Int</span>, <span class="keyword">_</span> <span class="params">a</span>: <span class="type">Int</span>, <span class="keyword">_</span> <span class="params">b</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Result: <span class="subst">\(mathFunction(a, b))</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">printMathResult(addTwoInts, <span class="number">3</span>, <span class="number">5</span>)          <span class="comment">//打印 &quot;Result: 8”</span></span><br><span class="line">printMathResult(multiplyTwoInts, <span class="number">3</span>, <span class="number">5</span>)   <span class="comment">//打印：&quot;Result: 15&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//测试2：</span></span><br><span class="line"><span class="comment">//生成随机数组成的数组</span></span><br><span class="line"><span class="keyword">var</span> array: [<span class="type">Int</span>] <span class="operator">=</span> []</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">_</span> <span class="keyword">in</span> <span class="number">0</span><span class="operator">..&lt;</span><span class="number">6</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> max<span class="operator">=</span><span class="number">20</span></span><br><span class="line">    <span class="keyword">let</span> randNum0<span class="operator">=</span>arc4random()<span class="operator">%</span><span class="type">UInt32</span>(max)</span><br><span class="line">    <span class="keyword">let</span> randNum1<span class="operator">=</span><span class="type">Int</span>(randNum0)</span><br><span class="line">    <span class="keyword">if</span>(array.contains(randNum1))&#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    array.append(randNum1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(array)       <span class="comment">//[12, 9, 19, 13, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义排序方法1：从大到小排序</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">biggerNumFirst</span>(<span class="params">num1</span>:<span class="type">Int</span>, <span class="params">num2</span>:<span class="type">Int</span>) -&gt; <span class="type">Bool</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 <span class="operator">&gt;</span> num2</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//自定义排序方法2：将数字转化为字符串， 按照字符换的字典排序</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">compareByNumberString</span>(<span class="params">num1</span>: <span class="type">Int</span>, <span class="params">num2</span>: <span class="type">Int</span>) -&gt;<span class="type">Bool</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">String</span>(num1) <span class="operator">&gt;</span> <span class="type">String</span>(num2)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//自定义排序方法3：距离某个数字最近</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">nearTo10</span>(<span class="params">num1</span>: <span class="type">Int</span>, <span class="params">num2</span>: <span class="type">Int</span>) -&gt;<span class="type">Bool</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">abs</span>(num1 <span class="operator">-</span> <span class="number">10</span>) <span class="operator">&lt;</span> <span class="built_in">abs</span>(num2 <span class="operator">-</span> <span class="number">10</span>) <span class="operator">?</span> <span class="literal">true</span> :<span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">array.sort(by: biggerNumFirst(num1:num2:))</span><br><span class="line">array.sort(by: compareByNumberString)</span><br><span class="line">array.sort(by: nearTo10)</span><br><span class="line"><span class="comment">//测试打印:</span></span><br><span class="line"><span class="comment">//[19, 13, 12, 9, 3]</span></span><br><span class="line"><span class="comment">//[9, 3, 19, 13, 12]</span></span><br><span class="line"><span class="comment">//[9, 12, 13, 3, 19]</span></span><br></pre></td></tr></table></figure>

<h5 id="3-3-函数类型作为返回值类型"><a href="#3-3-函数类型作为返回值类型" class="headerlink" title="3.3.函数类型作为返回值类型"></a>3.3.函数类型作为返回值类型</h5><p>你可以用函数类型作为另一个函数的返回类型。你需要做的是在返回箭头（-&gt;）后写一个完整的函数类型。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">getMathFunction</span>(<span class="params">symbol</span>: <span class="type">String</span>)-&gt;(<span class="type">Int</span>,<span class="type">Int</span>)-&gt;<span class="type">Int</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> symbol <span class="operator">==</span> <span class="string">&quot;*&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> multiplyTwoInts;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> addTwoInts</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//传入不同的字符串参数，会返回不同的函数</span></span><br><span class="line"><span class="keyword">var</span> function <span class="operator">=</span> getMathFunction(symbol: <span class="string">&quot;*&quot;</span>)</span><br><span class="line">function(<span class="number">1</span>,<span class="number">2</span>)    <span class="comment">//2</span></span><br><span class="line">function <span class="operator">=</span> getMathFunction(symbol: <span class="string">&quot;abcdefg&quot;</span>)</span><br><span class="line">function(<span class="number">1</span>,<span class="number">2</span>)    <span class="comment">//3</span></span><br></pre></td></tr></table></figure>

<h1 id="八、嵌套函数"><a href="#八、嵌套函数" class="headerlink" title="八、嵌套函数"></a>八、嵌套函数</h1><p>通常，我们见到的都是全局函数，即定义在全局域中的函数。我们也可以把函数定义在别的函数体中，称作嵌套函数。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">getMathFunction2</span>(<span class="params">symbol</span>: <span class="type">String</span>)-&gt;(<span class="type">Int</span>,<span class="type">Int</span>)-&gt;<span class="type">Int</span>&#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">mathFunc1</span>(<span class="params">a</span>:<span class="type">Int</span>,<span class="params">b</span>:<span class="type">Int</span>)-&gt;<span class="type">Int</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a <span class="operator">-</span> b</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">mathFunc2</span>(<span class="params">a</span>: <span class="type">Int</span>, <span class="params">b</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a <span class="operator">*</span> b</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> symbol <span class="operator">==</span> <span class="string">&quot;*&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mathFunc2;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mathFunc1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> method <span class="operator">=</span> getMathFunction2(symbol: <span class="string">&quot;*&quot;</span>)</span><br><span class="line">method(<span class="number">5</span>,<span class="number">6</span>)     <span class="comment">//30</span></span><br><span class="line">method <span class="operator">=</span> getMathFunction2(symbol: <span class="string">&quot;123123&quot;</span>)</span><br><span class="line">method(<span class="number">5</span>,<span class="number">6</span>)     <span class="comment">//-1</span></span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wuyubeichen.github.io/2017/08/01/Swift%E5%AD%A6%E4%B9%A001-%E5%B1%9E%E6%80%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Author">
      <meta itemprop="description" content="iOS Developer, Beijing China">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="梧雨北辰的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/08/01/Swift%E5%AD%A6%E4%B9%A001-%E5%B1%9E%E6%80%A7/" class="post-title-link" itemprop="url">Swift学习01-属性</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-08-01 18:14:43" itemprop="dateCreated datePublished" datetime="2017-08-01T18:14:43+08:00">2017-08-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-29 09:39:32" itemprop="dateModified" datetime="2022-08-29T09:39:32+08:00">2022-08-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Swift/" itemprop="url" rel="index"><span itemprop="name">Swift</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>属性</strong>：是与特定的Swift类、结构体、枚举相关联的值；与其他语言相比，属性不再是被类所特有；</p>
<p><strong>主要内容</strong>：</p>
<ol>
<li>存储属性与计算属性</li>
<li>属性观察器</li>
<li>类型属性</li>
<li>全局变量与局部变量</li>
</ol>
<h4 id="一、存储属性与计算属性"><a href="#一、存储属性与计算属性" class="headerlink" title="一、存储属性与计算属性"></a>一、存储属性与计算属性</h4><p>从属性被定义的方式上看，<code>Swift</code>属性有存储属性和计算属性两种：</p>
<ul>
<li>存储属性：存储在特定类或结构体实例里的一个常量(<code>let</code>)或变量(<code>var</code>)，作为实例的一部分；</li>
<li>计算属性：计算属性不直接存储值，而是提供一个<code>getter</code>和一个可选的<code>setter</code>，来间接设置其他属性或变量值；</li>
</ul>
<p>下面通过一段代码演示这两种属性的区别：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Square</span>&#123;</span><br><span class="line">    <span class="comment">//存储属性</span></span><br><span class="line">    <span class="keyword">var</span> width:<span class="type">Double</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算属性：通过一定计算方法得到的属性</span></span><br><span class="line">    <span class="keyword">var</span> area:<span class="type">Double</span>&#123;</span><br><span class="line">        <span class="keyword">get</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> width <span class="operator">*</span> width</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> square <span class="operator">=</span> <span class="type">Square</span>(width: <span class="number">10.0</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;正方形边长：<span class="subst">\(square.width)</span>&quot;</span>)     <span class="comment">//正方形边长：10.0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;正方形面积：<span class="subst">\(square.area)</span>&quot;</span>)      <span class="comment">//正方形面积：100.0</span></span><br></pre></td></tr></table></figure>

<p>总结存储属性和计算属性的用法还有如下几种情况：</p>
<h5 id="1-1-常量结构体的存储属性"><a href="#1-1-常量结构体的存储属性" class="headerlink" title="1.1.常量结构体的存储属性"></a>1.1.常量结构体的存储属性</h5><p>如果创建一个结构体的实例并且将其赋值给一个常量，则无法再修改该实例的任何属性(包括其中的变量属性)。这是因为结构体是值类型，值类型实例被声明为常量，其所有属性都成了常量；在这点上，类与结构体不同，这种情况下，类中的可变属性可以被修改。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> square1 <span class="operator">=</span> <span class="type">Square</span>(width: <span class="number">10.0</span>)</span><br><span class="line"><span class="comment">//square1.width = 11.0      //报错</span></span><br><span class="line"><span class="keyword">var</span> square2 <span class="operator">=</span> <span class="type">Square</span>(width:<span class="number">20.0</span>)</span><br><span class="line">square2.width <span class="operator">=</span> <span class="number">21.0</span>      <span class="comment">//可以修改</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//注：如果Squre是一个类，那么以上两种情况都可以通过</span></span><br></pre></td></tr></table></figure>

<h5 id="1-2-延迟存储属性"><a href="#1-2-延迟存储属性" class="headerlink" title="1.2.延迟存储属性"></a>1.2.延迟存储属性</h5><ul>
<li>定义：第一次被调用的时候才会计算其初始值的属性。在属性声明前使用<code>lazy</code>来表示一个延迟存储属性；</li>
<li>作用：当属性的值依赖于在实例的构造过程结束后才会知道影响值的外部因素时，或者当获得属性的初始值需要复杂或大量计算时，可以只在需要的时候计算它；</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Number</span>&#123;</span><br><span class="line">    <span class="comment">//存储属性</span></span><br><span class="line">    <span class="keyword">var</span> startNum: <span class="type">Int</span>!</span><br><span class="line">    <span class="keyword">var</span> endNum:<span class="type">Int</span>!</span><br><span class="line">    <span class="comment">//计算属性</span></span><br><span class="line">    <span class="keyword">var</span> length :<span class="type">Int</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> endNum <span class="operator">-</span> startNum <span class="operator">+</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//延迟属性：使用闭包计算出了延迟属性的值，此过程只执行一次</span></span><br><span class="line">    <span class="keyword">lazy</span> <span class="keyword">var</span> sum: <span class="type">Int</span> <span class="operator">=</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;计算延迟属性。。。。&quot;</span>)</span><br><span class="line">        <span class="keyword">var</span> tempNum <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="keyword">self</span>.startNum<span class="operator">...</span><span class="keyword">self</span>.endNum&#123;</span><br><span class="line">            tempNum <span class="operator">+=</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tempNum</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//可失败的构造方法</span></span><br><span class="line">    <span class="keyword">init?</span>(<span class="params">startNum</span>: <span class="type">Int</span> , <span class="params">endNum</span>:<span class="type">Int</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(startNum <span class="operator">&gt;</span> endNum)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">self</span>.startNum <span class="operator">=</span> startNum</span><br><span class="line">        <span class="keyword">self</span>.endNum <span class="operator">=</span> endNum</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> number <span class="operator">=</span> <span class="type">Number</span>(startNum: <span class="number">1</span>, endNum: <span class="number">100</span>)</span><br><span class="line">number<span class="operator">?</span>.length  <span class="comment">//100</span></span><br><span class="line">number<span class="operator">?</span>.sum    <span class="comment">//5050</span></span><br><span class="line">number<span class="operator">?</span>.sum    <span class="comment">//5050</span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：</p>
<ol>
<li>必须将延迟存储属性声明成变量(使用<code>var</code>关键字)，因为属性的初始值可能在实例构造完成之后才会得到。而常量属性在构造过程完成之前必须要有初始值，因此无法声明成延迟属性；</li>
<li>如果一个被标记为 <code>lazy</code> 的属性在没有初始化时就同时被多个线程访问，则无法保证该属性只会被初始化一次；</li>
</ol>
<h5 id="1-3-计算属性的使用"><a href="#1-3-计算属性的使用" class="headerlink" title="1.3.计算属性的使用"></a>1.3.计算属性的使用</h5><p>计算属性不直接存储值，而是提供一个<code>getter</code>和一个可选的<code>setter</code>，来间接设置其他属性或变量值；总结它的使用特点如下：</p>
<ol>
<li>只有<code>getter</code>没有<code>setter</code>的计算属性就是只读计算属性。只读属性通过点运算符访问，只能返回值而不可设置新值；</li>
<li>计算属性与其他属性相关，是变化的，所以必须使用<code>var</code>关键字进行修饰，包括只读计算属性；</li>
<li>只读计算属性可以去掉<code>get</code>关键字和花括号；</li>
</ol>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">var</span> y <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Size</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> width <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">var</span> height <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span>&#123;</span><br><span class="line">    <span class="comment">//存储型数据</span></span><br><span class="line">    <span class="keyword">var</span> originPoint  <span class="operator">=</span> <span class="type">Point</span>()</span><br><span class="line">    <span class="keyword">var</span> size <span class="operator">=</span> <span class="type">Size</span>()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算型属性</span></span><br><span class="line">    <span class="keyword">var</span> center:<span class="type">Point</span>&#123;</span><br><span class="line">        <span class="comment">//get方法：获取计算属性值</span></span><br><span class="line">        <span class="keyword">get</span>&#123;</span><br><span class="line">            <span class="keyword">let</span> center_x <span class="operator">=</span> originPoint.x <span class="operator">+</span> size.width<span class="operator">/</span><span class="number">2</span></span><br><span class="line">            <span class="keyword">let</span> center_y <span class="operator">=</span> originPoint.y <span class="operator">+</span> size.height<span class="operator">/</span><span class="number">2</span></span><br><span class="line">            <span class="keyword">return</span> <span class="type">Point</span>(x: center_x, y: center_y)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果没有set方法，是只读，</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         set(newCenter)&#123;</span></span><br><span class="line"><span class="comment">            originPoint.x = newCenter.x - size.width/2</span></span><br><span class="line"><span class="comment">            originPoint.y = newCenter.y - size.height/2</span></span><br><span class="line"><span class="comment">         &#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//set方法：设置计算属性新值</span></span><br><span class="line">        <span class="comment">//这里也可以省略括号和newCenter.使用newValue</span></span><br><span class="line">        <span class="keyword">set</span>&#123;</span><br><span class="line">            originPoint.x <span class="operator">=</span> newValue.x <span class="operator">-</span> size.width<span class="operator">/</span><span class="number">2</span></span><br><span class="line">            originPoint.y <span class="operator">=</span> newValue.y <span class="operator">-</span> size.height<span class="operator">/</span><span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算属性：area属性只有get,可以不显式的声明出get；此属性为只读属性</span></span><br><span class="line">    <span class="keyword">var</span> area:<span class="type">Double</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size.width <span class="operator">*</span> size.height</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">origin</span>: <span class="type">Point</span>, <span class="params">size</span>: <span class="type">Size</span>)&#123;</span><br><span class="line">        <span class="keyword">self</span>.originPoint  <span class="operator">=</span> origin</span><br><span class="line">        <span class="keyword">self</span>.size  <span class="operator">=</span> size</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建一个长方形</span></span><br><span class="line"><span class="keyword">var</span> rect <span class="operator">=</span> <span class="type">Rectangle</span>(origin: <span class="type">Point</span>(x: <span class="number">0</span>, y: <span class="number">0</span>), size: <span class="type">Size</span>(width: <span class="number">100</span>, height: <span class="number">100</span>))</span><br><span class="line">rect.center</span><br><span class="line">rect.area  <span class="comment">//10000</span></span><br></pre></td></tr></table></figure>

<h4 id="二、属性观察器"><a href="#二、属性观察器" class="headerlink" title="二、属性观察器"></a>二、属性观察器</h4><p>属性观察器监控和响应属性值的变化，每次属性被设置值的时候都会调用属性观察器，即使新值和当前值相同的时候也不例外；</p>
<p>属性观察器可以为延迟属性外的其他存储属性添加属性观察，也可以通过继承的方式重写父类属性，为其添加属性观察期。但是我们没有必要为非重写的计算属性添加属性观察器，因为它本身就可以通过自己的<code>setter</code>直接监控和响应值的变化；</p>
<p>添加属性观察器方式如下：</p>
<ul>
<li><code>willSet</code>方法：在新的值被设置之前调用，拥有一个默认参数<code>newValue</code>(代表新的属性值)；</li>
<li><code>didSet</code>方法：在新的值被设置之后立刻调用,拥有一个默认参数<code>oldValue</code>(代表就的属性值)；</li>
</ul>
<p>下面通过<code>lightBlub</code>演示用法，其中为<code>currentDianYa</code>属性添加了观察器：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">lightBlub</span> &#123;</span><br><span class="line">    <span class="comment">//最大电压和当前电压</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> maxDianYa <span class="operator">=</span> <span class="number">30</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//属性监听</span></span><br><span class="line">    <span class="comment">//注意：willSet和didSet括号中的值可以省略，直接使用系统自带的newVlaue和oldValue</span></span><br><span class="line">    <span class="keyword">var</span> currentDianYa <span class="operator">=</span> <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">//可以使用系统默认的属性newValue和oldValue</span></span><br><span class="line">        <span class="keyword">willSet</span>(newCurrentDianya)&#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;当前电压值将要改变:  <span class="subst">\(currentDianYa)</span> -&gt; <span class="subst">\(newCurrentDianya)</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当调用此方法时，已经设置了值的时候,</span></span><br><span class="line">        <span class="keyword">didSet</span>(oldCurentDianYa)&#123;</span><br><span class="line">            <span class="keyword">if</span>(currentDianYa <span class="operator">==</span> lightBlub.maxDianYa)&#123;</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;请注意 ,当前电压达到了最大电压值&quot;</span>)</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">self</span>.currentDianYa <span class="operator">&gt;</span> lightBlub.maxDianYa)&#123;</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;当前电压过高，不能设置新的电压值&quot;</span>)</span><br><span class="line">                currentDianYa <span class="operator">=</span> oldCurentDianYa</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> light <span class="operator">=</span> lightBlub()</span><br><span class="line">light.currentDianYa <span class="operator">=</span> <span class="number">10</span></span><br><span class="line">light.currentDianYa <span class="operator">=</span> <span class="number">30</span></span><br><span class="line">light.currentDianYa <span class="operator">=</span> <span class="number">40</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 打印结果：</span></span><br><span class="line"><span class="comment"> 当前电压值将要改变:  0 -&gt; 10</span></span><br><span class="line"><span class="comment"> 当前电压值将要改变:  10 -&gt; 30</span></span><br><span class="line"><span class="comment"> 请注意 ,当前电压达到了最大电压值</span></span><br><span class="line"><span class="comment"> 当前电压值将要改变:  30 -&gt; 40</span></span><br><span class="line"><span class="comment"> 当前电压过高，不能设置新的电压值</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：willSet和didSet并不会在初始化时被调用</strong></p>
<h4 id="三、类型属性"><a href="#三、类型属性" class="headerlink" title="三、类型属性"></a>三、类型属性</h4><p><strong>实例属性</strong>属于一个特定类型的实例，因此实例之间的属性相互独立。但其实，也可以为类型本身定义属性，这样无论创建了多少个该类型实例，这些属性只有唯一的一份，这种属性就是<strong>类型属性</strong>。</p>
<p><code>Swift</code>的类型属性就相当于<code>OC</code>或者<code>C</code>中的类变量，但他们有着以下的不同： 在<code>OC</code>或者<code>C</code>中，与某个类型相关的静态常量和静态变量，是作为全局静态变量来定义的。但是Swift中，类型属性是作为类型定义的一部分写在类型最外层的花括号内，因此它的作用范围也就在类型支持的范围内；</p>
<p><code>Swift</code>类型属性使用关键字<code>static</code>,下面是一个具体示例：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试Int的类型属性</span></span><br><span class="line"><span class="type">Int</span>.min </span><br><span class="line"><span class="type">Int</span>.max</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="comment">//对象属性：本人的得分</span></span><br><span class="line">    <span class="keyword">var</span> score: <span class="type">Int</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="comment">//类型属性：本游戏的最高得分,使用类名来访问，使用关键字static声明</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> heighestScore:<span class="type">Int</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造方法</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>)&#123;</span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//玩一句游戏得分</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">playGame</span>()&#123;</span><br><span class="line">        <span class="keyword">let</span> tempNum <span class="operator">=</span> <span class="type">Int</span>(arc4random()<span class="operator">%</span><span class="number">100</span>)<span class="operator">+</span><span class="number">1</span></span><br><span class="line">        <span class="keyword">self</span>.score <span class="operator">+=</span> tempNum</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(name)</span> 的游戏得分是：<span class="subst">\(score)</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">self</span>.score <span class="operator">&gt;</span> <span class="type">Player</span>.heighestScore)&#123;</span><br><span class="line">            <span class="type">Player</span>.heighestScore <span class="operator">=</span> <span class="keyword">self</span>.score</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;当前本游戏的最高分是:<span class="subst">\(Player.heighestScore)</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> player1 <span class="operator">=</span> <span class="type">Player</span>(name: <span class="string">&quot;zs&quot;</span>)</span><br><span class="line">player1.playGame()</span><br><span class="line">player1.playGame()</span><br><span class="line"><span class="keyword">let</span> player2 <span class="operator">=</span> <span class="type">Player</span>(name: <span class="string">&quot;cf&quot;</span>)</span><br><span class="line">player2.playGame()</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 打印结果</span></span><br><span class="line"><span class="comment"> zs 的游戏得分是：11</span></span><br><span class="line"><span class="comment"> 当前本游戏的最高分是:11</span></span><br><span class="line"><span class="comment"> zs 的游戏得分是：87</span></span><br><span class="line"><span class="comment"> 当前本游戏的最高分是:87</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> cf 的游戏得分是：88</span></span><br><span class="line"><span class="comment"> 当前本游戏的最高分是:88</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="四、全局变量与局部变量"><a href="#四、全局变量与局部变量" class="headerlink" title="四、全局变量与局部变量"></a>四、全局变量与局部变量</h4><ul>
<li><p>全局变量：在函数、方法、闭包或者任意类型之外定义的变量；</p>
</li>
<li><p>局部变量：在函数、方法或者闭包内部定义的变量；</p>
<p>全局的常量或变量都是延迟计算的，跟延迟存储属性相似，不同的地方在于：全局的常量或变量不需要标记lazy修饰符。</p>
</li>
</ul>
<p>局部范围的常量或变量从不延迟计算。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Author</p>
  <div class="site-description" itemprop="description">iOS Developer, Beijing China</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">38</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Author</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  


</body>
</html>
