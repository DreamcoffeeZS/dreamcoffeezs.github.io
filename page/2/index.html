<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/header.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/header.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/header.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"wuyubeichen.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="iOS Developer, Beijing China">
<meta property="og:type" content="website">
<meta property="og:title" content="梧雨北辰的博客">
<meta property="og:url" content="https://wuyubeichen.github.io/page/2/index.html">
<meta property="og:site_name" content="梧雨北辰的博客">
<meta property="og:description" content="iOS Developer, Beijing China">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Zhou Shuai">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://wuyubeichen.github.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>梧雨北辰的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="梧雨北辰的博客" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">梧雨北辰的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">天行健，君子以自强不息！</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wuyubeichen.github.io/2019/04/13/iOS%E5%BA%95%E5%B1%82-Block%E6%8D%95%E8%8E%B7%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Author">
      <meta itemprop="description" content="iOS Developer, Beijing China">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="梧雨北辰的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/13/iOS%E5%BA%95%E5%B1%82-Block%E6%8D%95%E8%8E%B7%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">iOS底层-Block捕获变量原理分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-13 16:16:49" itemprop="dateCreated datePublished" datetime="2019-04-13T16:16:49+08:00">2019-04-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-29 09:39:32" itemprop="dateModified" datetime="2022-08-29T09:39:32+08:00">2022-08-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS%E5%BA%95%E5%B1%82/" itemprop="url" rel="index"><span itemprop="name">iOS底层</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>主要内容：</strong></p>
<ol>
<li>分析<code>Block</code>捕获外部变量的过程</li>
<li>理解<code>Block</code>修改外部变量的限制</li>
<li>分析<code>__block</code>存储域类说明符的原理</li>
<li>理解<code>__block</code>变量的存储域</li>
<li>探究<code>Block</code>对对象的捕获过程</li>
<li><code>Block</code>的循环引用问题</li>
</ol>
<h4 id="一、分析Block捕获外部变量的过程"><a href="#一、分析Block捕获外部变量的过程" class="headerlink" title="一、分析Block捕获外部变量的过程"></a>一、分析Block捕获外部变量的过程</h4><p>为了保证<code>Block</code>内部能够正常访问外部的变量，<code>Block</code>有一个变量捕获机制，即<code>Block</code>语法表达式所使用变量可以被保存到<code>Block</code>的结构体实例(<code>Block</code>自身)中。</p>
<p>关于捕获，<code>Block</code>对不同的外部变量的处理有所不同，根据<code>OC</code>中使用变量的分类，大概包括以下几种情况：</p>
<ol>
<li>函数参数(这里研究<code>Block</code>捕获，所以此处不涉及)</li>
<li>局部变量(简称：自动变量)</li>
<li>静态局部变量(常简称，静态变量)</li>
<li>全局变量</li>
<li>静态全局变量</li>
</ol>
<p>那么，现在对<code>Block</code>捕获外部变量的四种情况进行测试，相关代码如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#<span class="keyword">import</span> &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用如下的命令，可将OC代码编译为C++代码</span></span><br><span class="line"><span class="comment">//clang -rewrite-objc main.m</span></span><br><span class="line"></span><br><span class="line">int global_val <span class="operator">=</span> <span class="number">1</span>;                  <span class="comment">//全局变量</span></span><br><span class="line"><span class="keyword">static</span> int static_global_val <span class="operator">=</span> <span class="number">1</span>;    <span class="comment">//静态全局变量</span></span><br><span class="line"></span><br><span class="line">int main(int argc, char <span class="operator">*</span> argv[]) &#123;</span><br><span class="line">    int val <span class="operator">=</span> <span class="number">1</span>;                     <span class="comment">//自动变量</span></span><br><span class="line">    <span class="keyword">static</span> int static_val <span class="operator">=</span> <span class="number">1</span>;       <span class="comment">//局部静态变量</span></span><br><span class="line">    </span><br><span class="line">    void (<span class="operator">^</span>myBlock)(void) <span class="operator">=</span> <span class="operator">^</span>&#123;</span><br><span class="line">        global_val <span class="operator">++</span>;</span><br><span class="line">        static_global_val <span class="operator">++</span>;</span><br><span class="line">        static_val <span class="operator">++</span>;</span><br><span class="line">        <span class="comment">//val++//直接修改会报错(Variable is not assignable (missing __block type specifier)</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">NSLog</span>(@<span class="string">&quot;<span class="subst">\n</span>Block内:<span class="subst">\n</span>global_val = %d,<span class="subst">\n</span>static_global_val = %d,<span class="subst">\n</span>val = %d,<span class="subst">\n</span>static_val= %d&quot;</span>,global_val,static_global_val,val,static_val);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    global_val <span class="operator">++</span>;</span><br><span class="line">    static_global_val <span class="operator">++</span>;</span><br><span class="line">    val <span class="operator">++</span>;</span><br><span class="line">    static_val <span class="operator">++</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;<span class="subst">\n</span>Block外:<span class="subst">\n</span>global_val = %d,<span class="subst">\n</span>static_global_val = %d,<span class="subst">\n</span>val = %d,<span class="subst">\n</span>static_val= %d&quot;</span>,global_val,static_global_val,val,static_val);</span><br><span class="line">    myBlock();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行的结果如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Block外</span>:</span><br><span class="line">global_val <span class="operator">=</span> <span class="number">2</span>,</span><br><span class="line">static_global_val <span class="operator">=</span> <span class="number">2</span>,</span><br><span class="line">val <span class="operator">=</span> <span class="number">2</span>,</span><br><span class="line">static_val<span class="operator">=</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="type">Block内</span>:</span><br><span class="line">global_val <span class="operator">=</span> <span class="number">3</span>,</span><br><span class="line">static_global_val <span class="operator">=</span> <span class="number">3</span>,</span><br><span class="line">val <span class="operator">=</span> <span class="number">1</span>,</span><br><span class="line">static_val<span class="operator">=</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>分析运行结果，我们会发现以上四种情况中，只有<code>静态局部变量</code>、<code>静态全局变量</code>、<code>全局变量</code>可以在<code>Block</code>里被修改，而且直接修改<code>自动变量</code>就会报错；</p>
<p>此时，考虑以下两个问题：</p>
<ol>
<li>为什么在<code>Block</code>里不允许更改自动变量？</li>
<li><code>Block</code>捕获不同的变量并修改时，有什么区别吗？</li>
</ol>
<p>为了具体分析，现在将上述代码转化为<code>C++</code>的源码，转换后的代码如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">int global_val <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">static</span> int static_global_val <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__main_block_impl_0</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">__block_impl</span> <span class="title class_">impl</span>;</span><br><span class="line">  <span class="title class_">struct</span> <span class="title class_">__main_block_desc_0</span>* <span class="title class_">Desc</span>;</span><br><span class="line">  <span class="title class_">int</span> *<span class="title class_">static_val</span>;  //对应静态局部变量</span><br><span class="line">  <span class="title class_">int</span> <span class="title class_">val</span>;          //对应自动变量</span><br><span class="line">  <span class="title class_">__main_block_impl_0</span>(<span class="title class_">void</span> *<span class="title class_">fp</span>, <span class="title class_">struct</span> <span class="title class_">__main_block_desc_0</span> *<span class="title class_">desc</span>, <span class="title class_">int</span> *<span class="title class_">_static_val</span>, <span class="title class_">int</span> <span class="title class_">_val</span>, <span class="title class_">int</span> <span class="title class_">flags</span>=0) : <span class="title class_">static_val</span>(<span class="title class_">_static_val</span>), <span class="title class_">val</span>(<span class="title class_">_val</span>) &#123;</span><br><span class="line">    impl.isa <span class="operator">=</span> <span class="operator">&amp;</span>_NSConcreteStackBlock;</span><br><span class="line">    impl.<span class="type">Flags</span> <span class="operator">=</span> flags;</span><br><span class="line">    impl.<span class="type">FuncPtr</span> <span class="operator">=</span> fp;</span><br><span class="line">    <span class="type">Desc</span> <span class="operator">=</span> desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> void __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 <span class="operator">*</span>__cself) &#123;</span><br><span class="line">  int <span class="operator">*</span>static_val <span class="operator">=</span> __cself-&gt;static_val; <span class="comment">// bound by copy</span></span><br><span class="line">  int val <span class="operator">=</span> __cself-&gt;val; <span class="comment">// bound by copy</span></span><br><span class="line"></span><br><span class="line">        global_val <span class="operator">++</span>;</span><br><span class="line">        static_global_val <span class="operator">++</span>;</span><br><span class="line">        (<span class="operator">*</span>static_val) <span class="operator">++</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">NSLog</span>((<span class="type">NSString</span> <span class="operator">*</span>)<span class="operator">&amp;</span>__NSConstantStringImpl__var_folders_3f_crl5bnj956d806cp7d3ctqhm0000gn_T_main_78fd5a_mi_0,global_val,static_global_val,val,(<span class="operator">*</span>static_val));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> <span class="title class_">__main_block_desc_0</span> &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t <span class="type">Block_size</span>;</span><br><span class="line">&#125; __main_block_desc_0_DATA <span class="operator">=</span> &#123; <span class="number">0</span>, sizeof(<span class="keyword">struct</span> __main_block_impl_0)&#125;;</span><br><span class="line"></span><br><span class="line">int main(int argc, char <span class="operator">*</span> argv[]) &#123;</span><br><span class="line">    int val <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> int static_val <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    void (<span class="operator">*</span>myBlock)(void) <span class="operator">=</span> ((void (<span class="operator">*</span>)())<span class="operator">&amp;</span>__main_block_impl_0((void <span class="operator">*</span>)__main_block_func_0, <span class="operator">&amp;</span>__main_block_desc_0_DATA, <span class="operator">&amp;</span>static_val, val));</span><br><span class="line"></span><br><span class="line">    global_val <span class="operator">++</span>;</span><br><span class="line">    static_global_val <span class="operator">++</span>;</span><br><span class="line">    val <span class="operator">++</span>;</span><br><span class="line">    static_val <span class="operator">++</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">NSLog</span>((<span class="type">NSString</span> <span class="operator">*</span>)<span class="operator">&amp;</span>__NSConstantStringImpl__var_folders_3f_crl5bnj956d806cp7d3ctqhm0000gn_T_main_78fd5a_mi_1,global_val,static_global_val,val,static_val);</span><br><span class="line"></span><br><span class="line">    ((void (<span class="operator">*</span>)(__block_impl <span class="operator">*</span>))((__block_impl <span class="operator">*</span>)myBlock)-&gt;<span class="type">FuncPtr</span>)((__block_impl <span class="operator">*</span>)myBlock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在代码分析之前，我们有必要对程序中的内存区域划分有所了解，其大致的分类如下：</p>
<table>
<thead>
<tr>
<th>内存区域</th>
<th>具体说明</th>
</tr>
</thead>
<tbody><tr>
<td>栈区</td>
<td>存放局部变量的值，系统自动分配和释放;<br>特点：容量小，速度快，有序</td>
</tr>
<tr>
<td>堆区</td>
<td>存放通过<code>malloc</code>系列函数或<code>new</code>操作符分配的内存，如对象；<br>一般由程序员分配和释放，如果不释放，则出现内存泄露;<br>特点：容量大，速度慢，无序；</td>
</tr>
<tr>
<td>静态区</td>
<td>存放全局变量和静态变量(包括静态局部变量和静态全局变量)；<br>当程序结束时，系统回收；</td>
</tr>
<tr>
<td>常量区</td>
<td>存放常量的内存区域；<br>程序结束时，系统回收；</td>
</tr>
<tr>
<td>代码区</td>
<td>存放二进制代码的区域</td>
</tr>
</tbody></table>
<p>了解了这些之后，我们再来具体分析代码和执行结果：</p>
<h5 id="1-全局变量和静态全局变量"><a href="#1-全局变量和静态全局变量" class="headerlink" title="1.全局变量和静态全局变量"></a>1.全局变量和静态全局变量</h5><p>这两种变量都存储在<code>静态区</code>，在任何时候都可以访问，所以<code>Block</code>无所谓捕获，而是采用了直接访问的方式成功的修改了它们的值；这一点从<code>Block</code>对应的构造函数中就可以看出来：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__main_block_impl_0(void <span class="operator">*</span>fp, <span class="keyword">struct</span> __main_block_desc_0 <span class="operator">*</span>desc, int <span class="operator">*</span>_static_var, int _var, int flags<span class="operator">=</span><span class="number">0</span>) : static_var(_static_var), <span class="keyword">var</span>(_var);</span><br></pre></td></tr></table></figure>
<p>可以看到，<code>Block</code>的构造函数的参数里只使用到了<code>静态局部变量</code>和<code>自动变量</code>，并没有涉及到<code>全局变量</code>和<code>静态全局变量</code>。</p>
<p>而且我们也在<code>Block</code>的结构体中，也只发现了对应的静态变量和自动变量的属性，这进一步说明<code>Block</code>是直接使用<code>全局变量</code>和<code>静态全局变量</code>，而非捕获的方式；</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int <span class="operator">*</span>static_val;  <span class="comment">//对应静态局部变量</span></span><br><span class="line">int val;          <span class="comment">//对应自动变量</span></span><br></pre></td></tr></table></figure>

<h5 id="2-自动变量与静态局部变量"><a href="#2-自动变量与静态局部变量" class="headerlink" title="2.自动变量与静态局部变量"></a>2.自动变量与静态局部变量</h5><p>虽然<code>自动变量</code>与<code>静态局部变量</code>都被<code>Block</code>捕获，但是只有静态局部变量才可以被修改成功。通过<code>Block</code>中对应的函数<code>__main_block_func_0</code>，可以观察到<code>Block</code>对外部变量的修改过程，相关代码如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> void __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 <span class="operator">*</span>__cself) &#123;</span><br><span class="line">  int <span class="operator">*</span>static_var <span class="operator">=</span> __cself-&gt;static_var; <span class="comment">// bound by copy</span></span><br><span class="line">  int <span class="keyword">var</span> <span class="operator">=</span> __cself-&gt;<span class="keyword">var</span>; <span class="comment">// bound by copy</span></span><br><span class="line">            global_var <span class="operator">++</span>;</span><br><span class="line">            static_global_var <span class="operator">++</span>;</span><br><span class="line">            (<span class="operator">*</span>static_var) <span class="operator">++</span>;</span><br><span class="line">            <span class="type">NSLog</span>((<span class="type">NSString</span> <span class="operator">*</span>)<span class="operator">&amp;</span>__NSConstantStringImpl__var_folders_3f_crl5bnj956d806cp7d3ctqhm0000gn_T_TestBlock_b539f1_mi_0,global_var,static_global_var,<span class="keyword">var</span>,(<span class="operator">*</span>static_var));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，<code>Block</code>为了访问到对应的<code>自动变量</code>和<code>静态局部变量</code>都使用了<code>__cself</code>，这些操作其实都是针对<code>Block</code>自身属性的，但不同的是：</p>
<ul>
<li><code>外部静态局部变量</code>，由于是指针传递，所以修改的是同一个变量，可以修改成功；</li>
<li><code>外部自动变量</code>，由于是值传递，所以即使修改成功，也无法改变外部自动变量的值；</li>
</ul>
<p>因此，也许是出于安全的目的，在编译阶段我们就会收到错误提示：<code>Block</code>不能修改其捕获的外部自动变量，即:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Variable</span> <span class="keyword">is</span> not assignable(missing __block type specifier)</span><br></pre></td></tr></table></figure>

<h5 id="3-静态局部变量也在静态区，为什么不可以像全局变量一样直接修改？"><a href="#3-静态局部变量也在静态区，为什么不可以像全局变量一样直接修改？" class="headerlink" title="3.静态局部变量也在静态区，为什么不可以像全局变量一样直接修改？"></a>3.静态局部变量也在静态区，为什么不可以像全局变量一样直接修改？</h5><p>其实，关键原因还是<code>&quot;局部&quot;</code>两个字，我们看到<code>C++</code>代码中的函数<code>__main_block_func_0</code>被设置在了包含<code>Block</code>语法的<code>main</code>函数之外，而静态局部变量就是在<code>main</code>函数中定义的；</p>
<p>所以，<code>__main_block_func_0</code>和<code>静态局部变量</code>的作用域是不同的，当然不能像全局变量一样随时访问它。因此，还是采用了捕获和指针传递的方式来修改<code>静态局部变量</code>。</p>
<h5 id="4-为什么自动变量不能像静态变量一样指针传递呢？"><a href="#4-为什么自动变量不能像静态变量一样指针传递呢？" class="headerlink" title="4.为什么自动变量不能像静态变量一样指针传递呢？"></a>4.为什么自动变量不能像静态变量一样指针传递呢？</h5><p>这主要还是因为<code>自动变量</code>和<code>静态变量</code>的存储域的不同。</p>
<p>自动变量存在栈上，其被销毁的时间不定，这很有可能导致<code>Block</code>执行的时候自动变量已经被销毁，那么此时访问被销毁的地址就会产生野指针错误。</p>
<h4 id="二、理解Block修改外部变量的限制"><a href="#二、理解Block修改外部变量的限制" class="headerlink" title="二、理解Block修改外部变量的限制"></a>二、理解Block修改外部变量的限制</h4><p>通过以上的代码示例，我们可以将<code>Block</code>修改外部变量成功的情况分为两种：</p>
<ul>
<li>第一种：<code>Block</code>直接访问全局性的变量，如全局变量、静态全局变量；</li>
<li>第二种：<code>Block</code>间接访问静态局部变量，捕获外部变量并使用指针传递的方式；</li>
</ul>
<p>此时，我们把<code>Block</code>中不允许修改外部变量的值的问题，变成了<code>不允许修改自动变量</code>的问题，但这也并非最终答案，其实最根本的原因还是<strong>Block不允许修改栈中指针的内容</strong>；</p>
<p>下面的一段代码，可以从侧面来验证我们的想法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#<span class="keyword">import</span> &lt;Foundation/Foundation.h&gt;</span><br><span class="line">int main(int argc, const char <span class="operator">*</span> argv[]) &#123;</span><br><span class="line">  <span class="type">NSMutableString</span> <span class="operator">*</span>mStr <span class="operator">=</span> @<span class="string">&quot;mStr&quot;</span>.mutableCopy;</span><br><span class="line">    void (<span class="operator">^</span>myBlock)(void) <span class="operator">=</span> <span class="operator">^</span>&#123;</span><br><span class="line">        <span class="comment">//mStr = @&quot;newMstr&quot;.mutableCopy; //代码1：直接修改了mStr指针内容；</span></span><br><span class="line">        [mStr appendString:@<span class="string">&quot;-ExtraStr&quot;</span>]; <span class="comment">//代码2：修改mStr指向的堆中内容；</span></span><br><span class="line">        <span class="type">NSLog</span>(@<span class="string">&quot;Block内：mStr:%@&quot;</span>,mStr);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;Block外：%@&quot;</span>,mStr);</span><br><span class="line">    myBlock();   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印结果：</span></span><br><span class="line"><span class="comment">//Block外：mStr</span></span><br><span class="line"><span class="comment">//Block内：mStr:mStr-ExtraStr</span></span><br></pre></td></tr></table></figure>
<p>上述代码是操作一个自动变量的可变字符串，经过测试<code>mStr</code>不可以直接赋值，却可以通过<code>appendString</code>修改字符串，这其中的原因是什么呢？</p>
<p>首先还是将代码转化为<code>C++</code>源码，具体如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">__main_block_impl_0</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">__block_impl</span> <span class="title class_">impl</span>;</span><br><span class="line">  <span class="title class_">struct</span> <span class="title class_">__main_block_desc_0</span>* <span class="title class_">Desc</span>;</span><br><span class="line">  <span class="title class_">NSMutableString</span> *<span class="title class_">mStr</span>;</span><br><span class="line">  <span class="title class_">__main_block_impl_0</span>(<span class="title class_">void</span> *<span class="title class_">fp</span>, <span class="title class_">struct</span> <span class="title class_">__main_block_desc_0</span> *<span class="title class_">desc</span>, <span class="title class_">NSMutableString</span> *<span class="title class_">_mStr</span>, <span class="title class_">int</span> <span class="title class_">flags</span>=0) : <span class="title class_">mStr</span>(<span class="title class_">_mStr</span>) &#123;</span><br><span class="line">    impl.isa <span class="operator">=</span> <span class="operator">&amp;</span>_NSConcreteStackBlock;</span><br><span class="line">    impl.<span class="type">Flags</span> <span class="operator">=</span> flags;</span><br><span class="line">    impl.<span class="type">FuncPtr</span> <span class="operator">=</span> fp;</span><br><span class="line">    <span class="type">Desc</span> <span class="operator">=</span> desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> void __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 <span class="operator">*</span>__cself)&#123;</span><br><span class="line">  <span class="type">NSMutableString</span> <span class="operator">*</span>mStr <span class="operator">=</span> __cself-&gt;mStr; <span class="comment">// bound by copy</span></span><br><span class="line"></span><br><span class="line">        ((void (<span class="operator">*</span>)(id, <span class="type">SEL</span>, <span class="type">NSString</span> <span class="operator">*</span> _Nonnull))(void <span class="operator">*</span>)objc_msgSend)((id)mStr, sel_registerName(<span class="string">&quot;appendString:&quot;</span>), (<span class="type">NSString</span> <span class="operator">*</span>)<span class="operator">&amp;</span>__NSConstantStringImpl__var_folders_3f_crl5bnj956d806cp7d3ctqhm0000gn_T_main_fe0cca_mi_1);</span><br><span class="line">        <span class="type">NSLog</span>((<span class="type">NSString</span> <span class="operator">*</span>)<span class="operator">&amp;</span>__NSConstantStringImpl__var_folders_3f_crl5bnj956d806cp7d3ctqhm0000gn_T_main_fe0cca_mi_2,mStr);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">static</span> void __main_block_copy_0(<span class="keyword">struct</span> __main_block_impl_0<span class="operator">*</span>dst, <span class="keyword">struct</span> __main_block_impl_0<span class="operator">*</span>src) &#123;_Block_object_assign((void<span class="operator">*</span>)<span class="operator">&amp;</span>dst-&gt;mStr, (void<span class="operator">*</span>)src-&gt;mStr, <span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> void __main_block_dispose_0(<span class="keyword">struct</span> __main_block_impl_0<span class="operator">*</span>src) &#123;_Block_object_dispose((void<span class="operator">*</span>)src-&gt;mStr, <span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> <span class="title class_">__main_block_desc_0</span> &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t <span class="type">Block_size</span>;</span><br><span class="line">  void (<span class="operator">*</span>copy)(<span class="keyword">struct</span> __main_block_impl_0<span class="operator">*</span>, <span class="keyword">struct</span> __main_block_impl_0<span class="operator">*</span>);</span><br><span class="line">  void (<span class="operator">*</span>dispose)(<span class="keyword">struct</span> __main_block_impl_0<span class="operator">*</span>);</span><br><span class="line">&#125; __main_block_desc_0_DATA <span class="operator">=</span> &#123; <span class="number">0</span>, sizeof(<span class="keyword">struct</span> __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char <span class="operator">*</span> argv[]) &#123;</span><br><span class="line">    <span class="type">NSMutableString</span> <span class="operator">*</span>mStr <span class="operator">=</span> ((id (<span class="operator">*</span>)(id, <span class="type">SEL</span>))(void <span class="operator">*</span>)objc_msgSend)((id)<span class="operator">&amp;</span>__NSConstantStringImpl__var_folders_3f_crl5bnj956d806cp7d3ctqhm0000gn_T_main_fe0cca_mi_0, sel_registerName(<span class="string">&quot;mutableCopy&quot;</span>));</span><br><span class="line">    void (<span class="operator">*</span>myBlock)(void) <span class="operator">=</span> ((void (<span class="operator">*</span>)())<span class="operator">&amp;</span>__main_block_impl_0((void <span class="operator">*</span>)__main_block_func_0, <span class="operator">&amp;</span>__main_block_desc_0_DATA, mStr, <span class="number">570425344</span>));</span><br><span class="line"></span><br><span class="line">    <span class="type">NSLog</span>((<span class="type">NSString</span> <span class="operator">*</span>)<span class="operator">&amp;</span>__NSConstantStringImpl__var_folders_3f_crl5bnj956d806cp7d3ctqhm0000gn_T_main_fe0cca_mi_3,mStr);</span><br><span class="line">    ((void (<span class="operator">*</span>)(__block_impl <span class="operator">*</span>))((__block_impl <span class="operator">*</span>)myBlock)-&gt;<span class="type">FuncPtr</span>)((__block_impl <span class="operator">*</span>)myBlock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>作为对象的字符串会涉及到释放的问题，所以此处转换后的源码与基本类型有所区别(但不影响此处分析，后续会讲到)。</p>
<p>我们发现<code>Block</code>捕获了<code>mStr</code>，而且采用了指针传递的方式，这与上面的静态局部变量被捕获的方式很相似，但是<code>mStr</code>依然不可以直接赋值新的字符串。</p>
<p>其实弄清楚问题的关键是理解下面这句代码究做了什么？</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mStr <span class="operator">=</span> @<span class="string">&quot;newMstr&quot;</span>.mutableCopy;</span><br></pre></td></tr></table></figure>
<p>这句代码的含义可以归纳为：</p>
<ol>
<li>第一步：<code>@&quot;mStr&quot;.mutableCopy</code>创建了新的字符串对象，并将新对象的地址返回；</li>
<li>第二步：将新对象地址赋值给了<code>mStr</code>；</li>
</ol>
<p>我们知道<code>mStr</code>指针是在栈上的，它随时可能被释放，直接修改就有可能造成野指针错误，这刚好对应了先前自动变量不可修改的问题；</p>
<p>但通过<code>appendString</code>为什么又可以修改字符串呢？这主要因为<code>mStr</code>通过指针传递被<code>Block</code>捕获后，<code>Block</code>只是借助其内部的指针(和<code>mStr</code>同名，且指向同一个地址)，找到了可变字符串的位置，向这块内存追加新的内容，但是并未改变<code>mStr</code>的内存地址；</p>
<p><strong>重要总结：Block修改外部变量的限制，其实是指Block不允许修改栈中指针的内容</strong>；</p>
<p>说白了， <code>block</code>内部可以修改的是堆中的内容， 但不能直接修改栈中的任何东西；</p>
<h4 id="三、理解-block存储域类说明符的原理"><a href="#三、理解-block存储域类说明符的原理" class="headerlink" title="三、理解__block存储域类说明符的原理"></a>三、理解__block存储域类说明符的原理</h4><p>通过以上的分析，我们可以将<code>Block</code>理解为”<code>可以带有自动变量值的匿名函数</code>“，但由于存储域的关系，<code>Block</code>并不能直接修改捕获的自动变量。为了解决这个问题，总结起来有两种方案：</p>
<ol>
<li>使用存储域在静态区的变量(如<code>全局变量</code>、<code>静态全局变量</code>、<code>静态局部变量</code>)；</li>
<li>使用存储域类说明符<code>__block</code>；</li>
</ol>
<p>第一种方案我们已经分析过了，现在重点来理解<code>__block存储域说明符</code>的用法，其实<code>C</code>语言中的还有许多其他存储域类说明符，如：</p>
<ul>
<li><code>typedef</code></li>
<li><code>extern</code></li>
<li><code>static</code></li>
<li><code>auto</code></li>
<li><code>register</code></li>
</ul>
<p><code>__block说明符</code>就类似于<code>static、auto、register</code>，<strong>它们可以用于指定变量值设置到哪个存储域中</strong>。例如，<code>auto</code>表示自动变量存储在栈中(默认)，<code>static</code>表示静态变量存储在数据区中。</p>
<p>下面我们来实际使用<code>__block</code>，使用它来修改被<code>Block</code>捕获的自动变量，具体的代码如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//__block存储域修饰符</span></span><br><span class="line">int main(int argc, const char <span class="operator">*</span> argv[]) &#123;</span><br><span class="line">    __block int val <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    void (<span class="operator">^</span>myBlock)(void) <span class="operator">=</span> <span class="operator">^</span>&#123; val <span class="operator">=</span> <span class="number">20</span>;&#125;;</span><br><span class="line"></span><br><span class="line">    val <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">    myBlock();</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;val: %@&quot;</span>,val);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，<code>Block</code>中修改自动变量却没有像之前那样报错，这说明<code>__block说明符</code>是有效的，为了探究其中原理，现在我们再次把上述代码转换<code>C++</code>代码，具体如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">__Block_byref_val_0</span> &#123;</span><br><span class="line">  void <span class="operator">*</span>__isa;</span><br><span class="line">__Block_byref_val_0 <span class="operator">*</span>__forwarding;</span><br><span class="line"> int __flags;</span><br><span class="line"> int __size;</span><br><span class="line"> int val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__main_block_impl_0</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">__block_impl</span> <span class="title class_">impl</span>;</span><br><span class="line">  <span class="title class_">struct</span> <span class="title class_">__main_block_desc_0</span>* <span class="title class_">Desc</span>;</span><br><span class="line">  <span class="title class_">__Block_byref_val_0</span> *<span class="title class_">val</span>; // <span class="title class_">by</span> <span class="title class_">ref</span></span><br><span class="line">  <span class="title class_">__main_block_impl_0</span>(<span class="title class_">void</span> *<span class="title class_">fp</span>, <span class="title class_">struct</span> <span class="title class_">__main_block_desc_0</span> *<span class="title class_">desc</span>, <span class="title class_">__Block_byref_val_0</span> *<span class="title class_">_val</span>, <span class="title class_">int</span> <span class="title class_">flags</span>=0) : <span class="title class_">val</span>(<span class="title class_">_val</span>-&gt;<span class="title class_">__forwarding</span>) &#123;</span><br><span class="line">    impl.isa <span class="operator">=</span> <span class="operator">&amp;</span>_NSConcreteStackBlock;</span><br><span class="line">    impl.<span class="type">Flags</span> <span class="operator">=</span> flags;</span><br><span class="line">    impl.<span class="type">FuncPtr</span> <span class="operator">=</span> fp;</span><br><span class="line">    <span class="type">Desc</span> <span class="operator">=</span> desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> void __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 <span class="operator">*</span>__cself) &#123;</span><br><span class="line">  __Block_byref_val_0 <span class="operator">*</span>val <span class="operator">=</span> __cself-&gt;val; <span class="comment">// bound by ref</span></span><br><span class="line"> (val-&gt;__forwarding-&gt;val) <span class="operator">=</span> <span class="number">20</span>;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> void __main_block_copy_0(<span class="keyword">struct</span> __main_block_impl_0<span class="operator">*</span>dst, <span class="keyword">struct</span> __main_block_impl_0<span class="operator">*</span>src) &#123;_Block_object_assign((void<span class="operator">*</span>)<span class="operator">&amp;</span>dst-&gt;val, (void<span class="operator">*</span>)src-&gt;val, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> void __main_block_dispose_0(<span class="keyword">struct</span> __main_block_impl_0<span class="operator">*</span>src) &#123;_Block_object_dispose((void<span class="operator">*</span>)src-&gt;val, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> <span class="title class_">__main_block_desc_0</span> &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t <span class="type">Block_size</span>;</span><br><span class="line">  void (<span class="operator">*</span>copy)(<span class="keyword">struct</span> __main_block_impl_0<span class="operator">*</span>, <span class="keyword">struct</span> __main_block_impl_0<span class="operator">*</span>);</span><br><span class="line">  void (<span class="operator">*</span>dispose)(<span class="keyword">struct</span> __main_block_impl_0<span class="operator">*</span>);</span><br><span class="line">&#125; __main_block_desc_0_DATA <span class="operator">=</span> &#123; <span class="number">0</span>, sizeof(<span class="keyword">struct</span> __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char <span class="operator">*</span> argv[]) &#123;</span><br><span class="line">    __attribute__((__blocks__(byref))) __Block_byref_val_0 val <span class="operator">=</span> &#123;(void<span class="operator">*</span>)<span class="number">0</span>,(__Block_byref_val_0 <span class="operator">*</span>)<span class="operator">&amp;</span>val, <span class="number">0</span>, sizeof(__Block_byref_val_0), <span class="number">10</span>&#125;;</span><br><span class="line">    void (<span class="operator">*</span>myBlock)(void) <span class="operator">=</span> ((void (<span class="operator">*</span>)())<span class="operator">&amp;</span>__main_block_impl_0((void <span class="operator">*</span>)__main_block_func_0, <span class="operator">&amp;</span>__main_block_desc_0_DATA, (__Block_byref_val_0 <span class="operator">*</span>)<span class="operator">&amp;</span>val, <span class="number">570425344</span>));</span><br><span class="line"></span><br><span class="line">    (val.__forwarding-&gt;val) <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">    ((void (<span class="operator">*</span>)(__block_impl <span class="operator">*</span>))((__block_impl <span class="operator">*</span>)myBlock)-&gt;<span class="type">FuncPtr</span>)((__block_impl <span class="operator">*</span>)myBlock);</span><br><span class="line">    <span class="type">NSLog</span>((<span class="type">NSString</span> <span class="operator">*</span>)<span class="operator">&amp;</span>__NSConstantStringImpl__var_folders_wd_fhcn9bn91v56nlzv9mt5z8ym0000gn_T_main_a9f88e_mi_0,(val.__forwarding-&gt;val));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析代码，我们会发现<code>__block变量</code>的初始化已经发生了根本的变化，此时的<code>自动变量val</code>对应的是<code>C++</code>源码中的<code>__Block_byref_val_0</code>结构体。该结构体包含了五个成员变量，具体定义如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">__Block_byref_val_0</span> &#123;</span><br><span class="line">  void <span class="operator">*</span>__isa;                      <span class="comment">//isa指针</span></span><br><span class="line">__Block_byref_val_0 <span class="operator">*</span>__forwarding;  <span class="comment">//初始化传递的是自身结构体实例的指针</span></span><br><span class="line"> int __flags;                       <span class="comment">//标记flag</span></span><br><span class="line"> int __size;                        <span class="comment">//大小</span></span><br><span class="line"> int val;                           <span class="comment">//对应原自动变量val的值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们看到<code>__block变量val</code>的初始值为<code>10</code>，而这个值也出现在了调用<code>__Block_byref_val_0</code>结构体构造方法的时候，总结<code>__block变量</code>被捕获的过程如下：</p>
<ol>
<li>自动变量<code>__block int varl</code>被封装为<code>__Block_byref_val_0</code>结构体，保存原始变量的指针和值；</li>
<li><code>__Block_byref_val_0</code>结构体包含一个与<code>__block变量</code>同名的成员变量<code>val</code>，对应外部自动变量的值；</li>
<li><code>__Block_byref_val_0</code>结构体包含一个<code>__forwarding</code>指针，初始化传递的是自己的地址;</li>
<li>在<code>Block</code>初始化的过程中，调用<code>__main_block_impl_0</code>结构体构造函数时，会将<code>__block变量</code>的<code>__Block_byref_val_0</code>结构体实例的指针作为参数；</li>
</ol>
<p>接下来分析给<code>__block变量</code>赋值的代码，转换后的源码如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> void __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 <span class="operator">*</span>__cself) &#123;</span><br><span class="line">  __Block_byref_val_0 <span class="operator">*</span>val <span class="operator">=</span> __cself-&gt;val; <span class="comment">// bound by ref</span></span><br><span class="line"> (val-&gt;__forwarding-&gt;val) <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里，我们看到函数首先通过<code>cself-&gt;val</code>拿到了对应<code>__block变量</code>的结构体实例，然后又通过<code>__Block_byref_val_0</code>结构体实例的成员变量<code>__forwarding</code>，最终访问到了结构体成员变量<code>val</code>；</p>
<p>具体的过程，如下图所示：<br><img src="http://182.92.228.41/wp-content/uploads/block_visit__block_val.png" width="500" hegiht="313" align=center/></p>
<p>分析当前情况，我就会发现这里有两个很关键问题：</p>
<ol>
<li>为什么要使用多余的<code>__forwarding</code>指针来间接访问变量？</li>
<li>当前<code>__block</code>说明符的作用仅仅体现在：将<code>__block变量</code>封装为<code>__Block_byref_val_0</code>结构体，这并未从根本上改变自动变量的性质，自动变量究竟是如何被修改的呢？</li>
</ol>
<p>为了理解上述问题，我们首先应该对下面的代码有一个更加清晰的了解：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void (<span class="operator">^</span>myBlock)(void) <span class="operator">=</span> <span class="operator">^</span>&#123; val <span class="operator">=</span> <span class="number">10</span>;&#125;;</span><br></pre></td></tr></table></figure>

<p>代码中创建后的<code>Block</code>直接赋值给了强指针，这其实满足了<code>ARC</code>环境下编辑器对<code>Block</code>的优化：</p>
<p><strong>编译器会自动将Block从栈拷贝到堆上，而Block中的用到的__block变量也会被一并拷贝，并且被堆上的Block持有</strong>。</p>
<p>所以，即使是<code>Block</code>语法所在的作用域结束，堆上的<code>Block</code>和<code>__block变量</code>依然继续存在，自然也就不存在自动变量创建在栈上被释放的问题了。</p>
<p>借助图示，理解如下：<br><img src="http://182.92.228.41/wp-content/uploads/block_one_block_use__block_val.png" width="500" hegiht="313" align=center/></p>
<p>另外，当<code>__block</code>变量结构体实例在从栈上被拷贝到堆上时，会将成员变量的<code>__forwarding</code>的值替换为复制目标堆上的<code>__block</code>变量结构体实例的地址。</p>
<p>通过这种功能，无论是在<code>Block</code>语法中、<code>Block</code>语法外使用<code>__block</code>变量，还是<code>__block</code>变量配置在栈上或堆上，都可以顺利访问同<code>__block</code>变量。这就是<code>__forwarding</code>指针存在的意义。</p>
<p>使用图示，理解如下：<br><img src="http://182.92.228.41/wp-content/uploads/block_copy__block_val__forwarding_pointer_change.png" width="500" hegiht="313" align=center/></p>
<p><strong>重要总结：</strong></p>
<ol>
<li><code>__block</code>修饰的自动变量被封装为结构体，作为一个对象随着<code>Block</code>被拷贝到了堆上，解决了自动变量容易因作用域结束而释放的问题。</li>
<li>而<code>__block</code>变量结构体中的<code>__forwarding</code>则保证了无论在栈上还是堆上访问的都是同一个<code>__block变量</code>；</li>
<li>我们能够成功修改<code>__block</code>变量的值，其实是修改了堆上被Block持有的<code>__block</code>变量的内部成员变量val；</li>
</ol>
<p><strong>其他问题：</strong></p>
<ol>
<li><code>ARC</code>存在编译器的自动优化，自动拷贝<code>Block</code>的情况还包含了很多种，这里只是其中一种情况，上篇已分析过；</li>
<li>上述代码中，<code>__block</code>说明符将基本类型的数据封装为结构体类型(其中包含了<code>isa</code>指针)，这其实就说明<code>__block</code>变量已经是作为了一个对象在使用；</li>
<li>而对象类型被<code>Block</code>捕获之后都会涉及一些释放的问题，所以源码也出现了许多与对象释放相关的函数如：<code>__main_block_copy_0</code>、<code>__main_block_dispose_0</code>等。这个问题后续会详细分析；</li>
</ol>
<h4 id="四、-block变量的存储域"><a href="#四、-block变量的存储域" class="headerlink" title="四、__block变量的存储域"></a>四、__block变量的存储域</h4><p><code>Block</code>的存储域通常涉及到拷贝的操作，那么对于<code>__block</code>变量又是如何处理的呢？使用<code>__block</code>变量的<code>Block</code>从栈上拷贝到堆上时，<code>__block</code>变量也会受到影响；</p>
<h5 id="1-单个Block中使用-block变量"><a href="#1-单个Block中使用-block变量" class="headerlink" title="1.单个Block中使用__block变量"></a>1.单个Block中使用__block变量</h5><p>若一个<code>Block</code>中使用<code>__block</code>变量，则当该<code>Block</code>从栈拷贝到堆上时，使用的所有<code>__block</code>变量也全部被从栈上拷贝到堆上。使用图示理解如下：<br><img src="http://182.92.228.41/wp-content/uploads/block_one_block_use__block_val.png" width="500" hegiht="313" align=center/></p>
<h5 id="2-多个Block使用-block变量"><a href="#2-多个Block使用-block变量" class="headerlink" title="2.多个Block使用__block变量"></a>2.多个Block使用__block变量</h5><p>多个<code>Block</code>使用<code>__block</code>变量时，任何一个<code>Block</code>从栈上拷贝到堆上，<code>__block</code>变量就会一并从栈上拷贝到堆上并被该<code>Block</code>所持有。当剩下的Block从栈拷贝到堆上时，被拷贝的<code>Block</code>持有<code>__block</code>变量，并增加<code>__block</code>变量的引用计数。使用图示理解如下：<br><img src="http://182.92.228.41/wp-content/uploads/block_many_block_use__block_val.png" width="500" hegiht="313" align=center/></p>
<h5 id="3-block变量的释放"><a href="#3-block变量的释放" class="headerlink" title="3.__block变量的释放"></a>3.__block变量的释放</h5><p>如果拷贝到堆上的<code>Block</code>被释放，那么它使用的<code>__block</code>变量的引用计数会减一，如果引用计数为<code>0</code>就会被释放。使用图示理解如下：</p>
<img src="http://182.92.228.41/wp-content/uploads/block___block_val_release.png" width="500" hegiht="313" align=center/>

<p><strong>重要总结：</strong>无论是对基本类型还是对象使用<code>__block</code>修饰符，从转化后的源码来看，它们都会被转化为对应的结构体实例来使用，具有引用类型数据的特性。因此<code>__block</code>变量随着<code>Block</code>被拷贝到堆上后，它们的内存管理与普通的<code>OC</code>对象引用计数内存管理模式完全相同。</p>
<h4 id="五、理解Block对对象的捕获"><a href="#五、理解Block对对象的捕获" class="headerlink" title="五、理解Block对对象的捕获"></a>五、理解Block对对象的捕获</h4><p>仔细观察之前的源码我们就会发现，<code>Block</code>捕获对象类型和<code>__block</code>类型的变量(在底层被封装为结构体，也属于对象)明显比基本类型要复杂多，其实这里主要是因为对象类型还要涉及到释放的问题。下面的代码演示了<code>Block</code>对对象的捕获的过程，具体如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">typedef void(<span class="operator">^</span><span class="type">AddBlock</span>)(<span class="type">NSString</span> <span class="operator">*</span>); <span class="comment">//定义一种携带字符串参数的Block</span></span><br><span class="line">int main(int argc, const char <span class="operator">*</span> argv[]) &#123;</span><br><span class="line">    <span class="type">AddBlock</span> blk <span class="operator">=</span> <span class="literal">nil</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">NSMutableArray</span> <span class="operator">*</span>mArr <span class="operator">=</span> @[].mutableCopy;</span><br><span class="line">        blk <span class="operator">=</span> <span class="operator">^</span>(<span class="type">NSString</span> <span class="operator">*</span>string)&#123;</span><br><span class="line">            [mArr addObject:string];</span><br><span class="line">            <span class="type">NSLog</span>(@<span class="string">&quot;mArr count = %ld&quot;</span>,[mArr count]);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;<span class="comment">//NSMutableArray所在的作用域结束</span></span><br><span class="line">    </span><br><span class="line">    blk(@<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    blk(@<span class="string">&quot;B&quot;</span>);</span><br><span class="line">    blk(@<span class="string">&quot;C&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印结果：</span></span><br><span class="line">mArr count <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">mArr count <span class="operator">=</span> <span class="number">2</span></span><br><span class="line">mArr count <span class="operator">=</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>分析代码：当前为<code>ARC</code>环境下，编译器自动对访问了自动变量的<code>mArr</code>的<code>blk</code>进行了拷贝；所以<code>mArr</code>离开其所在的作用域结束时并没有被释放。虽然<code>mArr</code>指针已经不能使用，但是<code>blk</code>依然保留有对<code>mArr</code>的引用可以找到这块内存。所以代码也是运行正常的；</p>
<p>现在查看编译器转换后的源码如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">__main_block_impl_0</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">__block_impl</span> <span class="title class_">impl</span>;</span><br><span class="line">  <span class="title class_">struct</span> <span class="title class_">__main_block_desc_0</span>* <span class="title class_">Desc</span>;</span><br><span class="line">  <span class="title class_">NSMutableArray</span> *<span class="title class_">mArr</span>;</span><br><span class="line">  <span class="title class_">__main_block_impl_0</span>(<span class="title class_">void</span> *<span class="title class_">fp</span>, <span class="title class_">struct</span> <span class="title class_">__main_block_desc_0</span> *<span class="title class_">desc</span>, <span class="title class_">NSMutableArray</span> *<span class="title class_">_mArr</span>, <span class="title class_">int</span> <span class="title class_">flags</span>=0) : <span class="title class_">mArr</span>(<span class="title class_">_mArr</span>) &#123;</span><br><span class="line">    impl.isa <span class="operator">=</span> <span class="operator">&amp;</span>_NSConcreteStackBlock;</span><br><span class="line">    impl.<span class="type">Flags</span> <span class="operator">=</span> flags;</span><br><span class="line">    impl.<span class="type">FuncPtr</span> <span class="operator">=</span> fp;</span><br><span class="line">    <span class="type">Desc</span> <span class="operator">=</span> desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> void __main_block_copy_0(<span class="keyword">struct</span> __main_block_impl_0<span class="operator">*</span>dst, <span class="keyword">struct</span> __main_block_impl_0<span class="operator">*</span>src) &#123;_Block_object_assign((void<span class="operator">*</span>)<span class="operator">&amp;</span>dst-&gt;mArr, (void<span class="operator">*</span>)src-&gt;mArr, <span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> void __main_block_dispose_0(<span class="keyword">struct</span> __main_block_impl_0<span class="operator">*</span>src) &#123;_Block_object_dispose((void<span class="operator">*</span>)src-&gt;mArr, <span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> <span class="title class_">__main_block_desc_0</span> &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t <span class="type">Block_size</span>;</span><br><span class="line">  void (<span class="operator">*</span>copy)(<span class="keyword">struct</span> __main_block_impl_0<span class="operator">*</span>, <span class="keyword">struct</span> __main_block_impl_0<span class="operator">*</span>);</span><br><span class="line">  void (<span class="operator">*</span>dispose)(<span class="keyword">struct</span> __main_block_impl_0<span class="operator">*</span>);</span><br><span class="line">&#125; __main_block_desc_0_DATA <span class="operator">=</span> &#123; <span class="number">0</span>, sizeof(<span class="keyword">struct</span> __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;</span><br></pre></td></tr></table></figure>
<p>由于代码量较大，这里只提供了与捕获基本类型不同的部分；我们发现：</p>
<ol>
<li>当<code>Block</code>捕获对象类型的变量时，此处的<code>__main_block_desc_0</code>结构体中多了<code>copy</code>与<code>dispose</code>两个成员变量；</li>
<li>而且它们的初始化分别使用了<code>__main_block_copy_0</code>和<code>__main_block_dispose_0</code>的函数指针；</li>
</ol>
<p>这里主要的原因是：</p>
<ol>
<li>在<code>Objective-C</code>中，<code>C</code>语言结构体不能含有<code>__strong、__weak</code>修饰符的变量，因为编译器不知道应该如何进行<code>C</code>语言结构的初始化和废弃操作，不能很好地管理内存；</li>
<li>但是<code>OC</code>的运行时库能够准确把握<code>Block</code>从栈复制到堆以及堆上<code>Block</code>被废弃的时机，所以这里才会增加与内存管理相关的变量和函数。</li>
</ol>
<h5 id="1-main-block-copy-0函数"><a href="#1-main-block-copy-0函数" class="headerlink" title="1.__main_block_copy_0函数"></a>1.__main_block_copy_0函数</h5><p>结构体<code>__main_block_desc_0</code>中的<code>copy</code>成员变量对应了<code>__main_block_copy_0</code>函数。</p>
<p>当<code>Block</code>从栈上拷贝到堆上时，<code>__main_block_copy_0</code>函数会被调用，然后再调用其内部的<code>_Block_object_assign</code>函数。<code>_Block_object_assign</code>函数就相当于<code>retain</code>操作，会自动根据<code>__main_block_impl_0</code>结构体内部的<code>mArr</code>是什么类型的指针，对<code>mArr</code>对象产生强引用或者弱引用。如果<code>mArr</code>指针是<code>__strong</code>类型，则为强引用，引用计数<code>+1</code>，如果<code>mArr</code>指针是<code>__weak</code>类型，则为弱引用，引用计数不变。</p>
<h5 id="2-main-block-dispose-0函数"><a href="#2-main-block-dispose-0函数" class="headerlink" title="2.__main_block_dispose_0函数"></a>2.__main_block_dispose_0函数</h5><p>结构体<code>__main_block_desc_0</code>中的<code>dispose</code>成员变量对应了<code>__main_block_dispose_0</code>函数。<br>当<code>Block</code>被废弃时，<code>__main_block_dispose_0</code>函数会被调用，<code>__main_block_dispose_0</code>函数就相当于release操作，将<code>mArr</code>对象的引用计数减1，如果此时引用计数为0，那么遵循引用计数的规则<code>mArr</code>也就被释放了。</p>
<h5 id="3-Block捕获对象与-block变量的区别"><a href="#3-Block捕获对象与-block变量的区别" class="headerlink" title="3.Block捕获对象与__block变量的区别"></a>3.Block捕获对象与__block变量的区别</h5><p>其实<code>Block</code>捕获对象与<code>__block</code>变量后，对于它们的内存管理的方式相同，也都是使用<code>copy</code>函数持有和<code>disposde</code>函数释放；两者体现在源码上的不同，我们可以观察下面的函数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> void __main_block_copy_0(<span class="keyword">struct</span> __main_block_impl_0<span class="operator">*</span>dst, <span class="keyword">struct</span> __main_block_impl_0<span class="operator">*</span>src) &#123;_Block_object_assign((void<span class="operator">*</span>)<span class="operator">&amp;</span>dst-&gt;mArr, (void<span class="operator">*</span>)src-&gt;mArr, <span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);&#125;</span><br></pre></td></tr></table></figure>
<p><code>_Block_object_assign</code>函数中的最后一个参数用于区分<code>Block</code>捕获的是对象还是<code>__block</code>变量。</p>
<table>
<thead>
<tr>
<th>对象变量</th>
<th>__block变量</th>
</tr>
</thead>
<tbody><tr>
<td>BLOCK_FIELD_IS_OBJECT</td>
<td>BLOCK_FIELD_IS_BYREF</td>
</tr>
</tbody></table>
<h4 id="六、Block的循环引用问题"><a href="#六、Block的循环引用问题" class="headerlink" title="六、Block的循环引用问题"></a>六、Block的循环引用问题</h4><p><code>Block</code>在从栈拷贝到堆上时，如果其中捕获了强类型的对象，该对象就会被<code>Block</code>所持有。这样很容易就会引起循环引用，我们来看下面的代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">typedef void(<span class="operator">^</span><span class="type">MyBlock</span>)(void);</span><br><span class="line"></span><br><span class="line"><span class="meta">@interface</span> <span class="type">MyObject</span> : <span class="type">NSObject</span></span><br><span class="line"><span class="meta">@property</span>(nonatomic,copy) <span class="type">MyBlock</span> block;</span><br><span class="line"><span class="meta">@end</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@implementation</span> <span class="type">MyObject</span></span><br><span class="line"><span class="operator">-</span> (instancetype)<span class="keyword">init</span> &#123;</span><br><span class="line">    <span class="keyword">self</span> <span class="operator">=</span> [<span class="keyword">super</span> <span class="keyword">init</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> (void)dealloc &#123;</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;MyObject dealloc!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@end</span></span><br><span class="line"></span><br><span class="line">int main(int argc, char <span class="operator">*</span> argv[]) &#123;</span><br><span class="line">    <span class="meta">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="type">MyObject</span> <span class="operator">*</span>myObject <span class="operator">=</span> [[<span class="type">MyObject</span> alloc] <span class="keyword">init</span>];</span><br><span class="line">        myObject.block <span class="operator">=</span> <span class="operator">^</span>&#123;</span><br><span class="line">            <span class="comment">//Capturing &#x27;myObject&#x27; strongly in this block is likely to lead to a retain cycle</span></span><br><span class="line">            <span class="type">NSLog</span>(@<span class="string">&quot;捕获对象:%@&quot;</span>, myObject );</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;myObject的作用域结束了&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>不仅编译器给出了内存泄漏的警告，而且测试结果也证实了<code>MyObject</code>的<code>dealloc</code>实例方法并没有执行，这里发生了循环引用。原因就在与<code>myObject</code>的<code>block</code>在被自动拷贝到堆上的过程中持有了<code>myObject</code>，而<code>myObject</code>本身就持有了<code>block</code>，所以两者相互持有就产生了问题。</p>
<p>现在就来总结类似情况下的<code>Block</code>循环引用的处理方法，可分为<code>ARC</code>和<code>MRC</code>两种情况：</p>
<h5 id="1-解决ARC环境下的循环引用问题"><a href="#1-解决ARC环境下的循环引用问题" class="headerlink" title="1.解决ARC环境下的循环引用问题"></a>1.解决ARC环境下的循环引用问题</h5><p><strong>方法1：使用弱引用修饰符__weak、和__unsafe_unretained修饰符；</strong><br>使用<code>__weak</code>解决上述问题，需要改进的代码如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char <span class="operator">*</span> argv[]) &#123;</span><br><span class="line">    <span class="meta">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="type">MyObject</span> <span class="operator">*</span>myObject <span class="operator">=</span> [[<span class="type">MyObject</span> alloc] <span class="keyword">init</span>];</span><br><span class="line">        __weak typeof(myObject) weakObject <span class="operator">=</span> myObject;</span><br><span class="line">        myObject.block <span class="operator">=</span> <span class="operator">^</span>&#123;</span><br><span class="line">            <span class="type">NSLog</span>(@<span class="string">&quot;捕获对象:%@&quot;</span>, weakObject );</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;myObject的作用域结束了&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码使用弱引用修饰符<code>__weak ，在block内部对  myObject</code>设置为弱引用，弱引用不会导致Block捕获对象的引用计数增加(这在上述分析中已经讲过)。</p>
<p>注意<code>__weak</code>和<code>__unsafe_unretained</code>的区别：</p>
<ol>
<li><strong>__weak</strong>：<code>iOS4</code>之后才提供使用，而且比<code>__unsafe_unretained</code>更加安全，因为当它指向的对象销毁时，会自动将指针置为<code>nil</code>；推荐使用。</li>
<li><strong>__unsafe_unretained</strong>：在<code>__weak</code>出现以前常用修饰符，其指向的对象销毁时，指针存储的地址值不变，所以没有<code>__weak</code>安全。</li>
</ol>
<p><strong>方法2：使用__block说明符</strong><br>回忆<code>__block</code>修饰基本类型的C++源码，我们可以知道<code>__block</code>修饰对象时其实也会封装一个结构体类型，而这个结构体中会持有自动变量对象，这样就会造成下图的情况：<br><img src="http://182.92.228.41/wp-content/uploads/block___block_handle_cycle1.jpeg" width="500" hegiht="313" align=center/><br>使用<code>__block</code>解决上述问题，需要改进的代码如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char <span class="operator">*</span> argv[]) &#123;</span><br><span class="line">    <span class="meta">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="type">MyObject</span> <span class="operator">*</span>myObject <span class="operator">=</span> [[<span class="type">MyObject</span> alloc] <span class="keyword">init</span>];</span><br><span class="line">        __block <span class="type">MyObject</span> <span class="operator">*</span>tempObject <span class="operator">=</span> myObject;</span><br><span class="line">        myObject.block <span class="operator">=</span> <span class="operator">^</span>&#123;</span><br><span class="line">            <span class="type">NSLog</span>(@<span class="string">&quot;捕获对象:%@&quot;</span>, tempObject );</span><br><span class="line">            tempObject <span class="operator">=</span> <span class="literal">nil</span>;  <span class="comment">//关键代码1</span></span><br><span class="line">        &#125;;</span><br><span class="line">        myObject.block();      <span class="comment">//关键代码2：执行持有的block；</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;myObject的作用域结束了&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码有两句关键，已经通过注释标注；在<code>block</code>中通过<code> tempObject = nil</code>这句代码，<code>__block</code>变量<code>tempObject</code>对于<code>MyObject</code>类对象的强引用失效了，而这句代码生效的前提又是<code>block</code>被调用了(关键代码2)；这种方式避免了循环引用的产生的过程如下图：<br><img src="http://182.92.228.41/wp-content/uploads/block___block_handle_cycle2.png" width="500" hegiht="313" align=center></p>
<p><strong>特别注意：</strong>如果关键代码2没有被调用，同样会造成循环引用。</p>
<p><strong>使用__block变量相比弱引用修饰符的优缺点:</strong><br>优点：</p>
<ol>
<li>通过执行<code>block</code>的方式，可动态决定<code>__block</code>变量可以控制对象的持有时间；</li>
<li>在不能使用<code>__weak</code>修饰符的环境下，避免使用<code>__unsafe_unretained</code>(因为要考虑野指针问题)；</li>
</ol>
<p>缺点：为了避免循环引用，必须执行<code>Block</code>;</p>
<h5 id="2-解决MRC环境下的循环引用问题"><a href="#2-解决MRC环境下的循环引用问题" class="headerlink" title="2.解决MRC环境下的循环引用问题"></a>2.解决MRC环境下的循环引用问题</h5><p><strong>方法1：使用弱引用修饰符__unsafe_unretained修饰符；</strong><br>在<code>MRC</code>环境下不支持使用<code>__weak</code>，所以只能使用<code>__unsafe_unretained</code>；使用原理同<code>ARC</code>环境下相同，这里不再赘述。</p>
<p><strong>方法2：使用__block说明符</strong><br><code>MRC</code>环境下，<code>__block</code>说明符被用来避免循环引用。这是因为当<code>Block</code>从栈拷贝到堆时，若<code>Block</code>使用的变量是附有<code>__block</code>说明符的id类型或者对象类型的自动变量，不会被<code>retain</code>，否则就会被<code>retain</code>。这一点和<code>ARC</code>环境是不同的。现在我们在MRC环境下改进代码，具体如下:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char <span class="operator">*</span> argv[]) &#123;</span><br><span class="line">    <span class="type">MyObject</span> <span class="operator">*</span>myObject <span class="operator">=</span> [[<span class="type">MyObject</span> alloc] <span class="keyword">init</span>];</span><br><span class="line">    __unsafe_unretained <span class="type">MyObject</span> <span class="operator">*</span>tempObject <span class="operator">=</span> myObject;</span><br><span class="line">    myObject.block <span class="operator">=</span> <span class="operator">^</span>&#123;</span><br><span class="line">        <span class="type">NSLog</span>(@<span class="string">&quot;捕获对象:%@&quot;</span>, tempObject );</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">NSAutoreleasePool</span> <span class="operator">*</span>pool <span class="operator">=</span> [[<span class="type">NSAutoreleasePool</span> alloc] <span class="keyword">init</span>];</span><br><span class="line">    [myObject autorelease];</span><br><span class="line">    [pool drain];  <span class="comment">//等同于[myObject release];</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印结果：</span></span><br><span class="line"><span class="comment">//MyObject dealloc!</span></span><br></pre></td></tr></table></figure>

<p>上述操作将代码改为了<code>MRC</code>下的自动释放池，相比之前在<code>ARC</code>中使用<code>__block</code>，这里没有在<code>Block</code>内部置<code>nil</code>的操作，也没有调用<code>block</code>，但同样解决了循环引用的问题；</p>
<p><strong>重要总结：</strong><code>__block</code>说明符在<code>ARC</code>与<code>MRC</code>环境下的用途有很大区别，因此在编写代码时我们必须区分好这两种环境；
 </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wuyubeichen.github.io/2019/04/12/iOS%E5%BA%95%E5%B1%82-Block%E6%9C%AC%E8%B4%A8%E5%8F%8A%E5%AD%98%E5%82%A8%E5%9F%9F%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Author">
      <meta itemprop="description" content="iOS Developer, Beijing China">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="梧雨北辰的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/12/iOS%E5%BA%95%E5%B1%82-Block%E6%9C%AC%E8%B4%A8%E5%8F%8A%E5%AD%98%E5%82%A8%E5%9F%9F%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">iOS底层-Block本质及存储域问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-12 16:16:49" itemprop="dateCreated datePublished" datetime="2019-04-12T16:16:49+08:00">2019-04-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-29 09:39:32" itemprop="dateModified" datetime="2022-08-29T09:39:32+08:00">2022-08-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS%E5%BA%95%E5%B1%82/" itemprop="url" rel="index"><span itemprop="name">iOS底层</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>主要内容：</strong></p>
<ol>
<li>分析<code>Block</code>的源码</li>
<li>验证<code>Block</code>的本质是对象</li>
<li>理解<code>Block</code>的存储域分类</li>
<li>验证<code>Block</code>的不同存储域</li>
<li>分析<code>Block</code>的<code>Copy</code>原理</li>
</ol>
<h4 id="一、分析Block的源码"><a href="#一、分析Block的源码" class="headerlink" title="一、分析Block的源码"></a>一、分析Block的源码</h4><p>为了分析<code>Block</code>的源码，从一个最简单的<code>Block</code>使用示例说起，测试代码如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.m文件：</span></span><br><span class="line">#<span class="keyword">import</span> &lt;Foundation/Foundation.h&gt;</span><br><span class="line">int main(int argc, char <span class="operator">*</span> argv[]) &#123;</span><br><span class="line">    int num <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    void (<span class="operator">^</span>block)(void) <span class="operator">=^</span>&#123;<span class="type">NSLog</span>(@<span class="string">&quot;num = %d&quot;</span>,num);&#125;;</span><br><span class="line">    block();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Objective-C</code>语言是基于<code>C</code>、<code>C++</code>的，为了深入理解<code>Block</code>的底层结构，我们可以通过如下的编译器命令将上述代码转换成<code>C++</code>源码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang <span class="operator">-</span>rewrite<span class="operator">-</span>objc 源代码文件名(如此例中的main.m)</span><br></pre></td></tr></table></figure>
<p>转化后的<code>C++</code>源码如下:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">__block_impl</span> &#123;</span><br><span class="line">  void <span class="operator">*</span>isa;</span><br><span class="line">  int <span class="type">Flags</span>;</span><br><span class="line">  int <span class="type">Reserved</span>;</span><br><span class="line">  void <span class="operator">*</span><span class="type">FuncPtr</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__main_block_impl_0</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">__block_impl</span> <span class="title class_">impl</span>;</span><br><span class="line">  <span class="title class_">struct</span> <span class="title class_">__main_block_desc_0</span>* <span class="title class_">Desc</span>;</span><br><span class="line">  <span class="title class_">int</span> <span class="title class_">num</span>;</span><br><span class="line">  <span class="title class_">__main_block_impl_0</span>(<span class="title class_">void</span> *<span class="title class_">fp</span>, <span class="title class_">struct</span> <span class="title class_">__main_block_desc_0</span> *<span class="title class_">desc</span>, <span class="title class_">int</span> <span class="title class_">_num</span>, <span class="title class_">int</span> <span class="title class_">flags</span>=0) : <span class="title class_">num</span>(<span class="title class_">_num</span>) &#123;</span><br><span class="line">    impl.isa <span class="operator">=</span> <span class="operator">&amp;</span>_NSConcreteStackBlock;</span><br><span class="line">    impl.<span class="type">Flags</span> <span class="operator">=</span> flags;</span><br><span class="line">    impl.<span class="type">FuncPtr</span> <span class="operator">=</span> fp;</span><br><span class="line">    <span class="type">Desc</span> <span class="operator">=</span> desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> void __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 <span class="operator">*</span>__cself) &#123;</span><br><span class="line">  int num <span class="operator">=</span> __cself-&gt;num; <span class="comment">// bound by copy</span></span><br><span class="line"><span class="type">NSLog</span>((<span class="type">NSString</span> <span class="operator">*</span>)<span class="operator">&amp;</span>__NSConstantStringImpl__var_folders_wd_fhcn9bn91v56nlzv9mt5z8ym0000gn_T_main_9e3646_mi_0,num);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> <span class="title class_">__main_block_desc_0</span> &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t <span class="type">Block_size</span>;</span><br><span class="line">&#125;</span><br><span class="line"> __main_block_desc_0_DATA <span class="operator">=</span> &#123; <span class="number">0</span>, sizeof(<span class="keyword">struct</span> __main_block_impl_0)&#125;;</span><br><span class="line"></span><br><span class="line">int main(int argc, char <span class="operator">*</span> argv[]) &#123;</span><br><span class="line">    int num <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    void (<span class="operator">*</span>myBlock)(void) <span class="operator">=</span>((void (<span class="operator">*</span>)())<span class="operator">&amp;</span>__main_block_impl_0((void <span class="operator">*</span>)__main_block_func_0, <span class="operator">&amp;</span>__main_block_desc_0_DATA, num));</span><br><span class="line">    ((void (<span class="operator">*</span>)(__block_impl <span class="operator">*</span>))((__block_impl <span class="operator">*</span>)myBlock)-&gt;<span class="type">FuncPtr</span>)((__block_impl <span class="operator">*</span>)myBlock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对比<code>OC</code>代码与<code>C++</code>源码中的<code>main</code>函数，我们发现：</p>
<ol>
<li>创建<code>Block</code>其实是调用了<code>__main_block_impl_0</code>结构体的构造函数；</li>
<li><code>Block</code>中待执行代码也都被封装到了<code>__main_block_func_0</code>函数中；</li>
</ol>
<p>另外值得注意的是，这些<code>C++</code>的结构体和函数的命名，是根据<code>Block</code>语法所属的函数名(此处为<code>main</code>)和<code>Block</code>语法在该函数出现的顺序值(此处为<code>0</code>)来设定的；</p>
<p>根据这些对应关系，我们<code>对C++</code>源码中的内容一一分析：</p>
<h5 id="1-main-block-imp-0结构体"><a href="#1-main-block-imp-0结构体" class="headerlink" title="1.__main_block_imp_0结构体"></a>1.__main_block_imp_0结构体</h5><p><code>__main_block_impl_0</code>结构体对应了<code>Block</code>的定义，结构体内部包含了三个成员变量<code>impl</code>、<code>Desc</code>、<code>num</code>。</p>
<p><code>num</code>其实就是被捕获的变量(后续再讲)，另外还有一个同名的构造函数<code>__main_block_impl_0</code>。可以看到相关的代码如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">__main_block_impl_0</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">__block_impl</span> <span class="title class_">impl</span>;</span><br><span class="line">  <span class="title class_">struct</span> <span class="title class_">__main_block_desc_0</span>* <span class="title class_">Desc</span>;</span><br><span class="line">  <span class="title class_">int</span> <span class="title class_">num</span>;</span><br><span class="line">  <span class="title class_">__main_block_impl_0</span>(<span class="title class_">void</span> *<span class="title class_">fp</span>, <span class="title class_">struct</span> <span class="title class_">__main_block_desc_0</span> *<span class="title class_">desc</span>, <span class="title class_">int</span> <span class="title class_">_num</span>, <span class="title class_">int</span> <span class="title class_">flags</span>=0) : <span class="title class_">num</span>(<span class="title class_">_num</span>) &#123;</span><br><span class="line">    impl.isa <span class="operator">=</span> <span class="operator">&amp;</span>_NSConcreteStackBlock;</span><br><span class="line">    impl.<span class="type">Flags</span> <span class="operator">=</span> flags;</span><br><span class="line">    impl.<span class="type">FuncPtr</span> <span class="operator">=</span> fp;</span><br><span class="line">    <span class="type">Desc</span> <span class="operator">=</span> desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>Block</code>通过调用这里的构造函数得以创建，调用时需传入了四个参数：<code>(void *fp, struct __main_block_desc_0 *desc, int _num, int flags=0)</code>，前三个参数对应成员变量的初始化，而最后一个参数<code>flags</code>携带默认值可暂不考虑；</p>
<h5 id="2-block-impl结构体"><a href="#2-block-impl结构体" class="headerlink" title="2.__block_impl结构体"></a>2.__block_impl结构体</h5><p><code>__main_block_imp_0</code>结构体的第一个成员变量<code>impl</code>，就是<code>__block_impl</code>结构体类型；</p>
<p>尤其注意：</p>
<ol>
<li>该结构体中包含有<code>isa</code>指针，从这一点就可以说明<code>Block</code>本质上还是一个<code>OC</code>对象，因为<code>OC</code>中只有对象才会具有<code>isa</code>指针的概念；</li>
<li><code>FuncPtr</code>是一个函数指针，在<code>__main_block_imp_0</code>构造函数调用时被赋值；</li>
</ol>
<h5 id="3-main-block-desc-0结构体"><a href="#3-main-block-desc-0结构体" class="headerlink" title="3.__main_block_desc_0结构体"></a>3.__main_block_desc_0结构体</h5><p><code>__main_block_imp_0</code>结构体构造函数中传入参数<code>desc</code>，其实就是<code>__main_block_desc_0</code>对象。该结构体包含两个成员变量：</p>
<ol>
<li><code>reserved</code>：系统保留值；</li>
<li><code>Block_size</code>：代表<code>Block</code>的大小；</li>
</ol>
<h5 id="4-main-block-func-0函数"><a href="#4-main-block-func-0函数" class="headerlink" title="4.__main_block_func_0函数"></a>4.__main_block_func_0函数</h5><p><code>__main_block_imp_0</code>结构体构造函数中传入函数指针<code>fp</code>，其实就是<code>__main_block_func_0</code>函数的地址；</p>
<p>该函数是将<code>Block</code>中所有的代码封装为函数，以待被调用；</p>
<h5 id="5-总结Block的特点"><a href="#5-总结Block的特点" class="headerlink" title="5.总结Block的特点"></a>5.总结Block的特点</h5><ol>
<li><code>Block</code>本质上一个<code>OC</code>对象：比如这里的<code>Block</code>，其底层对应了<code>__main_block_impl_0</code>结构体，而且内部包含有<code>isa</code>指针；</li>
<li><code>Block</code>中携带了函数执行的环境：此处<code>Block</code>里待执行的代码，在底层被封装为<code>__main_block_func_0</code>函数，以实现调用；</li>
<li><code>Block</code>相当于其他语言中的闭包或者匿名函数：它与函数区别在于，<code>Block</code>相当于<code>函数+函数执行的上下文环境</code>(捕获外部变量下面会讲到)；</li>
</ol>
<h4 id="二、验证Block的本质是对象"><a href="#二、验证Block的本质是对象" class="headerlink" title="二、验证Block的本质是对象"></a>二、验证Block的本质是对象</h4><p>下面通过打印的方式验证<code>Block</code>对象本质，测试代码如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">-</span> (void)testBlock5 &#123;</span><br><span class="line">    void(<span class="operator">^</span>block)(int a) <span class="operator">=</span> <span class="operator">^</span>(int a) &#123;</span><br><span class="line">        <span class="type">NSLog</span>(@<span class="string">&quot;This is a block&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;%@&quot;</span>,[block <span class="keyword">class</span>]);</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;%@&quot;</span>,[[block <span class="keyword">class</span>] superclass]);</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;%@&quot;</span>,[[[block <span class="keyword">class</span>] superclass] superclass]);</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;%@&quot;</span>,[[[[block <span class="keyword">class</span>] superclass] superclass] superclass]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印结果：</span></span><br><span class="line"><span class="comment">//__NSGlobalBlock__</span></span><br><span class="line"><span class="comment">//__NSGlobalBlock</span></span><br><span class="line"><span class="comment">//NSBlock</span></span><br><span class="line"><span class="comment">//NSObject</span></span><br></pre></td></tr></table></figure>
<p>观察打印结果：</p>
<ol>
<li>我们看到<code>Block</code>最终继承于<code>NSObject</code>类型，这里再一次验证了<code>Block</code>本质就是<code>OC</code>对象的结论；</li>
<li>而打印结果中出现的<code>__NSGlobalBlock__</code>，说明此处的<code>Block</code>的存储域为静态区；</li>
</ol>
<h4 id="三、理解Block的存储域分类"><a href="#三、理解Block的存储域分类" class="headerlink" title="三、理解Block的存储域分类"></a>三、理解Block的存储域分类</h4><p>在之前<code>Block</code>结构体构造函数中，我们很容易能找到这样一句代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">impl.isa <span class="operator">=</span> <span class="operator">&amp;</span>_NSConcreteStackBlock;</span><br></pre></td></tr></table></figure>
<p>我们已经知道<code>Block</code>也是一个<code>OC</code>对象，而每个<code>OC</code>对象都有一个<code>isa</code>指针指向其类对象，这里的情况也是类似的；</p>
<p>这里<code>Block</code>的<code>isa</code>指针指向了<code>_NSConcreteStackBlock</code>类对象，即此时的<code>Block</code>是以<code>_NSConcreteStackBlock</code>类为模板创建的实例；</p>
<p>除此之外，其实还有两个与之类似的类<code>_NSConcreteGlobalBlock</code>和<code>_NSConcreteMallocBlock</code>，不同的<code>Block</code>类创建的对象用于不同的存储域，也对应了对应不同的<code>OC</code>类型，具体整理如下：</p>
<table>
<thead>
<tr>
<th>clang类</th>
<th>OC类</th>
<th>内存区域</th>
</tr>
</thead>
<tbody><tr>
<td><code>_NSConcreteStackBlock</code></td>
<td><code>__NSStackBlock__</code></td>
<td>栈区</td>
</tr>
<tr>
<td><code>_NSConcreteMallocBlock</code></td>
<td><code>__NSMallocBlock__</code></td>
<td>堆区</td>
</tr>
<tr>
<td><code>_NSConcreteGlobalBlock</code></td>
<td><code>__NSGlobalBlock__</code></td>
<td>静态区</td>
</tr>
</tbody></table>
<h4 id="四、验证Block的不同存储域"><a href="#四、验证Block的不同存储域" class="headerlink" title="四、验证Block的不同存储域"></a>四、验证Block的不同存储域</h4><p>不同存储域的<code>Block</code>使用方式有很大差别，而正确区分<code>Block</code>类型的关键在于：**Block中是否引用了自动变量(需要MRC下测试)**，总结起来如下：</p>
<table>
<thead>
<tr>
<th>Block类型</th>
<th>环境</th>
<th>内存区域</th>
</tr>
</thead>
<tbody><tr>
<td><code>_NSConcreteGlobalBlock(__NSGlobalBlock__)</code></td>
<td>没有访问自动变量；<br>或者只用到静态区变量</td>
<td>静态区</td>
</tr>
<tr>
<td><code>_NSConcreteStackBlock( __NSStackBlock__)</code></td>
<td>访问了自动变量</td>
<td>栈区</td>
</tr>
<tr>
<td><code>_NSConcreteMallocBlock(__NSMallocBlock__)</code></td>
<td><code>__NSStackBlock__</code>调用了<code>copy</code></td>
<td>堆区</td>
</tr>
</tbody></table>
<p>为了验证上述情况，我们需要切换到<code>MRC</code>环境下，因为在<code>ARC</code>环境下的编译器为我们做了很多优化的工作，比如自动将栈区的<code>Block</code>拷贝到堆区，这样我们也就不容易捕获到<code>Block</code>初始状态的位置了。</p>
<p>所以，这里暂时将开发环境切换至<code>MRC</code>下来测试，相关的测试代码如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">-</span> (void)testBlock7 &#123;</span><br><span class="line">    <span class="comment">//1.Block内部没有调用外部自动变量</span></span><br><span class="line">    void (<span class="operator">^</span>block1)(void) <span class="operator">=</span> <span class="operator">^</span>&#123;</span><br><span class="line">        <span class="type">NSLog</span>(@<span class="string">&quot;Block&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.Block内部调用外部自动变量</span></span><br><span class="line">    int a <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    void (<span class="operator">^</span>block2)(void) <span class="operator">=</span> <span class="operator">^</span>&#123;</span><br><span class="line">        <span class="type">NSLog</span>(@<span class="string">&quot;Block-%d&quot;</span>,a);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.拷贝栈上的block</span></span><br><span class="line">    void (<span class="operator">^</span>block3)(void) <span class="operator">=</span> <span class="operator">^</span>&#123;</span><br><span class="line">        <span class="type">NSLog</span>(@<span class="string">&quot;Block-%d&quot;</span>,a);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//打印Block类型</span></span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;%@ %@ %@&quot;</span>, [block1 <span class="keyword">class</span>], [block2 <span class="keyword">class</span>], [[block3 copy] <span class="keyword">class</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印结果：</span></span><br><span class="line"><span class="comment">//__NSGlobalBlock__ __NSStackBlock__ __NSMallocBlock__</span></span><br></pre></td></tr></table></figure>

<h5 id="1-NSGlobalBlock-静态区"><a href="#1-NSGlobalBlock-静态区" class="headerlink" title="1.NSGlobalBlock(静态区)"></a>1.<strong>NSGlobalBlock</strong>(静态区)</h5><ol>
<li>判断依据：<code>Block</code>中没有引用自动变量或者只用到静态区变量；</li>
<li>此类型的<code>Block</code>与全局变量一样设置在程序的静态区，直到程序结束才会被回收；</li>
<li>此类型的<code>Block</code>不依赖执行时的状态，所以整个程序只需一个实例，用的也较少；</li>
</ol>
<h5 id="2-NSStackBlock-栈区"><a href="#2-NSStackBlock-栈区" class="headerlink" title="2.NSStackBlock(栈区)"></a>2.<strong>NSStackBlock</strong>(栈区)</h5><ol>
<li>判断依据：<code>Block</code>中访问自动变量，并且存放在栈中；</li>
<li>栈中的内存由系统自动分配和释放，作用域执行完毕之后就会被立即释放；</li>
<li>所以我们有可能遇到<code>Block</code>内存销毁之后才使用它的情况，开发中遇到的很多问题也都是因此而起；</li>
</ol>
<h5 id="3-NSMallocBlock-堆区"><a href="#3-NSMallocBlock-堆区" class="headerlink" title="3.NSMallocBlock(堆区)"></a>3.<strong>NSMallocBlock</strong>(堆区)</h5><ol>
<li><code>_NSStackBlock__</code>执行<code>copy</code>操作会生成<code>__NSMallocBlock__</code>；</li>
<li>栈<code>Block</code>被拷贝后存放在堆中后，需要我们自己进行内存管理，否则还可能造成一些循环引用的问题；</li>
</ol>
<h4 id="五、分析Block的Copy原理"><a href="#五、分析Block的Copy原理" class="headerlink" title="五、分析Block的Copy原理"></a>五、分析Block的Copy原理</h4><p><code>Block</code>有着不同的存储域类型，尤其是配置在栈上的<code>Block</code>(即<code>__NSStackBlock__</code>类型的<code>Block</code>)，如果其所属的作用域结束，该<code>Block</code>就会被释放，此时若继续使用<code>Block</code>，就会造成野指针问题；</p>
<p>所以，我们通常的做法就是执行<code>copy</code>操作，将其由栈区拷贝到堆区得到<code>__NSMallocBlock__</code>，而<code>__NSMallocBlock__</code>也会在其引用计数为<code>0</code>的时候被释放；</p>
<p>进一步分析<code>Block</code>的拷贝，需要分为<code>MRC</code>和<code>ARC</code>两种环境来考虑。</p>
<h5 id="1-MRC下的Block拷贝"><a href="#1-MRC下的Block拷贝" class="headerlink" title="1.MRC下的Block拷贝"></a>1.MRC下的Block拷贝</h5><p>在<code>MRC</code>环境下，我们只能显式的通过<code>copy</code>来实现<code>Block</code>的拷贝；通常为了避免<code>Block</code>的释放，我们定义<code>Block</code>属性的时候必须使用<code>copy修饰符</code>也正是基于这个原因。</p>
<p>下面是在<code>MRC</code>环境下测试栈<code>Block</code>的使用，具体代码如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">typedef void(<span class="operator">^</span><span class="type">PrintBlock</span>)(void);</span><br><span class="line"></span><br><span class="line"><span class="meta">@interface</span> <span class="type">ViewController</span> ()</span><br><span class="line"><span class="meta">@property</span> (nonatomic ,copy)<span class="type">PrintBlock</span> block1;</span><br><span class="line"><span class="meta">@property</span> (nonatomic ,copy)<span class="type">PrintBlock</span> block2;</span><br><span class="line"><span class="meta">@end</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@implementation</span> <span class="type">ViewController</span></span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> (void)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    [<span class="keyword">self</span> createBlock];</span><br><span class="line">    <span class="keyword">self</span>.block1();</span><br><span class="line">    <span class="keyword">self</span>.block2();</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;block1:%@&quot;</span>, [<span class="keyword">self</span>.block1 <span class="keyword">class</span>]); <span class="comment">//报错Thread 1: EXC_BAD_ACCESS (code=1, address=0x7ffeeb90b8c0)</span></span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;block2:%@&quot;</span>, [<span class="keyword">self</span>.block2 <span class="keyword">class</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> (void)createBlock &#123;</span><br><span class="line">    int a <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//此处采用直接赋值的方式，不会触发setter方法</span></span><br><span class="line">    _block1 <span class="operator">=</span> <span class="operator">^</span>&#123;</span><br><span class="line">        <span class="type">NSLog</span>(@<span class="string">&quot;This is block1-%d&quot;</span>,a);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.block2 <span class="operator">=</span> <span class="operator">^</span>&#123;</span><br><span class="line">        <span class="type">NSLog</span>(@<span class="string">&quot;This is block2-%d&quot;</span>,a);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//离开此作用域，block1就会被释放</span></span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;block1:%@、block2:%@&quot;</span>, [<span class="keyword">self</span>.block1 <span class="keyword">class</span>],[<span class="keyword">self</span>.block2 <span class="keyword">class</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@end</span></span><br></pre></td></tr></table></figure>
<p>打印结果及分析如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">block1:__NSStackBlock__<span class="operator">、</span>block2:__NSMallocBlock__</span><br><span class="line"><span class="type">This</span> <span class="keyword">is</span> block1<span class="operator">-</span><span class="number">10</span></span><br><span class="line"><span class="type">This</span> <span class="keyword">is</span> block2<span class="operator">-</span><span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>由于<code>block1</code>采用的是直接赋值的方式，没有调用<code>setter</code>方法，所以<code>block1</code>并没有被拷贝到堆上，是一个栈上的<code>Block</code>，这样也就直接导致了第二次打印<code>block1</code>时所发生的野指针崩溃；</p>
<h5 id="2-ARC下的Block拷贝"><a href="#2-ARC下的Block拷贝" class="headerlink" title="2.ARC下的Block拷贝"></a>2.ARC下的Block拷贝</h5><p>在<code>ARC</code>环境下，编译器会根据情况自动将栈上的<code>Block</code>复制到堆上，总结有以下几种情况:</p>
<ul>
<li><code>Block</code>作为函数返回值时；这就类似于<code>MRC</code>中对返回值<code>Block</code>执行了<code>[[returnedBlock copy] autorelease]</code>;</li>
<li><code>Block</code>被强引用，如<code>Block</code>被赋值给<code>__strong</code>或者<code>id</code>类型；</li>
<li><code>Block</code>作为<code>GCD API</code>的方法参数时；</li>
<li><code>Block</code>作为系统方法名含有<code>usingBlock</code>的方法参数时;</li>
</ul>
<p>下面的代码演示了这些情况：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">typedef void(<span class="operator">^</span><span class="type">Block</span>)(void);</span><br><span class="line"><span class="operator">-</span>(<span class="type">Block</span>)getBlock&#123;</span><br><span class="line">    <span class="comment">//ARC下的Block中访问了auto变量，此时block类型应为__NSStackBlock__</span></span><br><span class="line">   int a <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">   <span class="keyword">return</span>  <span class="operator">^</span>&#123;</span><br><span class="line">        <span class="type">NSLog</span>(@<span class="string">&quot;---------%d&quot;</span>, a);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> (void)testBlock9 &#123;</span><br><span class="line">    <span class="comment">//1.测试block作为函数返回值时</span></span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;bock1-：%@&quot;</span>,[[<span class="keyword">self</span> getBlock] <span class="keyword">class</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.测试将block赋值给__strong指针时</span></span><br><span class="line">    int a <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.1.block内没有访问auto变量</span></span><br><span class="line">    <span class="type">Block</span> block21 <span class="operator">=</span> <span class="operator">^</span>&#123;</span><br><span class="line">        <span class="type">NSLog</span>(@<span class="string">&quot;block21&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;block21-%@&quot;</span>,[block21 <span class="keyword">class</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.2.block内访问了auto变量，但没有赋值给__strong指针</span></span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;block22-%@&quot;</span>,[<span class="operator">^</span>&#123;</span><br><span class="line">        <span class="type">NSLog</span>(@<span class="string">&quot;block22-%d&quot;</span>, a);</span><br><span class="line">    &#125; <span class="keyword">class</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.3.block赋值给__strong指针</span></span><br><span class="line">    <span class="type">Block</span> block23 <span class="operator">=</span> <span class="operator">^</span>&#123;</span><br><span class="line">        <span class="type">NSLog</span>(@<span class="string">&quot;block23&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;block23-%@&quot;</span>,[block23 <span class="keyword">class</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.block作为Cocoa API中方法名含有usingBlock的方法参数时</span></span><br><span class="line">    <span class="type">NSArray</span> <span class="operator">*</span>array <span class="operator">=</span> @[@<span class="string">&quot;1&quot;</span>,@<span class="string">&quot;2&quot;</span>,@<span class="string">&quot;3&quot;</span>];</span><br><span class="line">    [array enumerateObjectsUsingBlock:<span class="operator">^</span>(id  _Nonnull obj, <span class="type">NSUInteger</span> idx, <span class="type">BOOL</span> <span class="operator">*</span> _Nonnull stop) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//4.block作为GCD API的方法参数时</span></span><br><span class="line">    <span class="comment">//Block中的延时操作完成时，系统将会对Block进行释放</span></span><br><span class="line">    dispatch_after(dispatch_time(<span class="type">DISPATCH_TIME_NOW</span>, (int64_t)(<span class="number">2.0</span> <span class="operator">*</span> <span class="type">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), <span class="operator">^</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印结果如下:</span></span><br><span class="line"><span class="comment">//bock1-：__NSMallocBlock__</span></span><br><span class="line"><span class="comment">//block21-__NSGlobalBlock__</span></span><br><span class="line"><span class="comment">//block22-__NSStackBlock__</span></span><br><span class="line"><span class="comment">//block23-__NSGlobalBlock__</span></span><br></pre></td></tr></table></figure>

<h5 id="3-其他存储域Block的拷贝"><a href="#3-其他存储域Block的拷贝" class="headerlink" title="3.其他存储域Block的拷贝"></a>3.其他存储域Block的拷贝</h5><p>上面讲述的重点都于对栈<code>Blok</code>的拷贝，若是对于已经配置在堆上或者配置在静态区的上的<code>Block</code>调用<code>copy</code>方法又将如何呢？下面是不同存储域的<code>Block</code>执行<code>copy</code>进行的总结：</p>
<table>
<thead>
<tr>
<th><code>Block</code>类型</th>
<th>副本源的配置存储域</th>
<th>复制效果</th>
</tr>
</thead>
<tbody><tr>
<td><code>_NSConcreteStackBlock</code></td>
<td>栈区</td>
<td>从栈复制到堆</td>
</tr>
<tr>
<td><code>_NSConcreteGlobalBlock</code></td>
<td>静态区</td>
<td>什么也不做</td>
</tr>
<tr>
<td><code>_NSConcreteMallocBlock</code></td>
<td>堆区</td>
<td>引用增加</td>
</tr>
</tbody></table>
<h5 id="4-总结Block需要拷贝的原理"><a href="#4-总结Block需要拷贝的原理" class="headerlink" title="4. 总结Block需要拷贝的原理"></a>4. 总结Block需要拷贝的原理</h5><p><code>Block</code>默认创建于其所在函数的函数栈上，所以当函数作用域结束时就会随之销毁；</p>
<p>在<code>MRC</code>环境下，没有编译器的优化，所以我们非常强调要使用<code>copy</code>将<code>Block</code>拷贝到堆上，从而避免<code>Block</code>在其作用域结束时被直接释放;</p>
<p>在<code>ARC</code>环境下，编译器会根据情况自动将栈上的<code>Block</code>复制到堆上，对于<code>Block</code>使用<code>copy</code>还是<code>strong</code>效果是一样的，所以写不写<code>copy</code>都行。在<code>ARC</code>环境下对于<code>Block</code>依然使用<code>copy</code>，更像是从<code>MRC</code>遗留下来的“传统”，时刻提醒我们：编译器自动对<code>Block</code>进行了拷贝操作。如果不写<code>copy</code> ，该类的调用者有可能会忘记或者根本不知道“编译器会自动对<code>Block</code>进行了拷贝操作”，他们有可能会在调用之前自行拷贝属性值，这种操作多余而低效。</p>
<p>最后，总结<code>Block</code>修饰符的使用：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MRC下block属性的建议写法：</span></span><br><span class="line"><span class="meta">@property</span> (copy, nonatomic) void (<span class="operator">^</span>block)(void);</span><br><span class="line"></span><br><span class="line"><span class="comment">//ARC下block属性的建议写法：</span></span><br><span class="line"><span class="meta">@property</span> (strong, nonatomic) void (<span class="operator">^</span>block)(void);</span><br><span class="line"><span class="meta">@property</span> (copy, nonatomic) void (<span class="operator">^</span>block)(void);</span><br></pre></td></tr></table></figure>



<h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><ol>
<li><a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Blocks/Articles/00_Introduction.html#//apple_ref/doc/uid/TP40007502-CH1-SW1">苹果官方Block文档</a></li>
<li><a target="_blank" rel="noopener" href="https://halfrost.com/ios_block/#blockcopydispose">深入研究 Block 捕获外部变量和 __block 实现原理</a></li>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000009470922">Block 到底啥时候会崩溃</a></li>
<li><a target="_blank" rel="noopener" href="https://www.aopod.com/2016/11/16/block-empty-checking/">为何调用block应先判空</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5b0181e15188254270643e88#heading-27">iOS底层原理总结 - 探寻block的本质(一)</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/entry/5a73d832f265da4e9311502d">在block内如何修改block外部变量引发的思考</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/majianfei1023/article/details/46629065">二级指针的作用详解</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/da96ec752aee">iOS Block底层探索</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/1f22891f2e8f">iOS底层-Block底层原理</a></li>
<li><a target="_blank" rel="noopener" href="https://opensource.apple.com/source/libclosure/">苹果开源代码-libClosure</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/11c90d6d9f02">漫谈Block(理解Block_layout)</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wuyubeichen.github.io/2019/03/03/iOS%E5%BC%80%E5%8F%91-ReactiveCocoa%E5%9F%BA%E7%A1%80%E7%AF%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Author">
      <meta itemprop="description" content="iOS Developer, Beijing China">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="梧雨北辰的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/03/03/iOS%E5%BC%80%E5%8F%91-ReactiveCocoa%E5%9F%BA%E7%A1%80%E7%AF%87/" class="post-title-link" itemprop="url">iOS开发-ReactiveCocoa基础篇</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-03-03 14:58:39" itemprop="dateCreated datePublished" datetime="2019-03-03T14:58:39+08:00">2019-03-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-29 09:39:32" itemprop="dateModified" datetime="2022-08-29T09:39:32+08:00">2022-08-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">iOS开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><code>ReactiveCocoa</code>(简称<code>RAC</code>)，<code>Reactive</code>表示响应式，<code>Cocoa</code>是苹果整个框架的简称，许多苹果框架都以<code>Cocoa</code>结尾。所以<code>RAC</code>是<code>Github</code>上为我们提供函数响应式编程方法的<code>iOS</code>开发框架。</p>
<p><strong>主要内容：</strong></p>
<ol>
<li>了解函数响应式编程</li>
<li>ReactiveCocoa简介</li>
<li>ReactiveCocoa集成</li>
<li>理解什么是信号</li>
<li>从源码理解RAC的信号机制</li>
<li>本篇总结</li>
</ol>
<h1 id="一、了解函数响应式编程"><a href="#一、了解函数响应式编程" class="headerlink" title="一、了解函数响应式编程"></a>一、了解函数响应式编程</h1><p><img src="https://upload-images.jianshu.io/upload_images/1244124-613e9c9d4106f91b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p><strong>函数式编程(Funcational Programming)</strong><br>使用高阶函数编程，即函数可采用多种函数作为它们的参数和返回值。</p>
<p><strong>响应式编程(Reactive Programming)</strong><br>一种面向数据流和变化传播的编程范式</p>
<p><strong>函数响应式编程(Funcational Reacitve Programming)</strong><br>简称FRP，ReactiveCocoa就是一个典型的FRP框架，响应式的编程思想，函数式的代码形式。</p>
<h1 id="二、ReactiveCocoa简介"><a href="#二、ReactiveCocoa简介" class="headerlink" title="二、ReactiveCocoa简介"></a>二、ReactiveCocoa简介</h1><p>iOS开发中，我们需要使用按钮点击、代理、通知等这些方法来处理响应事件。而RAC框架使用Category为很多基本的UIKit控件添加信号Signal，这样我们可以通过信号来监听数据流与变化传播，把将监听的代码与处理代码放在一起，从而方便我们管理。利用此特点结合MVVM架构，RAC也有十分显著的作用。</p>
<h1 id="三、ReactiveCocoa集成"><a href="#三、ReactiveCocoa集成" class="headerlink" title="三、ReactiveCocoa集成"></a>三、ReactiveCocoa集成</h1><p>RAC.5.0相对于之前版本对于自身项目结构进行了较大调整，被拆分ReactiveCocoa、ReactiveSwift、ReactiveObjC、ReactiveObjCBridge四个库，我们需要根据不同的情况来集成。<br><a target="_blank" rel="noopener" href="https://github.com/ReactiveCocoa/ReactiveCocoa">GitHub地址：https://github.com/ReactiveCocoa/ReactiveCocoa</a><br>通常，我们都使用Cocoapods集成RAC，**需要注意的是Podfile文件中必须使用user_framework!**，然后，针对于不同的代码环境，有三种集成情况：</p>
<h2 id="1-纯OC工程"><a href="#1-纯OC工程" class="headerlink" title="1.纯OC工程"></a>1.纯OC工程</h2><p>ReactiveObjc库包含原RAC2的全部代码，在纯OC工程中使用</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">platform :ios, <span class="string">&#x27;8.0&#x27;</span></span><br><span class="line">use_frameworks!     #必须添加</span><br><span class="line">target <span class="string">&#x27;ZSTest&#x27;</span> <span class="keyword">do</span>  #工程名</span><br><span class="line"><span class="meta">#pod &#x27;ReactiveObjC&#x27; #默认导入最新的RAC版本         </span></span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h2 id="2-纯Swift工程"><a href="#2-纯Swift工程" class="headerlink" title="2.纯Swift工程"></a>2.纯Swift工程</h2><p>纯Swfit工程继续使用ReactiveCocoa，但RAC依赖ReactiveSwift，所以相当于引入两个库。<br>集成方法同上，只不过将ReactiveObjc换成ReactiveCocoa。</p>
<h2 id="3-OC与Swift混编工程"><a href="#3-OC与Swift混编工程" class="headerlink" title="3.OC与Swift混编工程"></a>3.OC与Swift混编工程</h2><p>混编工程需要同时引入ReactiveCocoa与ReactiveObjCBridge，但是ReactiveObjCBridge库依赖于ReactiveObjc库，所以相当于同时引入四个库了。示例如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">platform :ios, <span class="string">&#x27;8.0&#x27;</span></span><br><span class="line">use_frameworks!     #必须添加</span><br><span class="line">target <span class="string">&#x27;ZSTest&#x27;</span> <span class="keyword">do</span>  #工程名</span><br><span class="line">pod <span class="string">&#x27;ReactiveCocoa&#x27;</span></span><br><span class="line">pod <span class="string">&#x27;ReactiveObjC&#x27;</span>  </span><br><span class="line">pod <span class="string">&#x27;ReactiveObjCBridge&#x27;</span></span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h1 id="四、ReactiveCocoa信号理解"><a href="#四、ReactiveCocoa信号理解" class="headerlink" title="四、ReactiveCocoa信号理解"></a>四、ReactiveCocoa信号理解</h1><p>我觉得学习RAC的第一个关口就是理解信号RACSignal了，什么是信号也许是困惑我们的第一个问题。</p>
<p>作为RAC中最为核心的一个类，<strong>信号可以理解为传递数据变化信息的工具</strong>，信号会在数据发生变化时发送事件流给它的订阅者，然后订阅者执行响应方法。信号本身不具备发送信号的能力，而是交给一个订阅者去发出。</p>
<p>首先上一段代码，演示信号的一个基本使用。<br>测试场景：我们要对一个用于输入用户名的UITextFiled进行检测，每次输入内容变化的时候都打出输入框的内容，使用RAC来实现此操作的关键代码如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span>.userNameTxtField.rac_textSignal subscribeNext:^(<span class="built_in">NSString</span> * _Nullable x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;测试：%@&quot;</span>,x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">控制台打印：</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">17</span>:<span class="number">57</span>:<span class="number">00.497956</span>+<span class="number">0800</span> ZSTest[<span class="number">4351</span>:<span class="number">263810</span>] 测试：<span class="number">1</span></span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">17</span>:<span class="number">57</span>:<span class="number">00.498237</span>+<span class="number">0800</span> ZSTest[<span class="number">4351</span>:<span class="number">263810</span>] 测试：<span class="number">12</span></span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">17</span>:<span class="number">57</span>:<span class="number">00.498375</span>+<span class="number">0800</span> ZSTest[<span class="number">4351</span>:<span class="number">263810</span>] 测试：<span class="number">123</span></span><br></pre></td></tr></table></figure>

<p>没错的，不使用代理方法，也没有action的响应处理，我们仅仅使用了一行方法就实现了对文本框输入内容的实时打印。由此，RAC的实用性可见一斑。</p>
<h1 id="五、ReactiveCocoa信号机制"><a href="#五、ReactiveCocoa信号机制" class="headerlink" title="五、ReactiveCocoa信号机制"></a>五、ReactiveCocoa信号机制</h1><p>我们会对上面的代码产生疑问，RAC是怎么做到上述代码功能的呢？而且我们常说的订阅者又在哪里呢？</p>
<p>其实RAC已经使用Category的形式为我们基本的UI控件创建了信号(<strong>如上例中的rac_textSignal</strong>)，所以这里我们才可以很方便的实现信号订阅，而且订阅者在整个过程中也是对于我们隐藏的。 现在我们使用自定义信号的方法，从创建信号到订阅信号细致的了解一下这个过程。首先上一段创建信号的测试代码如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建信号</span></span><br><span class="line">RACSignal *testSignal = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="type">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    <span class="comment">//1.订阅者发送信号内容</span></span><br><span class="line">    [subscriber sendNext:<span class="string">@&quot;发送信号内容&quot;</span>];</span><br><span class="line">    <span class="comment">//2.订阅者发送信号完成的信息，不需要再发送数据时，最好发送信号完成，可以内部调起清理信号的操作。</span></span><br><span class="line">    [subscriber sendCompleted];</span><br><span class="line">    <span class="comment">//3.创建信号的Block参数，需要返回一个RACDisposable对象 ，可以返回nil。</span></span><br><span class="line">    <span class="comment">//RACDisposable对象用于取消订阅信号，此block在信号完成或者错误时调用。</span></span><br><span class="line">    RACDisposable *racDisposable = [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">       <span class="built_in">NSLog</span>(<span class="string">@&quot;信号Error或者Complete时销毁&quot;</span>);</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="keyword">return</span> racDisposable;</span><br><span class="line">&#125;];</span><br><span class="line">    </span><br><span class="line"><span class="comment">//订阅信号</span></span><br><span class="line">[testSignal subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="comment">//新变化的值</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;订阅信号：subscribeNext:%@&quot;</span>,x);</span><br><span class="line">&#125; error:^(<span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">    <span class="comment">//信号错误，被取消订阅,被移除观察</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;订阅信号：Error:%@&quot;</span>,error.description);</span><br><span class="line">&#125; completed:^&#123;</span><br><span class="line">    <span class="comment">//信号已经完成，被取消订阅，被移除观察</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;订阅信号：subscribeComplete&quot;</span>);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">控制台打印:</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">17</span>:<span class="number">57</span>:<span class="number">00.497956</span>+<span class="number">0800</span> ZSTest[<span class="number">4351</span>:<span class="number">263810</span>] 订阅信号：subscribeNext:发送信号内容</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">17</span>:<span class="number">57</span>:<span class="number">00.498237</span>+<span class="number">0800</span> ZSTest[<span class="number">4351</span>:<span class="number">263810</span>] 订阅信号：subscribeComplete</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">17</span>:<span class="number">57</span>:<span class="number">00.498375</span>+<span class="number">0800</span> ZSTest[<span class="number">4351</span>:<span class="number">263810</span>] 信号Error或者Complete时销毁</span><br></pre></td></tr></table></figure>

<p>我们通过观察源码来理解整个过程:</p>
<h2 id="1-创建信号"><a href="#1-创建信号" class="headerlink" title="1.创建信号"></a>1.创建信号</h2><p>创建信号，我们需要使用RACSignal的类方法createSignal。该方法需要一个Block作为参数。查看源码，我们就会发现RACSignal最终是通过调用自己子类RACDynamicSignal的createSignal方法，将这个Block设置给了自己的didSubscribe属性的。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RACSignal.m文件</span></span><br><span class="line">+ (RACSignal *)createSignal:(RACDisposable * (^)(<span class="type">id</span>&lt;RACSubscriber&gt; subscriber))didSubscribe &#123;</span><br><span class="line"> 	<span class="keyword">return</span> [RACDynamicSignal createSignal:didSubscribe];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RACDynamicSignal.h文件</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RACDynamicSignal</span> ()</span></span><br><span class="line"><span class="comment">// The block to invoke for each subscriber.</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readonly</span>) RACDisposable * (^didSubscribe)(<span class="type">id</span>&lt;RACSubscriber&gt; subscriber);</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RACDynamicSignal.m文件</span></span><br><span class="line">+ (RACSignal *)createSignal:(RACDisposable * (^)(<span class="type">id</span>&lt;RACSubscriber&gt; subscriber))didSubscribe &#123;</span><br><span class="line"> 	RACDynamicSignal *signal = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line"> 	signal-&gt;_didSubscribe = [didSubscribe <span class="keyword">copy</span>];</span><br><span class="line"> 	<span class="keyword">return</span> [signal setNameWithFormat:<span class="string">@&quot;+createSignal:&quot;</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>didSubscribe</strong>：这是创建信号时候需要传入的一个block，它的传入参数是订阅者subscriber，而返回值是需要是一个RACDisposable对象。创建信号后的didSubscrib是一个等待执行的block。</p>
<p><strong>RACSubscriber</strong>：表示订阅者，创建信号时订阅者发送信号，这里的订阅者是一个协议而非一个类。信号需要订阅者帮助其发送数据。查看RACSubscriber的协议，我可以看到以下几个方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发送信息</span></span><br><span class="line">- (<span class="type">void</span>)sendNext:(<span class="keyword">nullable</span> <span class="type">id</span>)value;</span><br><span class="line"><span class="comment">//发送错误消息</span></span><br><span class="line">- (<span class="type">void</span>)sendError:(<span class="keyword">nullable</span> <span class="built_in">NSError</span> *)error;</span><br><span class="line"><span class="comment">//发送完成信息</span></span><br><span class="line">- (<span class="type">void</span>)sendCompleted;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">- (<span class="type">void</span>)didSubscribeWithDisposable:(RACCompoundDisposable *)disposable;</span><br></pre></td></tr></table></figure>

<p>在创建一个信号的时候，订阅者使用sendNext发送信息。而且如果我们不再发送数据，最好在这里执行一次sendCompleted方法，这样的话，信号内部会自动调用对应的方法取消信号订阅。</p>
<p><strong>RACDisposable</strong>：这个类用于取消订阅信号和清理资源，在信号出现错误或者信号完成的时候，信号会自动调起RACDisposable对象的block方法。在代码中我们也可以看到，创建RACDisposable对象是使用disposableWithBlock方法设置了一个block操作，执行block操作之后，信号就不再被订阅了。</p>
<p><strong>总结：创建信号就是使用createSignal方法，创建一个信号，并为信号设置了一个didSubscribe属性(也就是一系列订阅者需要做的操作)。</strong></p>
<h2 id="2-订阅信号"><a href="#2-订阅信号" class="headerlink" title="2.订阅信号"></a>2.订阅信号</h2><p>进入订阅信号的源码我们看到如下代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (RACDisposable *)subscribeNext:(<span class="type">void</span> (^)(<span class="type">id</span> x))nextBlock error:(<span class="type">void</span> (^)(<span class="built_in">NSError</span> *error))errorBlock completed:(<span class="type">void</span> (^)(<span class="type">void</span>))completedBlock &#123;</span><br><span class="line"> 	<span class="built_in">NSCParameterAssert</span>(nextBlock != <span class="literal">NULL</span>);</span><br><span class="line"> 	<span class="built_in">NSCParameterAssert</span>(errorBlock != <span class="literal">NULL</span>);</span><br><span class="line"> 	<span class="built_in">NSCParameterAssert</span>(completedBlock != <span class="literal">NULL</span>);</span><br><span class="line"> 	</span><br><span class="line"> 	RACSubscriber *o = [RACSubscriber subscriberWithNext:nextBlock error:errorBlock completed:completedBlock];</span><br><span class="line"> 	<span class="keyword">return</span> [<span class="keyword">self</span> subscribe:o];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此方法中，我们可以看到订阅信号有两个过程：<br><strong>过程1：使用subscribeNext的方法参数，创建出一个订阅者subscriber。</strong><br><strong>过程2：信号对象执行了订阅操作subscribe，方法中传入参数是刚创建的订阅者。</strong></p>
<p><strong>注：这也就解释了我们常提起却看不见的订阅者存在哪里的问题。真实开发中我们只关心订阅者需要发送的值就行了，而不需要关心其内部订阅的过程。</strong></p>
<p>继续打开信号的subscribe方法，看到源码如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (RACDisposable *)subscribe:(<span class="type">id</span>&lt;RACSubscriber&gt;)subscriber &#123;</span><br><span class="line"> 	<span class="built_in">NSCParameterAssert</span>(subscriber != <span class="literal">nil</span>);</span><br><span class="line"> 	RACCompoundDisposable *disposable = [RACCompoundDisposable compoundDisposable];</span><br><span class="line"> 	subscriber = [[RACPassthroughSubscriber alloc] initWithSubscriber:subscriber signal:<span class="keyword">self</span> disposable:disposable];</span><br><span class="line"> 	<span class="keyword">if</span> (<span class="keyword">self</span>.didSubscribe != <span class="literal">NULL</span>) &#123;</span><br><span class="line"> 		RACDisposable *schedulingDisposable = [RACScheduler.subscriptionScheduler schedule:^&#123;</span><br><span class="line"> 			RACDisposable *innerDisposable = <span class="keyword">self</span>.didSubscribe(subscriber);</span><br><span class="line"> 			[disposable addDisposable:innerDisposable];</span><br><span class="line"> 		&#125;];</span><br><span class="line"> 		[disposable addDisposable:schedulingDisposable];</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="keyword">return</span> disposable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码中我们不难看出：<strong>除了对于订阅者和清理对象的再次封装外，最重要的就是创建信号时为信号设置Block(didSubscribe)被调用了，而且Block参数使用了我们创建的订阅者。</strong></p>
<h1 id="六、本篇总结"><a href="#六、本篇总结" class="headerlink" title="六、本篇总结"></a>六、本篇总结</h1><p>1.自创建信号会传入一个Block(didSubscribe)，Block中遵循协议的订阅者会调用sendNext方法发送消息。而在订阅信号subscribeNext时，会在内部创建一个订阅者，并将其传递给原先赋值的didSubscribe，并执行这个Block。</p>
<p>2.<strong>但是我们应该注意</strong>：上述的分析只是其中信号机制的一种情况罢了。RAC对于UI组件信号的封装可能有所不同，比如之前我们看到的输入框信号，执行订阅信号subscribeNext时并不立即执行打印，而是监听到输入时打印。这其实是该信号使用了concat又做了一系列的操作。<strong>对于不同的信号我们只需要理解上述分析中提到几个关键属性，就可以结合源码很好的理解信号机制的使用了。</strong></p>
<p>本篇的重点在于对RAC的基本介绍，是为了更好的理解信号机制，这仅相当于打开一个切入口来认识RAC。关于RAC的详细用法可以参考下一篇：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/16b4b9d74b7c">ReactiveCocoa函数响应式编程-应用篇</a>，这里将总结RAC关于信号的各种用法。</p>
<p>其他参考链接：<br>1.<a target="_blank" rel="noopener" href="http://www.cocoachina.com/ios/20150123/10994.html">ReactiveCocoa入门教程：第一部分</a><br>2.<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/87ef6720a096">最快让你上手ReactiveCocoa之基础篇</a><br>3.<a target="_blank" rel="noopener" href="http://ios.jobbole.com/82356/">这样好用的ReactiveCocoa,根本停不下来</a><br>4.<a target="_blank" rel="noopener" href="https://www.cnblogs.com/zhenw/p/6160931.html">函数式编程与面向对象的比较</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wuyubeichen.github.io/2019/03/02/iOS%E5%BC%80%E5%8F%91-ReactiveCocoa%E5%BA%94%E7%94%A8%E7%AF%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Author">
      <meta itemprop="description" content="iOS Developer, Beijing China">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="梧雨北辰的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/03/02/iOS%E5%BC%80%E5%8F%91-ReactiveCocoa%E5%BA%94%E7%94%A8%E7%AF%87/" class="post-title-link" itemprop="url">iOS开发-ReactiveCocoa应用篇</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-03-02 14:58:39" itemprop="dateCreated datePublished" datetime="2019-03-02T14:58:39+08:00">2019-03-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-29 09:39:32" itemprop="dateModified" datetime="2022-08-29T09:39:32+08:00">2022-08-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">iOS开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>使用RAC其实就是一个创建信号订阅信号的过程。上篇<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/ba90d649ecb8">ReactiveCocoa函数响应式编程-基础篇</a>，主要简单介绍了RAC的信号机制，本篇则以信号为核心，就信号常用的类、操作信号的方法，替换响应处理等方面总结RAC的使用。</p>
<p><strong>主要内容</strong></p>
<ol>
<li>RAC中常用的类</li>
<li>RAC中常用的宏</li>
<li>RAC中信号的常用操作</li>
<li>RAC常用的处理事件响应的方法本篇总结</li>
</ol>
<p><strong>本篇还提供了关于RAC使用的两个测试工程，结合代码学习更加直观</strong>：<br><a target="_blank" rel="noopener" href="https://github.com/DreamcoffeeZS/ReactiveCocoaDemo">项目1</a>：<br>1.测试RAC对信号的各类操作。<br>2.使用RAC改进一个普通的登录界面。<br><a target="_blank" rel="noopener" href="https://github.com/DreamcoffeeZS/MVVMReactiveCocoa">项目2</a>：<br>MVVM架构结合RAC响应式编程的开发示例。实现登录界面和的分页数据界面。效果图如下：<br><img src="https://upload-images.jianshu.io/upload_images/1244124-34473c827d2898b5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="RAC&amp;&amp;MVVM实现一个登录界面和一个分页数据表视图界面"></p>
<h1 id="一、RAC中常用的类"><a href="#一、RAC中常用的类" class="headerlink" title="一、RAC中常用的类"></a>一、RAC中常用的类</h1><h2 id="1-RACSubject"><a href="#1-RACSubject" class="headerlink" title="1.RACSubject"></a>1.RACSubject</h2><p>RACSubject是信号RACSignal的一个子类，但它的底部实现与RACSignal有所不同。其订阅信号subscribeNext的方法只是使用nextBlock创建了一个订阅者并保存起来待用，多次调用subscribeNext会保存多个订阅者。<strong>只有发送信号sendNext方法执行时，订阅者才会执行nextBlock里的内容，多个订阅者会执行多次</strong>。<br>使用示例：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建信号</span></span><br><span class="line"><span class="comment">//创建RACSubject不需要block参数</span></span><br><span class="line">RACSubject *subject = [RACSubject subject];</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.订阅信号</span></span><br><span class="line"><span class="comment">//这里信号被订阅两次，那么订阅者也创建了两次，保存在RACSubject的subscribers属性数组中。</span></span><br><span class="line"><span class="comment">//那么每当信号有新值发出的时候，每个订阅者都会执行。    </span></span><br><span class="line">[subject subscribeNext:^(<span class="type">id</span> x) &#123;</span><br><span class="line">    <span class="comment">//block在信号发出新值时调用</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;第一个订阅者:%@&quot;</span>,x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[subject subscribeNext:^(<span class="type">id</span> x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;第二个订阅者:%@&quot;</span>,x);</span><br><span class="line">&#125;];</span><br><span class="line">    </span><br><span class="line"><span class="comment">//3.发送信号</span></span><br><span class="line">[subject sendNext:<span class="string">@&quot;6”];</span></span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">控制台打印：</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-24</span> <span class="number">13</span>:<span class="number">07</span>:<span class="number">51.425569</span>+<span class="number">0800</span> ZSTest[<span class="number">2840</span>:<span class="number">124915</span>] 第一个订阅者:<span class="number">6</span></span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-24</span> <span class="number">13</span>:<span class="number">07</span>:<span class="number">51.426113</span>+<span class="number">0800</span> ZSTest[<span class="number">2840</span>:<span class="number">124915</span>] 第二个订阅者:<span class="number">6</span></span><br></pre></td></tr></table></figure>

<p>应用示例：<strong>替换代理</strong><br>我们测试这样一个功能：在当前视图控制器A中点击按钮调转到下一视图控制器B，在B的文本框中输入内容，点击编辑完成按钮回到A，显示B中输入的内容到A的UILabel上。通常我们使用代理来解决这样的问题，那么现在我们可以利用RACSubject的特性来代替常用的代理的功能，其实就跟我们使用block回调一样。具体代码如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.下一视图控制中添加RACSubject属性。</span></span><br><span class="line"><span class="comment">//SecondViewController.h文件</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SecondViewController</span> : <span class="title">BaseViewController</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) RACSubject *racSubject;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2.点击编辑完成按钮时，检查代理信号并发送消息，这里传递出一个字典(包含输入的文字)</span></span><br><span class="line"><span class="comment">//SecondViewController.m文件</span></span><br><span class="line">- (<span class="keyword">IBAction</span>)completeBtnClick:(<span class="type">id</span>)sender &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">self</span>.racSubject)&#123;</span><br><span class="line">        [<span class="keyword">self</span>.racSubject sendNext:@&#123;<span class="string">@&quot;text&quot;</span>:<span class="keyword">self</span>.txtField.text&#125;];</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span>.navigationController popViewControllerAnimated:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3.当前视图控制器A的跳转按钮响应方法中，创建secondVC，并为其添加信号属性和订阅信号。</span></span><br><span class="line"><span class="comment">//TestViewCotroller.m文件</span></span><br><span class="line">- (<span class="keyword">IBAction</span>)testBtnClick:(<span class="type">id</span>)sender &#123;</span><br><span class="line">    SecondViewController *secondVC = [[SecondViewController alloc] initWithNibName:<span class="string">@&quot;SecondViewController&quot;</span> bundle:<span class="literal">nil</span>];</span><br><span class="line">   <span class="comment">//为secondVC设置RACSubject属性，并订阅信号</span></span><br><span class="line">    secondVC.racSubject = [RACSubject subject];</span><br><span class="line">    __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line">    <span class="comment">//定阅信号的block会更新文字的显示</span></span><br><span class="line">    [secondVC.racSubject subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">        <span class="built_in">NSDictionary</span> *infoDic =(<span class="built_in">NSDictionary</span> *)x;</span><br><span class="line">        weakSelf.showLabel.text =  infoDic[<span class="string">@&quot;text&quot;</span>];</span><br><span class="line">    &#125;];</span><br><span class="line">    [<span class="keyword">self</span>.navigationController pushViewController:secondVC animated:<span class="literal">YES</span>];</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<h2 id="2-RACTuple与RACSequence"><a href="#2-RACTuple与RACSequence" class="headerlink" title="2.RACTuple与RACSequence"></a>2.RACTuple与RACSequence</h2><p><strong>RACTuple</strong>：类似OC的数组，是RAC中用来封装值的元组类，可以配合RACTupleUnpack解元组。<br><strong>RACSequeue</strong>：数组和字典经过rac_sequence方法会被转化为RACSequeue类型，并进一步转为我们常用的信号。订阅此类信号的时候，信号就会被激活并遍历其中的所有值。</p>
<p>使用示例：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历数组</span></span><br><span class="line"><span class="built_in">NSArray</span> *characters = @[<span class="string">@&quot;A&quot;</span>,<span class="string">@&quot;C&quot;</span>,<span class="string">@&quot;B&quot;</span>,<span class="string">@&quot;E&quot;</span>,<span class="string">@&quot;D&quot;</span>];</span><br><span class="line">    [characters.rac_sequence.signal subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;char:%@&quot;</span>,x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">控制台打印：</span><br><span class="line"><span class="type">char</span>:A</span><br><span class="line"><span class="type">char</span>:C</span><br><span class="line"><span class="type">char</span>:B</span><br><span class="line"><span class="type">char</span>:E</span><br><span class="line"><span class="type">char</span>:D</span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历字典</span></span><br><span class="line"><span class="built_in">NSDictionary</span> *myInfoDic = @&#123;<span class="string">@&quot;name&quot;</span>:<span class="string">@&quot;zs&quot;</span>,<span class="string">@&quot;nickname&quot;</span>:<span class="string">@&quot;FengZi&quot;</span>,<span class="string">@&quot;age&quot;</span>:<span class="string">@&quot;18&quot;</span>&#125;;\</span><br><span class="line">[myInfoDic.rac_sequence.signal subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="comment">//解元组，注意一一对应</span></span><br><span class="line">    RACTupleUnpack(<span class="built_in">NSString</span> *key,<span class="built_in">NSString</span> *value) = x;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;myInfoDic:%@-%@&quot;</span>,key,value);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">控制台打印：</span><br><span class="line">myInfoDic:name-zs</span><br><span class="line">myInfoDic:nickname-FengZi</span><br><span class="line">myInfoDic:age<span class="number">-18</span></span><br></pre></td></tr></table></figure>



<h2 id="3-RACMulticastConnection"><a href="#3-RACMulticastConnection" class="headerlink" title="3.RACMulticastConnection"></a>3.RACMulticastConnection</h2><p>RACMulticastConnection用于解决一个信号被多次订阅后，创建信号中的block被重复调用的问题，所以在实际开发中，使用RACMulticastConnection可以解决网络重复请求的问题。<br>测试1:普通的信号</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signalA = [RACSignal createSignal:^RACDisposable *(<span class="type">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@&quot;发送信号A&quot;</span>);</span><br><span class="line">   [subscriber sendNext:<span class="string">@&quot;发送信号A&quot;</span>];</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[signalA subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@&quot;第一次订阅：%@&quot;</span>,x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"> [signalA subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@&quot;第二次订阅：%@&quot;</span>,x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">控制台打印：</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-28</span> <span class="number">10</span>:<span class="number">02</span>:<span class="number">00.702607</span>+<span class="number">0800</span> ZSTest[<span class="number">2446</span>:<span class="number">48444</span>] 发送信号A</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-28</span> <span class="number">10</span>:<span class="number">02</span>:<span class="number">00.702856</span>+<span class="number">0800</span> ZSTest[<span class="number">2446</span>:<span class="number">48444</span>] 第一次订阅：发送信号A</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-28</span> <span class="number">10</span>:<span class="number">02</span>:<span class="number">00.703069</span>+<span class="number">0800</span> ZSTest[<span class="number">2446</span>:<span class="number">48444</span>] 发送信号A</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-28</span> <span class="number">10</span>:<span class="number">02</span>:<span class="number">00.703325</span>+<span class="number">0800</span> ZSTest[<span class="number">2446</span>:<span class="number">48444</span>] 第二次订阅：发送信号A</span><br></pre></td></tr></table></figure>

<p>测试2：使用RACMulticastConnection</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建信号</span></span><br><span class="line">RACSignal *signalB = [RACSignal createSignal:^RACDisposable *(<span class="type">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;发送信号B&quot;</span>);</span><br><span class="line">    [subscriber sendNext:<span class="string">@&quot;发送信号B&quot;</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line">    </span><br><span class="line"><span class="comment">//2.连接信号：publish或者muticast方法</span></span><br><span class="line"><span class="comment">//连接后的信号使用订阅方法时，并不能激活信号，而是将其订阅者保存到数组中。</span></span><br><span class="line"><span class="comment">//在连接对象执行connect方法时，信号中的订阅者会统一调用sendNext方法。</span></span><br><span class="line">RACMulticastConnection *signalBconnect = [signalB publish];</span><br><span class="line">    </span><br><span class="line"><span class="comment">//3.订阅信号</span></span><br><span class="line"><span class="comment">//使用signalBconnect而不再是signalB</span></span><br><span class="line">[signalBconnect.signal subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;第一次订阅：%@&quot;</span>,x);</span><br><span class="line">&#125;];</span><br><span class="line">[signalBconnect.signal subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;第二次订阅：%@&quot;</span>,x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.连接后激活信号</span></span><br><span class="line">[signalBconnect connect];</span><br><span class="line"></span><br><span class="line">控制台打印：</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-28</span> <span class="number">10</span>:<span class="number">02</span>:<span class="number">00.704209</span>+<span class="number">0800</span> ZSTest[<span class="number">2446</span>:<span class="number">48444</span>] 发送信号B</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-28</span> <span class="number">10</span>:<span class="number">02</span>:<span class="number">00.704368</span>+<span class="number">0800</span> ZSTest[<span class="number">2446</span>:<span class="number">48444</span>] 第一次订阅：发送信号B</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-28</span> <span class="number">10</span>:<span class="number">02</span>:<span class="number">00.704543</span>+<span class="number">0800</span> ZSTest[<span class="number">2446</span>:<span class="number">48444</span>] 第二次订阅：发送信号B</span><br></pre></td></tr></table></figure>

<h2 id="4-RACCommand：用于处理事件的类"><a href="#4-RACCommand：用于处理事件的类" class="headerlink" title="4.RACCommand：用于处理事件的类"></a>4.RACCommand：用于处理事件的类</h2><p>RACCommand可以把事件如何处理，如何传递都封装到类中，之后就可以方便的调起它的执行方法。在实际开发中，我们可以用它来封装一个网络操作。<br>注意：<br>1.创建方法中block返回一个信号，且不能为nil，但是可以使用[RACSignal empty]表示空信号<br>2.RACCommand必须被强引用，否则容易被释放</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建RACCommand：initWithSignalBlock</span></span><br><span class="line"><span class="keyword">self</span>.command = [[RACCommand alloc] initWithSignalBlock:^RACSignal * _Nonnull(<span class="type">id</span>  _Nullable input) &#123;</span><br><span class="line">    <span class="comment">//我们常在这里创建一个网络请求的信号，也就是封装一个请求数据的操作。</span></span><br><span class="line">    RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="type">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">        [subscriber sendNext:<span class="string">@&quot;网络请求的信号&quot;</span>];</span><br><span class="line">        <span class="comment">//数据传递完成，必须调用sendComplleted.,否则永远处于执行中。</span></span><br><span class="line">        [subscriber sendCompleted];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="keyword">return</span> signal;</span><br><span class="line">&#125;];</span><br><span class="line">    </span><br><span class="line"><span class="comment">//2.订阅RACCommand中的信号，要等到RACCommand执行后，才能收到消息</span></span><br><span class="line">[<span class="keyword">self</span>.command.executionSignals subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="comment">//这里是一个信号中信号</span></span><br><span class="line">    [x subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;收到信号：%@&quot;</span>,x);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">//改进订阅方法：switchToLatest可以直接获取信号中信号</span></span><br><span class="line">[<span class="keyword">self</span>.command.executionSignals.switchToLatest subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;改进-收到信号：%@&quot;</span>,x);</span><br><span class="line">&#125;];</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">//3.监听RACCommand命令是否执行完毕的信号</span></span><br><span class="line"><span class="comment">//默认会监测一次，所以可以使用skip表示跳过第一次信号。</span></span><br><span class="line"><span class="comment">//这里可以用于App网络请求时，控制加载提示视图的隐藏或者显示</span></span><br><span class="line">[[<span class="keyword">self</span>.command.executing skip:<span class="number">1</span>] subscribeNext:^(<span class="built_in">NSNumber</span> * _Nullable x) &#123;</span><br><span class="line">    <span class="keyword">if</span>([x boolValue] == <span class="literal">YES</span>)&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;RACCommand命令正在执行...&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;RACCommand命令不在执行中！！！&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br><span class="line">    </span><br><span class="line"><span class="comment">//4.执行RACComand</span></span><br><span class="line"><span class="comment">//方法：- (RACSignal *)execute:(id)input</span></span><br><span class="line">[<span class="keyword">self</span>.command execute:<span class="string">@&quot;&quot;</span>];</span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">控制台打印：</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-24</span> <span class="number">14</span>:<span class="number">43</span>:<span class="number">06.571968</span>+<span class="number">0800</span> ZSTest[<span class="number">3725</span>:<span class="number">171859</span>] RACCommand命令正在执行...</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-24</span> <span class="number">14</span>:<span class="number">43</span>:<span class="number">06.572526</span>+<span class="number">0800</span> ZSTest[<span class="number">3725</span>:<span class="number">171859</span>] 收到信号：网络请求的信号</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-24</span> <span class="number">14</span>:<span class="number">43</span>:<span class="number">06.572662</span>+<span class="number">0800</span> ZSTest[<span class="number">3725</span>:<span class="number">171859</span>] 改进-收到信号：网络请求的信号</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-24</span> <span class="number">14</span>:<span class="number">43</span>:<span class="number">06.573506</span>+<span class="number">0800</span> ZSTest[<span class="number">3725</span>:<span class="number">171859</span>] RACCommand命令不在执行中！！！</span><br></pre></td></tr></table></figure>

<h1 id="二、RAC常用的宏定义"><a href="#二、RAC常用的宏定义" class="headerlink" title="二、RAC常用的宏定义"></a>二、RAC常用的宏定义</h1><h2 id="1-RAC-对象，对象属性-：绑定属性"><a href="#1-RAC-对象，对象属性-：绑定属性" class="headerlink" title="1.RAC(对象，对象属性)：绑定属性"></a>1.RAC(对象，对象属性)：绑定属性</h2><p>输入框背景色绑定了映射后的validUserNameSignal信号，信号变化时背景色更新</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RAC(<span class="keyword">self</span>.userNameTxtField,backgroundColor) = [validUserNameSignal map:^<span class="type">id</span> _Nullable(<span class="built_in">NSNumber</span> *userNameValid) &#123;</span><br><span class="line">    <span class="keyword">return</span> [userNameValid boolValue] ? [<span class="built_in">UIColor</span> whiteColor] : [<span class="built_in">UIColor</span> yellowColor];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<h2 id="2-RACObserve-被观察的对象，被观察对象的属性-：代替KVO监听某个对象的某个属性"><a href="#2-RACObserve-被观察的对象，被观察对象的属性-：代替KVO监听某个对象的某个属性" class="headerlink" title="2.RACObserve(被观察的对象，被观察对象的属性) ：代替KVO监听某个对象的某个属性"></a>2.RACObserve(被观察的对象，被观察对象的属性) ：代替KVO监听某个对象的某个属性</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[RACObserve(<span class="keyword">self</span>.view, backgroundColor) subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;测试：%@&quot;</span>,x);</span><br><span class="line">&#125;];</span><br><span class="line"><span class="comment">//颜色变化时将打印</span></span><br><span class="line"><span class="keyword">self</span>.view.backgroundColor = [<span class="built_in">UIColor</span> whiteColor];</span><br><span class="line"><span class="keyword">self</span>.view.backgroundColor =[<span class="built_in">UIColor</span> redColor];</span><br></pre></td></tr></table></figure>

<h2 id="3-RACTuplePack与RACTupleUnpack"><a href="#3-RACTuplePack与RACTupleUnpack" class="headerlink" title="3.RACTuplePack与RACTupleUnpack"></a>3.RACTuplePack与RACTupleUnpack</h2><p><strong>RACTuplePack</strong>：将数据封装成元组<br><strong>RACTupleUnpack</strong>：将元组解包为数据</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用RACTuplePack封装元组</span></span><br><span class="line">RACTuple *racTuple = RACTuplePack(<span class="string">@&quot;字符串1&quot;</span>,<span class="string">@&quot;字符串2&quot;</span>);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;测试racTuple:%@&quot;</span>,racTuple);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用RACTupleUnpack解元组</span></span><br><span class="line">RACTupleUnpack(<span class="built_in">NSString</span> *str1,<span class="built_in">NSString</span> *str2) = racTuple;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;测试RACTupleUnpack：%@-%@&quot;</span>,str1,str2);</span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">控制台打印：</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-26</span> <span class="number">19</span>:<span class="number">27</span>:<span class="number">27.568399</span>+<span class="number">0800</span> ZSTest[<span class="number">23113</span>:<span class="number">380213</span>] 测试racTuple:&lt;RACTwoTuple: <span class="number">0x60400000ed70</span>&gt; (</span><br><span class="line">    <span class="string">&quot;\U5b57\U7b26\U4e321&quot;</span>,</span><br><span class="line">    <span class="string">&quot;\U5b57\U7b26\U4e322&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-26</span> <span class="number">19</span>:<span class="number">27</span>:<span class="number">27.568623</span>+<span class="number">0800</span> ZSTest[<span class="number">23113</span>:<span class="number">380213</span>] 测试RACTupleUnpack：字符串<span class="number">1</span>-字符串<span class="number">2</span></span><br></pre></td></tr></table></figure>

<h2 id="4-weakify、-strongify"><a href="#4-weakify、-strongify" class="headerlink" title="4.@weakify、@strongify"></a>4.@weakify、@strongify</h2><p>RAC中使用@weakify、@strongify解决Block循环引用的问题。<strong>在block内部使用@strongify(self)后就可以使用self操作属性了，但是一定注意这两个宏定义一定要配合使用</strong>，<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/701da54bd78c">可参考源码分析</a>。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@weakify(<span class="keyword">self</span>);</span><br><span class="line"><span class="comment">//RAC处理手势，点击页面，隐藏键盘</span></span><br><span class="line">[<span class="keyword">self</span>.tapGesture.rac_gestureSignal subscribeNext:^(__kindof <span class="built_in">UIGestureRecognizer</span> * _Nullable x) &#123;</span><br><span class="line">    @strongify(<span class="keyword">self</span>);</span><br><span class="line">    <span class="comment">//经过宏定义处理后就可以使用self了，但此self非彼self。具体可查看源码分析</span></span><br><span class="line">    [<span class="keyword">self</span>.view endEditing:<span class="literal">YES</span>];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>







<h1 id="三、RAC中关于信号的常用操作"><a href="#三、RAC中关于信号的常用操作" class="headerlink" title="三、RAC中关于信号的常用操作"></a>三、RAC中关于信号的常用操作</h1><p>本节整理了以下几种常用信号操作：<br>1.信号映射：map与flattenMap<br>2.信号过滤：filter、ignore、 distinctUntilChanged<br>3.信号合并： combineLatest、reduce、merge、zipWith<br>4.信号连接：concat、then<br>5.信号操作时间：timeout、interval、dely<br>6.信号取值：take、takeLast、takeUntil、<br>7.信号跳过：skip<br>8.信号发送顺序：donext、cocompleted<br>9.获取信号中的信号：switchToLatest<br>10.信号错误重试：retry<br>11.信号节流：throttle<br>12.信号操作多线程：deliverON、subscribeOn</p>
<h2 id="1-信号映射：map与flattenMap"><a href="#1-信号映射：map与flattenMap" class="headerlink" title="1.信号映射：map与flattenMap"></a>1.信号映射：map与flattenMap</h2><p><strong>map</strong>：将信号内容修改为另一种新值。改变了传递的值<br><strong>flattenMap</strong>：将源信号映射修改为另一种新的信号。修改了信号本身</p>
<h3 id="1-1、map"><a href="#1-1、map" class="headerlink" title="1.1、map"></a>1.1、map</h3><p>将信号文本值修改为文本长度</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//block中return的是你希望接收到的值</span></span><br><span class="line">[[<span class="keyword">self</span>.txtField.rac_textSignal map:^<span class="type">id</span> _Nullable(<span class="built_in">NSString</span> * _Nullable value) &#123;</span><br><span class="line">    <span class="keyword">return</span> @(value.length);<span class="comment">//必须返回一个对象</span></span><br><span class="line">&#125;] subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">     <span class="comment">//输入abcd，打印了输入字符的长度</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;打印x:%@&quot;</span>,x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">控制台打印：</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">10</span>:<span class="number">52</span>:<span class="number">41.831785</span>+<span class="number">0800</span> ZSTest[<span class="number">1143</span>:<span class="number">44274</span>] 打印x:<span class="number">1</span></span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">10</span>:<span class="number">52</span>:<span class="number">42.575238</span>+<span class="number">0800</span> ZSTest[<span class="number">1143</span>:<span class="number">44274</span>] 打印x:<span class="number">2</span></span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">10</span>:<span class="number">52</span>:<span class="number">43.602008</span>+<span class="number">0800</span> ZSTest[<span class="number">1143</span>:<span class="number">44274</span>] 打印x:<span class="number">3</span></span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">10</span>:<span class="number">52</span>:<span class="number">44.054940</span>+<span class="number">0800</span> ZSTest[<span class="number">1143</span>:<span class="number">44274</span>] 打印x:<span class="number">4</span></span><br></pre></td></tr></table></figure>

<h3 id="1-2、flattenMap"><a href="#1-2、flattenMap" class="headerlink" title="1.2、flattenMap"></a>1.2、flattenMap</h3><p>flattenMap的block返回的是你想要的信号</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个普通信号</span></span><br><span class="line">RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="type">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:<span class="string">@&quot;发送信号：1&quot;</span>];</span><br><span class="line">    [subscriber sendCompleted];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个发送信号的信号，信号的信号</span></span><br><span class="line">RACSignal *signalOfSignals = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="type">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:signal];</span><br><span class="line">    [subscriber sendCompleted];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line">    </span><br><span class="line"><span class="comment">//订阅信号中的信号</span></span><br><span class="line">[signalOfSignals subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="comment">//不使用flattenMap，会打印出内部信号</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;订阅signalOfSignals：%@&quot;</span>,x);</span><br><span class="line">&#125;];</span><br><span class="line">    </span><br><span class="line">[[signalOfSignals flattenMap:^__kindof RACSignal * _Nullable(<span class="type">id</span>  _Nullable value) &#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">   &#125;] subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="comment">//使用flattenMap，会打印内部信号的值</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;使用flattenMap后订阅signalOfSignals：%@&quot;</span>,x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">控制台打印：</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">11</span>:<span class="number">23</span>:<span class="number">42.920455</span>+<span class="number">0800</span> ZSTest[<span class="number">1363</span>:<span class="number">61658</span>] 订阅signalOfSignals：&lt;RACDynamicSignal: <span class="number">0x60400023a320</span>&gt; name: </span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">11</span>:<span class="number">23</span>:<span class="number">42.920791</span>+<span class="number">0800</span> ZSTest[<span class="number">1363</span>:<span class="number">61658</span>] 使用flattenMap后订阅signalOfSignals：发送信号：<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>特别说明：信号中信号常出现在我们封装一个网络请求为信号的时候，这时候注意flattenMap的使用。</strong></p>
<h2 id="2-信号过滤：filter、ignore、-distinctUntilChanged"><a href="#2-信号过滤：filter、ignore、-distinctUntilChanged" class="headerlink" title="2.信号过滤：filter、ignore、 distinctUntilChanged"></a>2.信号过滤：filter、ignore、 distinctUntilChanged</h2><h3 id="2-1、filter"><a href="#2-1、filter" class="headerlink" title="2.1、filter"></a>2.1、filter</h3><p>过滤信号，符合条件的信号才能发出消息。<br>示例：输入1234，当输入到4(文本长度大于3)的时候才开始打印如下的信息</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="keyword">self</span>.txtField.rac_textSignal filter:^<span class="type">BOOL</span>(<span class="built_in">NSString</span> * _Nullable value) &#123;</span><br><span class="line">    <span class="keyword">return</span> value.length &gt; <span class="number">3</span>;</span><br><span class="line">    &#125;] subscribeNext:^(<span class="built_in">NSString</span> * _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;打印x：%@&quot;</span>,x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">控制台打印：</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">11</span>:<span class="number">39</span>:<span class="number">23.371432</span>+<span class="number">0800</span> ZSTest[<span class="number">1428</span>:<span class="number">68939</span>] 打印x：<span class="number">1234</span></span><br></pre></td></tr></table></figure>

<h3 id="2-2、ignore"><a href="#2-2、ignore" class="headerlink" title="2.2、ignore"></a>2.2、ignore</h3><p>忽略信号，针对信号值的某一种状态进行忽略，忽略时不会发送消息。<br>示例：监听每次的输入，但是当文本框内的内容是”a”时不会打印</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="keyword">self</span>.txtField.rac_textSignal ignore:<span class="string">@&quot;a&quot;</span>] subscribeNext:^(<span class="built_in">NSString</span> * _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;ignore测试打印：%@&quot;</span>,x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<h3 id="2-3、distinctUntilChanged"><a href="#2-3、distinctUntilChanged" class="headerlink" title="2.3、distinctUntilChanged"></a>2.3、distinctUntilChanged</h3><p>当上次的值与当前值有变化时才会发出消息，否则信息被忽略</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为了方便测试，我们监测控制器的currentText属性来修改Label的文本值。</span></span><br><span class="line">__<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>)weakSelf = <span class="keyword">self</span>;</span><br><span class="line">[[RACObserve(<span class="keyword">self</span>, currentText) distinctUntilChanged] subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;使用%@更新testLabel的值&quot;</span>,x);</span><br><span class="line">    weakSelf.testLabel.text = x;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">//currentTxt未被赋初值，所以第一次打印null,我们自己修改三次值，只打印两次</span></span><br><span class="line"><span class="keyword">self</span>.currentText = <span class="string">@&quot;hello&quot;</span>;</span><br><span class="line"><span class="keyword">self</span>.currentText = <span class="string">@&quot;world&quot;</span>;</span><br><span class="line"><span class="keyword">self</span>.currentText = <span class="string">@&quot;world&quot;</span>;</span><br><span class="line"></span><br><span class="line">控制台打印:</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">16</span>:<span class="number">43</span>:<span class="number">54.617385</span>+<span class="number">0800</span> ZSTest[<span class="number">3598</span>:<span class="number">220992</span>] 使用(null)更新testLabel的值</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">16</span>:<span class="number">43</span>:<span class="number">54.618026</span>+<span class="number">0800</span> ZSTest[<span class="number">3598</span>:<span class="number">220992</span>] 使用hello更新testLabel的值</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">16</span>:<span class="number">43</span>:<span class="number">54.618380</span>+<span class="number">0800</span> ZSTest[<span class="number">3598</span>:<span class="number">220992</span>] 使用world更新testLabel的值 </span><br></pre></td></tr></table></figure>



<h2 id="3-信号合并：combineLatest、reduce、merge、zipWith"><a href="#3-信号合并：combineLatest、reduce、merge、zipWith" class="headerlink" title="3.信号合并：combineLatest、reduce、merge、zipWith"></a>3.信号合并：combineLatest、reduce、merge、zipWith</h2><p>为了便于测试，这里先创建两个RACSubject类型的信号用于测试，此类信号只有发送信号sendNext方法执行时，订阅者才会执行nextBlock里的内容;</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">RACSubject *signalOne = [RACSubject subject];</span><br><span class="line">[signalOne subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;订阅信号one：%@&quot;</span>,x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">RACSubject *signalTwo = [RACSubject subject];</span><br><span class="line">[signalTwo subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;订阅信号Two：%@&quot;</span>,x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<h3 id="3-1、combineLatest：合并信号"><a href="#3-1、combineLatest：合并信号" class="headerlink" title="3.1、combineLatest：合并信号"></a>3.1、combineLatest：合并信号</h3><p>合并信号的效果就是，这多个信号都至少有过一次订阅信号sendNext的操作，才会触发合并的信号。下面的测试如果只有signalOne执行sendNext方法，那么combineLatest后的信号不会被触发。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[[RACSignal combineLatest:@[signalOne,signalTwo]] subscribeNext:^(RACTuple * _Nullable x) &#123;</span><br><span class="line">    <span class="comment">//解元组：合并信号得到的是一个元组,里面存放的是两个信号发送的消息</span></span><br><span class="line">    RACTupleUnpack(<span class="built_in">NSString</span> *str1,<span class="built_in">NSString</span> *str2) = x;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;combineLatest:str1-%@,str2-%@&quot;</span>,str1,str2);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[signalOne sendNext:<span class="string">@&quot;1&quot;</span>];</span><br><span class="line">[signalTwo sendNext:<span class="string">@&quot;2”];</span></span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">控制台打印：</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">14</span>:<span class="number">29</span>:<span class="number">53.198724</span>+<span class="number">0800</span> ZSTest[<span class="number">2172</span>:<span class="number">143774</span>] 订阅信号one：<span class="number">1</span></span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">14</span>:<span class="number">29</span>:<span class="number">53.199673</span>+<span class="number">0800</span> ZSTest[<span class="number">2172</span>:<span class="number">143774</span>] 订阅信号Two：<span class="number">2</span></span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">14</span>:<span class="number">29</span>:<span class="number">53.200075</span>+<span class="number">0800</span> ZSTest[<span class="number">2172</span>:<span class="number">143774</span>] combineLatest:&lt;RACTuple: <span class="number">0x60000000d9a0</span>&gt; (</span><br><span class="line">    <span class="number">1</span>,</span><br><span class="line">    <span class="number">2</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="3-2、reduce：聚合信号"><a href="#3-2、reduce：聚合信号" class="headerlink" title="3.2、reduce：聚合信号"></a>3.2、reduce：聚合信号</h3><p>combineLatest合并后的信号订阅后，得到的是一个元组(包含每个被合并信号的新值)。然而在开发中，我们往往需要检测多个信号合并后的效果(比如用户名和密码信号有效时，登录按钮才可以点击)，这里就用到了reduce来实现信号聚合。<br>reduce聚合操作中的block参数个数随合并信号的数量而定，有多少个信号被合并，blcok中的参数就有多少个。这些参数一一对应被合并的信号，是它们对应的新值。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[[RACSignal combineLatest:@[signalOne,signalTwo] reduce:^<span class="type">id</span>(<span class="built_in">NSString</span> *strOne,<span class="built_in">NSString</span> *strTwo)&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%@-%@&quot;</span>,strOne,strTwo];</span><br><span class="line">&#125;] subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;combineLatest-reduce：%@&quot;</span>,x);</span><br><span class="line">&#125;];</span><br><span class="line">[signalOne sendNext:<span class="string">@&quot;1&quot;</span>];</span><br><span class="line">[signalTwo sendNext:<span class="string">@&quot;2&quot;</span>];</span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">控制台打印：</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">14</span>:<span class="number">40</span>:<span class="number">08.977580</span>+<span class="number">0800</span> ZSTest[<span class="number">2288</span>:<span class="number">149816</span>] 订阅信号one：<span class="number">1</span></span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">14</span>:<span class="number">40</span>:<span class="number">08.978566</span>+<span class="number">0800</span> ZSTest[<span class="number">2288</span>:<span class="number">149816</span>] 订阅信号Two：<span class="number">2</span></span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">14</span>:<span class="number">40</span>:<span class="number">08.979587</span>+<span class="number">0800</span> ZSTest[<span class="number">2288</span>:<span class="number">149816</span>] combineLatest-reduce：<span class="number">1</span><span class="number">-2</span></span><br></pre></td></tr></table></figure>

<h3 id="3-3、merge：合并信号"><a href="#3-3、merge：合并信号" class="headerlink" title="3.3、merge：合并信号"></a>3.3、merge：合并信号</h3><p>当合并后的信号被订阅时，就会订阅里面所有的信号<br>测试1：将多个信号合并之后，当其中任何一个信号发送消息时，都能被监测到。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *mergeSignal = [signalOne merge:signalTwo];</span><br><span class="line">[mergeSignal subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;mergeSignal：%@&quot;</span>,x);</span><br><span class="line">&#125;];</span><br><span class="line"><span class="comment">//只调用其中一个信号,就会触发merge合并的信号</span></span><br><span class="line">[signalOne sendNext:<span class="string">@&quot;测试信号1&quot;</span>];</span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">控制台打印：</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">14</span>:<span class="number">53</span>:<span class="number">34.342899</span>+<span class="number">0800</span> ZSTest[<span class="number">2577</span>:<span class="number">160009</span>] 订阅信号one：测试信号<span class="number">1</span></span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">14</span>:<span class="number">53</span>:<span class="number">34.343124</span>+<span class="number">0800</span> ZSTest[<span class="number">2577</span>:<span class="number">160009</span>] mergeSignal：测试信号<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>测试2：当合并后的信号被订阅时，就会订阅里面所有的信号</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signal1 = [RACSignal createSignal:^RACDisposable *(<span class="type">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:<span class="string">@&quot;signal1&quot;</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">RACSignal *signal2 = [RACSignal createSignal:^RACDisposable *(<span class="type">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:<span class="string">@&quot;signal2&quot;</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">RACSignal *mergeSignals = [signal1 merge:signal2];</span><br><span class="line">    [mergeSignals subscribeNext:^(<span class="type">id</span> x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;mergeSignals：%@&quot;</span>,x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">控制台打印：</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">18</span>:<span class="number">10</span>:<span class="number">29.623099</span>+<span class="number">0800</span> ZSTest[<span class="number">4444</span>:<span class="number">270816</span>] mergeSignals：signal1</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">18</span>:<span class="number">10</span>:<span class="number">29.623721</span>+<span class="number">0800</span> ZSTest[<span class="number">4444</span>:<span class="number">270816</span>] mergeSignals：signal2</span><br></pre></td></tr></table></figure>

<h3 id="3-4、zipWith：压缩信号"><a href="#3-4、zipWith：压缩信号" class="headerlink" title="3.4、zipWith：压缩信号"></a>3.4、zipWith：压缩信号</h3><p>1.zipWith把两个信号压缩成为一个信号。<br>2.只有当两个信号同时发出信号时，两个信号的内容才会被合并为一个元组，触发压缩流的next事件。比如：当一个界面多个请求的时候，要等所有请求完成才更新UI。元组内元素顺序只与压缩信号的顺序有关，与发送信号的顺序无关。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *zipSignal = [signalOne zipWith:signalTwo];</span><br><span class="line">[zipSignal subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="comment">//解元组：合并信号得到的是一个元组,里面存放的是两个信号发送的消息</span></span><br><span class="line">    RACTupleUnpack(<span class="built_in">NSString</span> *str1,<span class="built_in">NSString</span> *str2) = x;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;zipSignal：str1-%@,str2-%@&quot;</span>,str1,str2);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[signalOne sendNext:<span class="string">@&quot;测试zipSignalMsgOne&quot;</span>];</span><br><span class="line">[signalTwo sendNext:<span class="string">@&quot;测试zipSignalMsgTwo&quot;</span>];</span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">控制台打印：</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">15</span>:<span class="number">23</span>:<span class="number">58.989780</span>+<span class="number">0800</span> ZSTest[<span class="number">2926</span>:<span class="number">177798</span>] 订阅信号one：测试zipSignalMsgOne</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">15</span>:<span class="number">23</span>:<span class="number">58.990012</span>+<span class="number">0800</span> ZSTest[<span class="number">2926</span>:<span class="number">177798</span>] 订阅信号Two：测试zipSignalMsgTwo</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">15</span>:<span class="number">23</span>:<span class="number">58.991056</span>+<span class="number">0800</span> ZSTest[<span class="number">2926</span>:<span class="number">177798</span>] zipSignal：str1-测试zipSignalMsgOne,str2-测试zipSignalMsgTwo</span><br></pre></td></tr></table></figure>



<h2 id="4-信号拼接：concat、then"><a href="#4-信号拼接：concat、then" class="headerlink" title="4.信号拼接：concat、then"></a>4.信号拼接：concat、then</h2><h3 id="4-1、concat"><a href="#4-1、concat" class="headerlink" title="4.1、concat"></a>4.1、concat</h3><p>1.使用concat可以按序拼接多个信号，拼接后的信号按序执行。<br>2.使用concat连接信号后，每个信号无需再单独订阅，其内部会按序自动订阅<br>3.前面的信号必须执行sendCompleted，后面的信号才会被激活</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signalOne = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="type">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:<span class="string">@&quot;signalOne&quot;</span>];</span><br><span class="line">    [subscriber sendCompleted];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line">    </span><br><span class="line">RACSignal *signalTwo = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="type">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:<span class="string">@&quot;signalTwo&quot;</span>];</span><br><span class="line">    [subscriber sendCompleted];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">RACSignal *signalThree = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="type">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:<span class="string">@&quot;signalThree&quot;</span>];</span><br><span class="line">    [subscriber sendCompleted];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line">   </span><br><span class="line"><span class="comment">//拼接了三个信号，订阅之后，三个信号依次激活</span></span><br><span class="line">RACSignal *concatSignal = [[signalOne concat:signalThree] concat:signalTwo];</span><br><span class="line">[concatSignal subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;信号被激活:%@&quot;</span>,x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">控制台打印：</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-22</span> <span class="number">17</span>:<span class="number">36</span>:<span class="number">47.565105</span>+<span class="number">0800</span> ZSTest[<span class="number">6018</span>:<span class="number">274201</span>] 信号被激活:signalOne</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-22</span> <span class="number">17</span>:<span class="number">36</span>:<span class="number">47.565403</span>+<span class="number">0800</span> ZSTest[<span class="number">6018</span>:<span class="number">274201</span>] 信号被激活:signalThree</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-22</span> <span class="number">17</span>:<span class="number">36</span>:<span class="number">47.565609</span>+<span class="number">0800</span> ZSTest[<span class="number">6018</span>:<span class="number">274201</span>] 信号被激活:signalTwo</span><br></pre></td></tr></table></figure>

<h3 id="4-2、then-连接信号"><a href="#4-2、then-连接信号" class="headerlink" title="4.2、then:连接信号"></a>4.2、then:连接信号</h3><p>使用then连接信号，上一个信号完成后，才会连接then返回的信号，所以then连接的上一个信号必须使用sendCompleted，否则后续信号无法执行。<br><strong>then连接的多个信号与concat不同的是：之前的信号会被忽略掉，即订阅信号只会接收到最后一个信号的值</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[[[[RACSignal createSignal:^RACDisposable *(<span class="type">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;信号1&quot;</span>);</span><br><span class="line">        [subscriber sendNext:<span class="string">@&quot;发送信号1&quot;</span>];</span><br><span class="line">        [subscriber sendCompleted];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;] then:^RACSignal *&#123;</span><br><span class="line">        <span class="keyword">return</span> [RACSignal createSignal:^RACDisposable *(<span class="type">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;信号2&quot;</span>);</span><br><span class="line">            [subscriber sendNext:<span class="string">@&quot;发送信号2&quot;</span>];</span><br><span class="line">            [subscriber sendCompleted];</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;]then:^RACSignal * _Nonnull&#123;</span><br><span class="line">        <span class="keyword">return</span> [RACSignal createSignal:^RACDisposable *(<span class="type">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;信号3&quot;</span>);</span><br><span class="line">            [subscriber sendNext:<span class="string">@&quot;发送信号3&quot;</span>];</span><br><span class="line">            [subscriber sendCompleted];</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;] subscribeNext:^(<span class="type">id</span> x) &#123;</span><br><span class="line">        <span class="comment">//只能接收到最后一个信号的值</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;订阅信号：%@&quot;</span>,x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">控制台打印：</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">16</span>:<span class="number">53</span>:<span class="number">52.819003</span>+<span class="number">0800</span> ZSTest[<span class="number">3668</span>:<span class="number">227466</span>] 信号<span class="number">1</span></span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">16</span>:<span class="number">53</span>:<span class="number">52.819762</span>+<span class="number">0800</span> ZSTest[<span class="number">3668</span>:<span class="number">227466</span>] 信号<span class="number">2</span></span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">16</span>:<span class="number">53</span>:<span class="number">52.820008</span>+<span class="number">0800</span> ZSTest[<span class="number">3668</span>:<span class="number">227466</span>] 信号<span class="number">3</span></span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">16</span>:<span class="number">53</span>:<span class="number">52.820139</span>+<span class="number">0800</span> ZSTest[<span class="number">3668</span>:<span class="number">227466</span>] 订阅信号：发送信号<span class="number">3</span></span><br></pre></td></tr></table></figure>



<h2 id="5-信号操作时间：timeout、interval、dely"><a href="#5-信号操作时间：timeout、interval、dely" class="headerlink" title="5.信号操作时间：timeout、interval、dely"></a>5.信号操作时间：timeout、interval、dely</h2><h3 id="5-1、interval"><a href="#5-1、interval" class="headerlink" title="5.1、interval"></a>5.1、interval</h3><p>创建定时器信号，每固定时间发送一次信号</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *intervalSignal = [RACSignal interval:<span class="number">1</span> onScheduler:[RACScheduler currentScheduler]];</span><br><span class="line"></span><br><span class="line"><span class="comment">//只知道使用take结束定时器这一种方法，不知道还有没有其他方法</span></span><br><span class="line">[[intervalSignal take:<span class="number">5</span>]subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="comment">//订阅定时器信号，启动定时器，只打印5次</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;interval,定时器打印&quot;</span>);</span><br><span class="line">   &#125;];</span><br></pre></td></tr></table></figure>

<h3 id="5-2、timeout"><a href="#5-2、timeout" class="headerlink" title="5.2、timeout"></a>5.2、timeout</h3><p>可以设置超时操作，让一个信号在规定时间之后自动报错<br><strong>创建信号时不能使用sendCompleted，因为这样的话一旦发送了消息就取消订阅了。</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *timeOutSignal = [[RACSignal createSignal:^RACDisposable * _Nullable(<span class="type">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:<span class="string">@&quot;timeOutSignal发送信号&quot;</span>];</span><br><span class="line">    <span class="comment">//[subscriber sendCompleted];</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;] timeout:<span class="number">5</span> onScheduler:[RACScheduler currentScheduler]];</span><br><span class="line">   </span><br><span class="line">[timeOutSignal subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;timeOutSignal:%@&quot;</span>,x);</span><br><span class="line"> &#125; error:^(<span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">    <span class="comment">//5秒后执行打印：</span></span><br><span class="line">    <span class="comment">//timeOutSignal:出现Error-Error Domain=RACSignalErrorDomain Code=1 &quot;(null)&quot;</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;timeOutSignal:出现Error-%@&quot;</span>,error);</span><br><span class="line">&#125; completed:^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;timeOutSignal:complete&quot;</span>);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<h3 id="5-3、delay"><a href="#5-3、delay" class="headerlink" title="5.3、delay"></a>5.3、delay</h3><p>延迟发送sendNext</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *delaySignal = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="type">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:<span class="string">@&quot;delaySignal-sendNext&quot;</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line">   </span><br><span class="line"><span class="comment">//10秒后才收到消息，执行打印</span></span><br><span class="line">[[delaySignal delay:<span class="number">10</span>] subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;delaySignal:%@&quot;</span>,x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>



<h3 id="6-信号取值take、takeLast、takeUntil"><a href="#6-信号取值take、takeLast、takeUntil" class="headerlink" title="6.信号取值take、takeLast、takeUntil"></a>6.信号取值take、takeLast、takeUntil</h3><p>首先创建一个signal来测试这三个方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="type">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:<span class="string">@&quot;发送消息1&quot;</span>];</span><br><span class="line">    [subscriber sendNext:<span class="string">@&quot;发送消息2&quot;</span>];</span><br><span class="line">    [subscriber sendNext:<span class="string">@&quot;发送消息3&quot;</span>];</span><br><span class="line">    [subscriber sendNext:<span class="string">@&quot;发送消息4&quot;</span>];</span><br><span class="line">    [subscriber sendCompleted];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<h3 id="6-1、take：从开始共取N次的next值"><a href="#6-1、take：从开始共取N次的next值" class="headerlink" title="6.1、take：从开始共取N次的next值"></a>6.1、take：从开始共取N次的next值</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[[signal take:<span class="number">2</span>] subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;订阅信号:%@&quot;</span>,x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">控制台打印：</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">17</span>:<span class="number">15</span>:<span class="number">09.865290</span>+<span class="number">0800</span> ZSTest[<span class="number">3835</span>:<span class="number">237999</span>] 订阅信号:发送消息<span class="number">1</span></span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">17</span>:<span class="number">15</span>:<span class="number">09.865617</span>+<span class="number">0800</span> ZSTest[<span class="number">3835</span>:<span class="number">237999</span>] 订阅信号:发送消息<span class="number">2</span> </span><br></pre></td></tr></table></figure>

<h3 id="6-2、takeLast：从最后共取值N次next的值"><a href="#6-2、takeLast：从最后共取值N次next的值" class="headerlink" title="6.2、takeLast：从最后共取值N次next的值"></a>6.2、takeLast：从最后共取值N次next的值</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[[signal takeLast:<span class="number">3</span>]subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;订阅信号：%@&quot;</span>,x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">控制台打印：</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">17</span>:<span class="number">19</span>:<span class="number">51.343909</span>+<span class="number">0800</span> ZSTest[<span class="number">3933</span>:<span class="number">241042</span>] 订阅信号：发送消息<span class="number">2</span></span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">17</span>:<span class="number">19</span>:<span class="number">51.344063</span>+<span class="number">0800</span> ZSTest[<span class="number">3933</span>:<span class="number">241042</span>] 订阅信号：发送消息<span class="number">3</span></span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">17</span>:<span class="number">19</span>:<span class="number">51.344177</span>+<span class="number">0800</span> ZSTest[<span class="number">3933</span>:<span class="number">241042</span>] 订阅信号：发送消息<span class="number">4</span> </span><br></pre></td></tr></table></figure>

<h3 id="6-3、takeUntil-RACSignal"><a href="#6-3、takeUntil-RACSignal" class="headerlink" title="6.3、takeUntil:(RACSignal *)"></a>6.3、takeUntil:(RACSignal *)</h3><p>使用RACSubject类型的信号来测试，直到某个信号执行完成  ,才获取信号</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">RACSubject *signalA = [RACSubject subject];</span><br><span class="line"></span><br><span class="line">[signalA subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;订阅信号A：%@&quot;</span>,x);</span><br><span class="line">&#125;];</span><br><span class="line">    </span><br><span class="line">__<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>)weakSelf = <span class="keyword">self</span>;</span><br><span class="line"><span class="comment">//[RACObserve(self, currentText)发送消息知道signalA信号结束</span></span><br><span class="line">[[RACObserve(<span class="keyword">self</span>, currentText) takeUntil:signalA] subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;使用%@更新testLabel的值&quot;</span>,x);</span><br><span class="line">    weakSelf.testLabel.text = x;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="keyword">self</span>.currentText = <span class="string">@&quot;0&quot;</span>;</span><br><span class="line"><span class="keyword">self</span>.currentText = <span class="string">@&quot;1&quot;</span>;</span><br><span class="line"><span class="keyword">self</span>.currentText = <span class="string">@&quot;2&quot;</span>;</span><br><span class="line">[signalA sendCompleted];<span class="comment">//信号A结束之后，监听testLabel文本的信号也不在发送消息了</span></span><br><span class="line"><span class="keyword">self</span>.currentText = <span class="string">@&quot;3&quot;</span>;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;代码执行到此行。。。。&quot;</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">控制台打印：</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">17</span>:<span class="number">31</span>:<span class="number">08.907925</span>+<span class="number">0800</span> ZSTest[<span class="number">4044</span>:<span class="number">247412</span>] 使用(null)更新testLabel的值</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">17</span>:<span class="number">31</span>:<span class="number">08.908531</span>+<span class="number">0800</span> ZSTest[<span class="number">4044</span>:<span class="number">247412</span>] 使用<span class="number">0</span>更新testLabel的值</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">17</span>:<span class="number">31</span>:<span class="number">08.908957</span>+<span class="number">0800</span> ZSTest[<span class="number">4044</span>:<span class="number">247412</span>] 使用<span class="number">1</span>更新testLabel的值</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">17</span>:<span class="number">31</span>:<span class="number">08.909194</span>+<span class="number">0800</span> ZSTest[<span class="number">4044</span>:<span class="number">247412</span>] 使用<span class="number">2</span>更新testLabel的值</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">17</span>:<span class="number">31</span>:<span class="number">08.909725</span>+<span class="number">0800</span> ZSTest[<span class="number">4044</span>:<span class="number">247412</span>] 代码执行到此行。。。。</span><br></pre></td></tr></table></figure>

<h2 id="7-信号跳过：skip"><a href="#7-信号跳过：skip" class="headerlink" title="7.信号跳过：skip"></a>7.信号跳过：skip</h2><p>使用skip跳过几个信号</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="type">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:<span class="string">@&quot;第一次发送消息&quot;</span>];</span><br><span class="line">    [subscriber sendNext:<span class="string">@&quot;第二次发送消息&quot;</span>];</span><br><span class="line">    [subscriber sendNext:<span class="string">@&quot;第三次发送消息&quot;</span>];</span><br><span class="line">    [subscriber sendNext:<span class="string">@&quot;第四次发送消息&quot;</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[[signal skip:<span class="number">2</span>] subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>,x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">控制台打印：</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">17</span>:<span class="number">48</span>:<span class="number">06.479104</span>+<span class="number">0800</span> ZSTest[<span class="number">4284</span>:<span class="number">259095</span>] 第三次发送消息</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">17</span>:<span class="number">48</span>:<span class="number">06.479376</span>+<span class="number">0800</span> ZSTest[<span class="number">4284</span>:<span class="number">259095</span>] 第四次发送消息</span><br></pre></td></tr></table></figure>



<h2 id="8-信号发送顺序：doNext、doCompleted"><a href="#8-信号发送顺序：doNext、doCompleted" class="headerlink" title="8.信号发送顺序：doNext、doCompleted"></a>8.信号发送顺序：doNext、doCompleted</h2><p>发送信号前与发送信号后操作：doNext、doCompleted<br><strong>doNext</strong>：在订阅者发送消息sendNext之前执行<br><strong>doCompleted</strong>：在订阅者发送完成sendCompleted之后执行</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="type">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:<span class="string">@&quot;发送信号：1&quot;</span>];</span><br><span class="line">    [subscriber sendCompleted];</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line">    </span><br><span class="line">[[[signal doNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@&quot;执行doNext&quot;</span>);</span><br><span class="line">&#125;] doCompleted:^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;执行doComplete&quot;</span>);</span><br><span class="line">&#125;] subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@&quot;订阅信号：%@&quot;</span>,x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">控制台打印：</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-28</span> <span class="number">11</span>:<span class="number">20</span>:<span class="number">42.881535</span>+<span class="number">0800</span> ZSTest[<span class="number">2656</span>:<span class="number">81106</span>] 执行doNext</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-28</span> <span class="number">11</span>:<span class="number">20</span>:<span class="number">42.881841</span>+<span class="number">0800</span> ZSTest[<span class="number">2656</span>:<span class="number">81106</span>] 订阅信号：发送信号：<span class="number">1</span></span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-28</span> <span class="number">11</span>:<span class="number">20</span>:<span class="number">42.882583</span>+<span class="number">0800</span> ZSTest[<span class="number">2656</span>:<span class="number">81106</span>] 执行doComplete</span><br></pre></td></tr></table></figure>

<h2 id="9-获取信号中的信号：switchToLatest"><a href="#9-获取信号中的信号：switchToLatest" class="headerlink" title="9.获取信号中的信号：switchToLatest"></a>9.获取信号中的信号：switchToLatest</h2><p>switchToLatest只能用于信号中的信号(否则崩溃)，获取最新发送的信号。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个普通信号</span></span><br><span class="line">RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="type">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:<span class="string">@&quot;发送信号：1&quot;</span>];</span><br><span class="line">    [subscriber sendCompleted];</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个发送信号的信号，信号的信号</span></span><br><span class="line">RACSignal *signalOfSignals = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="type">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:signal];</span><br><span class="line">    [subscriber sendCompleted];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line">    </span><br><span class="line"><span class="comment">//订阅最近发出的信号</span></span><br><span class="line">[signalOfSignals.switchToLatest subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="comment">//控制台打印：switchToLatest打印：发送信号：1</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;switchToLatest打印：%@&quot;</span>,x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<p>特别说明：<br><strong>可以看出switchToLatest和flattenMap的功能很相似，但是它们有一主要区别：</strong></p>
<h2 id="10-信号错误重试：retry"><a href="#10-信号错误重试：retry" class="headerlink" title="10.信号错误重试：retry"></a>10.信号错误重试：retry</h2><p>retry：只要失败就重新执行信号</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> signalANum = <span class="number">0</span>;</span><br><span class="line">RACSignal *signalA = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="type">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    <span class="keyword">if</span> (signalANum == <span class="number">5</span>) &#123;</span><br><span class="line">        [subscriber sendNext:<span class="string">@&quot;signalANum is 5&quot;</span>];</span><br><span class="line">        [subscriber sendCompleted];</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;signalANum错误！！!&quot;</span>);</span><br><span class="line">        [subscriber sendError:<span class="literal">nil</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    signalANum++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line">  </span><br><span class="line">[[signalA retry] subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;StringA-Next：%@&quot;</span>,x);</span><br><span class="line">&#125; error:^(<span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">    <span class="comment">//特别注意：这里并没有打印</span></span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@&quot;signalA-Errror&quot;</span>);</span><br><span class="line">&#125;] ;</span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">控制台打印：</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-24</span> <span class="number">09</span>:<span class="number">46</span>:<span class="number">38.996888</span>+<span class="number">0800</span> ZSTest[<span class="number">818</span>:<span class="number">14322</span>] signalANum错误！！!</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-24</span> <span class="number">09</span>:<span class="number">46</span>:<span class="number">39.063427</span>+<span class="number">0800</span> ZSTest[<span class="number">818</span>:<span class="number">14322</span>] signalANum错误！！!</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-24</span> <span class="number">09</span>:<span class="number">46</span>:<span class="number">39.064203</span>+<span class="number">0800</span> ZSTest[<span class="number">818</span>:<span class="number">14322</span>] signalANum错误！！!</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-24</span> <span class="number">09</span>:<span class="number">46</span>:<span class="number">39.064567</span>+<span class="number">0800</span> ZSTest[<span class="number">818</span>:<span class="number">14322</span>] signalANum错误！！!</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-24</span> <span class="number">09</span>:<span class="number">46</span>:<span class="number">39.064819</span>+<span class="number">0800</span> ZSTest[<span class="number">818</span>:<span class="number">14322</span>] signalANum错误！！!</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-24</span> <span class="number">09</span>:<span class="number">46</span>:<span class="number">39.065199</span>+<span class="number">0800</span> ZSTest[<span class="number">818</span>:<span class="number">14322</span>] StringA-Next：signalANum is <span class="number">5</span></span><br></pre></td></tr></table></figure>

<h2 id="11-信号节流：throttle"><a href="#11-信号节流：throttle" class="headerlink" title="11.信号节流：throttle"></a>11.信号节流：throttle</h2><p>当某个信号发送比较频繁时，可以使用throttle节流，在某一段时间不发送信号内容，过了一段时间获取信号的最新内容发出。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[[[RACSignal createSignal:^RACDisposable * _Nullable(<span class="type">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:<span class="string">@&quot;发送消息11&quot;</span>];</span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">2</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            [subscriber sendNext:<span class="string">@&quot;发送消息21&quot;</span>];</span><br><span class="line">            [subscriber sendNext:<span class="string">@&quot;发送消息22&quot;</span>];</span><br><span class="line">    &#125;);</span><br><span class="line">        </span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">3</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            [subscriber sendNext:<span class="string">@&quot;发送消息31&quot;</span>];</span><br><span class="line">            [subscriber sendNext:<span class="string">@&quot;发送消息32&quot;</span>];</span><br><span class="line">            [subscriber sendNext:<span class="string">@&quot;发送消息33&quot;</span>];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">4</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            [subscriber sendNext:<span class="string">@&quot;发送消息41&quot;</span>];</span><br><span class="line">            [subscriber sendNext:<span class="string">@&quot;发送消息42&quot;</span>];</span><br><span class="line">            [subscriber sendNext:<span class="string">@&quot;发送消息43&quot;</span>];</span><br><span class="line">            [subscriber sendNext:<span class="string">@&quot;发送消息44&quot;</span>];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;    </span><br><span class="line">&#125;] throttle:<span class="number">2</span>] subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;Next:%@&quot;</span>,x);</span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">控制台打印：</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-24</span> <span class="number">11</span>:<span class="number">05</span>:<span class="number">48.411464</span>+<span class="number">0800</span> ZSTest[<span class="number">2063</span>:<span class="number">62521</span>] Next:发送消息<span class="number">11</span></span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-24</span> <span class="number">11</span>:<span class="number">05</span>:<span class="number">52.426162</span>+<span class="number">0800</span> ZSTest[<span class="number">2063</span>:<span class="number">62521</span>] Next:发送消息<span class="number">44</span></span><br></pre></td></tr></table></figure>

<h2 id="12-信号关于线程的操作"><a href="#12-信号关于线程的操作" class="headerlink" title="12.信号关于线程的操作"></a>12.信号关于线程的操作</h2><p><strong>副作用</strong>：关于信号与线程,我们把在创建信号时block中的代码称之为副作用。<br><strong>deliverON</strong>：切换到指定线程中，可用于回到主线中刷新UI,内容传递切换到指定线程中，<br><strong>subscribeOn</strong>：内容传递和副作用都会切换到指定线程中。<br><strong>deliverOnMainThread</strong>：能保证原信号subscribeNext，sendError，sendCompleted都在主线程MainThread中执行。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试1：系统并行队列中异步执行,未使用deliverON切换线程</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">        [[RACSignal createSignal:^RACDisposable * _Nullable(<span class="type">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">            [subscriber sendNext:<span class="string">@&quot;测试1-endNext&quot;</span>];</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;测试1-当前线程：%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">        &#125;] subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;测试1-Next:%@&quot;</span>,x);</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;测试1-Next当前线程：%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;) ;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//测试2：系统并行队列中异步执行,使用deliverON切换线程</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">        [[[RACSignal createSignal:^RACDisposable * _Nullable(<span class="type">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">            [subscriber sendNext:<span class="string">@&quot;测试2-endNext&quot;</span>];</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;测试2-当前线程：%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">        &#125;] deliverOn:[RACScheduler mainThreadScheduler]] subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;测试2-Next:%@&quot;</span>,x);</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;测试2-Next当前线程：%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;) ;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//测试3：系统并行队列中异步执行,使用subscribeOn切换线程</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">        [[[RACSignal createSignal:^RACDisposable * _Nullable(<span class="type">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">            [subscriber sendNext:<span class="string">@&quot;测试3-sendNext&quot;</span>];</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;测试3-sendNext当前线程：%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">        &#125;] subscribeOn:[RACScheduler mainThreadScheduler]] subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;测试3-Next:%@&quot;</span>,x);</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;测试3-Next当前线程：%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;) ;</span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">控制台打印：</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-24</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">48.025872</span>+<span class="number">0800</span> ZSTest[<span class="number">2624</span>:<span class="number">109537</span>] 测试<span class="number">1</span>-Next:测试<span class="number">1</span>-endNext</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-24</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">48.026152</span>+<span class="number">0800</span> ZSTest[<span class="number">2624</span>:<span class="number">109537</span>] 测试<span class="number">1</span>-Next当前线程：&lt;<span class="built_in">NSThread</span>: <span class="number">0x60400046e640</span>&gt;&#123;number = <span class="number">5</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-24</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">48.026746</span>+<span class="number">0800</span> ZSTest[<span class="number">2624</span>:<span class="number">109537</span>] 测试<span class="number">1</span>-sendNext当前线程：&lt;<span class="built_in">NSThread</span>: <span class="number">0x60400046e640</span>&gt;&#123;number = <span class="number">5</span>, name = (null)&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-24</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">48.027784</span>+<span class="number">0800</span> ZSTest[<span class="number">2624</span>:<span class="number">109537</span>] 测试<span class="number">2</span>-sendNext当前线程：&lt;<span class="built_in">NSThread</span>: <span class="number">0x60400046e640</span>&gt;&#123;number = <span class="number">5</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-24</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">48.073294</span>+<span class="number">0800</span> ZSTest[<span class="number">2624</span>:<span class="number">109360</span>] 测试<span class="number">2</span>-Next:测试<span class="number">2</span>-sendNext</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-24</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">48.073890</span>+<span class="number">0800</span> ZSTest[<span class="number">2624</span>:<span class="number">109360</span>] 测试<span class="number">2</span>-Next当前线程：&lt;<span class="built_in">NSThread</span>: <span class="number">0x60400006a280</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-24</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">48.074181</span>+<span class="number">0800</span> ZSTest[<span class="number">2624</span>:<span class="number">109360</span>] 测试<span class="number">3</span>-Next:测试<span class="number">3</span>-sendNext</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-24</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">48.074511</span>+<span class="number">0800</span> ZSTest[<span class="number">2624</span>:<span class="number">109360</span>] 测试<span class="number">3</span>-Next当前线程：&lt;<span class="built_in">NSThread</span>: <span class="number">0x60400006a280</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-24</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">48.074646</span>+<span class="number">0800</span> ZSTest[<span class="number">2624</span>:<span class="number">109360</span>] 测试<span class="number">3</span>-sendNext当前线程：&lt;<span class="built_in">NSThread</span>: <span class="number">0x60400006a280</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br></pre></td></tr></table></figure>

<p>分析：<br><strong>测试1：未切换线程，发送消息与接收消息都在异步线程中</strong><br><strong>测试2：使用deliverON，发送消息还在原来的线程，但是接收消息切换到主线程。</strong><br><strong>测试2：使用subscribeON，发送消息和接收消息都被切换到了主线程中执行。</strong></p>
<h1 id="四、RAC常用的处理事件响应的方法"><a href="#四、RAC常用的处理事件响应的方法" class="headerlink" title="四、RAC常用的处理事件响应的方法"></a>四、RAC常用的处理事件响应的方法</h1><h2 id="1-代替代理的使用"><a href="#1-代替代理的使用" class="headerlink" title="1.代替代理的使用"></a>1.代替代理的使用</h2><p>基础篇里已经有一种使用RACSubject替换代理的方法，这里是另一种形式的替换。在视图控制中添加自定义视图CustomView，其上有一按钮testBtn添加了响应方法testBtnClick:。此时可以使用RAC在不使用代理的情况下，在视图控制中监听自定义视图中按钮的点击:<br><strong>关键方法：rac_signalForSelector</strong><br>使用说明：<br>1.通过rac_signalForSelector方法，以按钮响应方法为参数，得到一个信号。<br>2.订阅信号，在按钮点击时会发出信号。经过测试，即使testBtnClick方法没有在自定义视图的.h文件中声明，执行也是正常的。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[_customView  rac_signalForSelector:<span class="keyword">@selector</span>(testBtnClick:)] subscribeNext:^(RACTuple * _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;testBtn点击了。。。&quot;</span>);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<h2 id="2-代替按钮等控制视图的响应事件"><a href="#2-代替按钮等控制视图的响应事件" class="headerlink" title="2.代替按钮等控制视图的响应事件"></a>2.代替按钮等控制视图的响应事件</h2><p>创建一个类似按钮的响应控件，我们可以不必再为其添加响应方法。使用RAC可以将按钮点击事件转化为信号，点击按钮会发送信号，执行订阅方法。<br><strong>关键方法：rac_signalForControlEvents</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[testBtn rac_signalForControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>] subscribeNext:^(__kindof <span class="built_in">UIControl</span> * _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;testBtn点击了。。。&quot;</span>);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<h2 id="3-代替KVO，监听对象属性变化"><a href="#3-代替KVO，监听对象属性变化" class="headerlink" title="3.代替KVO，监听对象属性变化"></a>3.代替KVO，监听对象属性变化</h2><p><strong>关键方法：rac_valuesAndChangesForKeyPath</strong><br>使用说明：<br>1.自定义视图_customView属性frame的变化被转化信号，frame发生变化的时候，会发送信号。<br>2.observer可以为nil,但是会报警告。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[[_customView rac_valuesAndChangesForKeyPath:<span class="string">@&quot;frame&quot;</span> options:<span class="built_in">NSKeyValueObservingOptionNew</span> observer: <span class="literal">nil</span>] subscribeNext:^(<span class="type">id</span> x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;CustomView的Frame值变化了：%@&quot;</span>,x);</span><br><span class="line">&#125;];</span><br><span class="line">_customView.frame = <span class="built_in">CGRectZero</span>;</span><br></pre></td></tr></table></figure>

<h2 id="4-监听文本输入变化"><a href="#4-监听文本输入变化" class="headerlink" title="4.监听文本输入变化"></a>4.监听文本输入变化</h2><p><strong>关键方法：rac_textSignal</strong><br>UITextField与UITextView输入视图内容的变化，我们也可以采用RAC的方法来监听</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[_testTxtView rac_textSignal] subscribeNext:^(<span class="built_in">NSString</span> * _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;当前文本输入内容：%@&quot;</span>,x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<h2 id="5-代替通知的使用"><a href="#5-代替通知的使用" class="headerlink" title="5.代替通知的使用"></a>5.代替通知的使用</h2><p><strong>关键方法：rac_addObserverForName</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//步骤1： 添加通知</span></span><br><span class="line">[[[<span class="built_in">NSNotificationCenter</span> defaultCenter] rac_addObserverForName:<span class="string">@&quot;SecondVCNotificaitonName&quot;</span> object:<span class="literal">nil</span>] subscribeNext:^(<span class="built_in">NSNotification</span> * _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSDictionary</span> *objectDic = (<span class="built_in">NSDictionary</span> *)x.object;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;获取到通知里的文本：%@&quot;</span>,objectDic[<span class="string">@&quot;text&quot;</span>]);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">//步骤2：发起通知</span></span><br><span class="line"><span class="comment">//SecondVC中点击按钮，将输入框中的文本封装成字典，将其作为参数发起通知</span></span><br><span class="line">- (<span class="keyword">IBAction</span>)completeBtnClick:(<span class="type">id</span>)sender &#123;</span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:<span class="string">@&quot;SecondVCNotificaitonName&quot;</span> object:@&#123;<span class="string">@&quot;text&quot;</span>:<span class="keyword">self</span>.txtField.text&#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-多请求汇总处理"><a href="#6-多请求汇总处理" class="headerlink" title="6.多请求汇总处理"></a>6.多请求汇总处理</h2><p><strong>关键方法：rac_liftSelector：withSignals：</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下载任务1</span></span><br><span class="line">RACSignal *downLoad1 = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="type">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:@&#123;<span class="string">@&quot;data2&quot;</span>:<span class="string">@&quot;value1&quot;</span>&#125;];</span><br><span class="line">    [subscriber sendCompleted];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">//下载任务2</span></span><br><span class="line">RACSignal *downLoad2  = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="type">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:@&#123;<span class="string">@&quot;data2&quot;</span>:<span class="string">@&quot;value2&quot;</span>&#125;];</span><br><span class="line">    [subscriber sendCompleted];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line">    </span><br><span class="line"><span class="comment">//多信号对应多参数，注意顺序与格式</span></span><br><span class="line">[<span class="keyword">self</span> rac_liftSelector:<span class="keyword">@selector</span>(handleAllTasksWithT1:withT2:) withSignals:downLoad1,downLoad2, <span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//集中处理所有的请求</span></span><br><span class="line">- (<span class="type">void</span>)handleAllTasksWithT1:(<span class="type">id</span>)data1 withT2:(<span class="type">id</span>)data2&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;下载任务全部完成：%@，%@&quot;</span>,data1,data2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="五、本篇总结"><a href="#五、本篇总结" class="headerlink" title="五、本篇总结"></a>五、本篇总结</h1><p>写到这里，其实RAC还是有好多东西没有在这里涉及，本篇也只是对于它最常用的部分进行了归纳总结，尤其是我对于RAC在MVVM架构中的使用还不太熟练。RAC的学习，这仅仅是一个开始，继续努力吧！</p>
<p>参考链接：<br>1.<a target="_blank" rel="noopener" href="http://ios.jobbole.com/86357/">RAC核心元素与信号流</a><br>2.<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/a4fefb434652">iOS常用API整理</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wuyubeichen.github.io/2019/02/26/iOS%E5%BC%80%E5%8F%91-DTCoreText%E7%9A%84%E9%9B%86%E6%88%90%E4%B8%8E%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Author">
      <meta itemprop="description" content="iOS Developer, Beijing China">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="梧雨北辰的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/02/26/iOS%E5%BC%80%E5%8F%91-DTCoreText%E7%9A%84%E9%9B%86%E6%88%90%E4%B8%8E%E4%BD%BF%E7%94%A8/" class="post-title-link" itemprop="url">iOS开发-DTCoreText的集成与使用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-02-26 16:16:49" itemprop="dateCreated datePublished" datetime="2019-02-26T16:16:49+08:00">2019-02-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-29 09:39:32" itemprop="dateModified" datetime="2022-08-29T09:39:32+08:00">2022-08-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">iOS开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>主要内容：</p>
<ol>
<li><code>DTCoreText</code>简介</li>
<li><code>DTCoreText</code>的集成</li>
<li><code>DTCoreText</code>的使用</li>
<li><code>DTAttributedLabel</code></li>
<li><code>DTAttributedTextView</code></li>
<li><code>DTAttributedTextCell</code></li>
<li>可能遇到的错误</li>
</ol>
<h4 id="一、DTCoreText简介"><a href="#一、DTCoreText简介" class="headerlink" title="一、DTCoreText简介"></a>一、DTCoreText简介</h4><p><code>DTCoreText</code>是可以将<code>HTML</code>字符串转化为富文本使用的工具，既保证原生实现又能适应灵活的样式修改，而且相比于使用<code>WebView</code>显示内容在性能上也有很大优势，本篇就这一技术的使用进行总结。</p>
<p><code>DTCoreText</code>相关资源如下：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://github.com/Cocoanetics/DTCoreText">DTCoreText源码下载</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.cocoanetics.com/DTCoreText/">DTCoreText官方文档</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.cocoanetics.com/DTCoreText/docs/Setup%20Guide.html">DTCoreText集成文档</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/DreamcoffeeZS/DTCoreTextDemo.git">本文DTCoreText测试工程</a></li>
</ol>
<p>温馨提示：文中代码量比较大，看起来可能比较费劲，所以先将本文的<a target="_blank" rel="noopener" href="https://github.com/DreamcoffeeZS/DTCoreTextDemo.git">Demo链接</a>放在这里，结合代码看更方便，毕竟代码才是硬道理嘛！</p>
<h4 id="二、DTCoreText的集成"><a href="#二、DTCoreText的集成" class="headerlink" title="二、DTCoreText的集成"></a>二、DTCoreText的集成</h4><p>在项目中使用<code>DTCoreText</code>需要它的两个静态库：<code>DTCoreText.framework</code>和<code>DTFoundation.framework</code>，但是从<code>Github</code>下载的文件却不能直接使用。</p>
<p>起初，我是直接从网上其他地方下载打包好的静态库来使用的，但这样会遗漏掉更新。所以，这里总结了集成<code>DTCoreText</code>的具体步骤。</p>
<h5 id="1-下载源码"><a href="#1-下载源码" class="headerlink" title="1.下载源码"></a>1.下载源码</h5><p>创建一个文件夹<code>DTCoreText</code>，使用终端命令下载源码：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone --recursive [https://github.com/Cocoanetics/DTCoreText.git](https://github.com/Cocoanetics/DTCoreText.git) Externals/DTCoreText</span><br></pre></td></tr></table></figure>
<h5 id="2-设置编译配置"><a href="#2-设置编译配置" class="headerlink" title="2.设置编译配置"></a>2.设置编译配置</h5><p>修改<code>DTCoreText</code>工程的编译配置，然后运行工程就得到适合不同平台的静态库；</p>
<p>为了获取到适合<code>iOS</code>设备使用的<code>SDK</code>，选择工程<code>Target</code>为<code>DTCoreText(iOS)</code>，并依次选择<code>DTCoreText(iOS)</code> -&gt; <code>Deployment Info</code> -&gt; 选择需要最低支持的系统版本；<br><img src="http://182.92.228.41/wp-content/uploads/dtcoretext_targets_deployment_Info.png" width="600" align=center/></p>
<h5 id="3-设置Scheme"><a href="#3-设置Scheme" class="headerlink" title="3.设置Scheme"></a>3.设置Scheme</h5><p>选择<code>Product</code> -&gt; <code>Scheme</code> -&gt; <code>Edit Scheme</code>，修改编译环境修改为<code>Release</code>模式：<br><img src="http://182.92.228.41/wp-content/uploads/dtcoretext_scheme_release.png" width="600" align=center/></p>
<h5 id="4-模拟器和真机分别编译"><a href="#4-模拟器和真机分别编译" class="headerlink" title="4.模拟器和真机分别编译"></a>4.模拟器和真机分别编译</h5><p>使用<code>commadn+B</code>执行代码编译，注意一定要选择正确的<code>Target</code>，既然是用于<code>iOS</code>，就应该选择<code>DTCoreText (iOS)</code>这个<code>Target</code>进行编译</p>
<img src="http://182.92.228.41/wp-content/uploads/dtcoretext_compile_generic_ios.png" width="600" align=center/>
<img src="http://182.92.228.41/wp-content/uploads/dtcoretext_compile_ios_simulator.png" width="600" align=center/>

<h5 id="5-打开编译缓存，获取静态库"><a href="#5-打开编译缓存，获取静态库" class="headerlink" title="5.打开编译缓存，获取静态库"></a>5.打开编译缓存，获取静态库</h5><p>在<code>Xcode</code>依次打开<code>File</code> -&gt; <code>File Setting</code> -&gt; <code>DerivedData</code>，然后点击之后的路径箭头可以找到<code>DTCoreText</code>的编译缓存文件夹：<br><img src="http://182.92.228.41/wp-content/uploads/dtcoretext_compile_derived_data.png" width="600" align=center/></p>
<p>然后我们再依次打开<code>Build</code>-&gt;<code>Products</code>，将会看到适合模拟器和真机使用的两个静态库文件夹：<br><img src="http://182.92.228.41/wp-content/uploads/dtcoretext_build_products.png" width="600" align=center/></p>
<h5 id="6-合并静态库"><a href="#6-合并静态库" class="headerlink" title="6.合并静态库"></a>6.合并静态库</h5><p>经过上述步骤，我分别得到了适合模拟器和真机使用的静态库，现在我们把它们合并。首先我们把<code>Products</code>文件拷贝到一个合适的位置，然后在控制台执行合并静态库的命令如下：<br><img src="http://182.92.228.41/wp-content/uploads/dtcoretext_lipo_create_terminal.png" width="600" align=center/></p>
<p>如图，我们使用<code>lipo</code>命令合并了适合模拟器和真机使用的可执行文件：<br><img src="http://182.92.228.41/wp-content/uploads/dtcoretext_lipo_create_result.png" width="300" align=center/></p>
<p>然后，我们需要将两个文件分别对应拷贝到<code>Release-iphones</code>文件夹中的<code>DTCoreText.framework</code>和<code>DTFoundation.framework</code>中，这样最终我们就得到想要的静态库。</p>
<h4 id="三、DTCoreText的使用"><a href="#三、DTCoreText的使用" class="headerlink" title="三、DTCoreText的使用"></a>三、DTCoreText的使用</h4><p>在这之前我们准备一段测试用的<code>Html</code>如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_html <span class="operator">=</span> @<span class="string">&quot;&lt;span style=<span class="subst">\&quot;</span>color:#333;font-size:15px;<span class="subst">\&quot;</span>&gt;&lt;strong&gt;标题1&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span align=<span class="subst">\&quot;</span>left<span class="subst">\&quot;</span> style=<span class="subst">\&quot;</span>color:#333;font-size:15px;<span class="subst">\&quot;</span>&gt;详细介绍详细介绍详细介绍详细介绍详细介绍详细介绍。&lt;/span&gt;&lt;br/&gt;&lt;img src=<span class="subst">\&quot;</span>http://cn-qinqimaifang-uat.oss-cn-hangzhou.aliyuncs.com/img/specialist/upload/spcetiicwlz1v_54e2e00fa8a6faf66168571654dbfee2.jpg<span class="subst">\&quot;</span> _src=<span class="subst">\&quot;</span>http://cn-qinqimaifang-uat.oss-cn-hangzhou.aliyuncs.com/img/specialist/upload/spcetiicwlz1v_54e2e00fa8a6faf66168571654dbfee2.jpg<span class="subst">\&quot;</span>&gt;&lt;br/&gt;&lt;br/&gt;&lt;span style=<span class="subst">\&quot;</span>color:#333;font-size:15px;<span class="subst">\&quot;</span>&gt;百度:&lt;a href=<span class="subst">\&quot;</span>http://www.baidu.com.cn<span class="subst">\&quot;</span>&gt;my testlink&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span style=<span class="subst">\&quot;</span>color:#333;font-size:15px;<span class="subst">\&quot;</span>&gt;电话：&lt;a href=<span class="subst">\&quot;</span>tel:4008001234<span class="subst">\&quot;</span>&gt;my phoneNum&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span style=<span class="subst">\&quot;</span>color:#333;font-size:15px;<span class="subst">\&quot;</span>&gt;我邮箱:&lt;a href=<span class="subst">\&quot;</span>mailto:dreamcoffeezs@163.com<span class="subst">\&quot;</span>&gt;my mail&lt;/a&gt;&lt;/span&gt;&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>关于<code>DTCoreText</code>，我们主要用到它的三个控件，分别是<code>DTAttributedLabel</code>，<code>DTAttributedTextView</code>和<code>DTAttributedTextCell</code>，下面对它们的使用进行具体说明。</p>
<h4 id="四、使用DTAttributedLabel"><a href="#四、使用DTAttributedLabel" class="headerlink" title="四、使用DTAttributedLabel"></a>四、使用DTAttributedLabel</h4><p>顾名思义，我们会把<code>DTAttributedLabel</code>当做一个<code>UILabel</code>来使用，但事实上<code>DTAttributedLabel</code>并不属于<code>UILabel</code>的子类，下面针对<code>DTAttributedLabel</code>使用的三个问题进行介绍。</p>
<h5 id="1-显示基本文本"><a href="#1-显示基本文本" class="headerlink" title="1.显示基本文本"></a>1.显示基本文本</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建DTAttributedLabel</span></span><br><span class="line">_attributedLabel <span class="operator">=</span> [[<span class="type">DTAttributedLabel</span> alloc] initWithFrame:<span class="type">CGRectZero</span>];</span><br><span class="line">_attributedLabel.delegate <span class="operator">=</span> <span class="keyword">self</span>;</span><br><span class="line">[<span class="keyword">self</span>.view addSubview:<span class="keyword">self</span>.attributedLabel];</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.Html转化富文本</span></span><br><span class="line"><span class="type">NSData</span> <span class="operator">*</span>data <span class="operator">=</span> [_html dataUsingEncoding:<span class="type">NSUTF8StringEncoding</span>];</span><br><span class="line"><span class="type">NSAttributedString</span> <span class="operator">*</span>attributedString <span class="operator">=</span> [[<span class="type">NSAttributedString</span> alloc] initWithHTMLData:data documentAttributes:<span class="type">NULL</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.计算Frame</span></span><br><span class="line"><span class="comment">//预设一个最大的Frame,限宽不限高，方便以后计算布局</span></span><br><span class="line">_viewMaxRect <span class="operator">=</span>  <span class="type">CGRectMake</span>(<span class="number">15</span>, <span class="number">15</span>, <span class="type">ZSToolScreenWidth</span> <span class="operator">-</span> <span class="number">15</span><span class="operator">*</span><span class="number">2</span>, <span class="type">CGFLOAT_HEIGHT_UNKNOWN</span>);        </span><br><span class="line"><span class="type">DTCoreTextLayouter</span> <span class="operator">*</span>layouter <span class="operator">=</span> [[<span class="type">DTCoreTextLayouter</span> alloc] initWithAttributedString:attributedString];</span><br><span class="line"><span class="type">NSRange</span> entireStringRange <span class="operator">=</span> <span class="type">NSMakeRange</span>(<span class="number">0</span>, [attributedString length]);</span><br><span class="line"><span class="type">DTCoreTextLayoutFrame</span> <span class="operator">*</span>layoutFrame <span class="operator">=</span> [layouter layoutFrameWithRect:_viewMaxRect range:entireStringRange];</span><br><span class="line"><span class="type">CGSize</span> textSize <span class="operator">=</span> [layoutFrame frame].size;</span><br><span class="line"><span class="keyword">self</span>.attributedLabel.frame <span class="operator">=</span> <span class="type">CGRectMake</span>(_viewMaxRect.origin.x, _viewMaxRect.origin.y, _viewMaxRect.size.width, textSize.height);</span><br><span class="line">  </span><br><span class="line"><span class="comment">//4.设置富文本</span></span><br><span class="line"><span class="keyword">self</span>.attributedLabel.attributedString <span class="operator">=</span> [<span class="keyword">self</span> getAttributedStringWithHtml:<span class="keyword">self</span>.html];</span><br></pre></td></tr></table></figure>

<h5 id="2-显示图片"><a href="#2-显示图片" class="headerlink" title="2.显示图片"></a>2.显示图片</h5><p>既然是富文本，<code>DTAttributedLabel</code>也会显示图片。但是如果我们的<code>Html</code>字符串里图片链接没有包含大小，图片并不能正常显示。为了显示图片我们需要懒加载获取宽高再刷新显示，这就需要用到<code>DTAttributedLabel</code>的代理方法如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark <span class="operator">-</span> <span class="type">Delegate：DTAttributedTextContentViewDelegate</span></span><br><span class="line"><span class="comment">//DTCoretText在解析Html的时候，如果遇到网络图片会插入一个占位符</span></span><br><span class="line"><span class="comment">//对于图片类型(DTImageTextAttachmentd)的占位符，我们使用DTLazyImageView来显示</span></span><br><span class="line"><span class="operator">-</span> (<span class="type">UIView</span> <span class="operator">*</span>)attributedTextContentView:(<span class="type">DTAttributedTextContentView</span> <span class="operator">*</span>)attributedTextContentView viewForAttachment:(<span class="type">DTTextAttachment</span> <span class="operator">*</span>)attachment frame:(<span class="type">CGRect</span>)frame&#123;</span><br><span class="line">    <span class="keyword">if</span>([attachment isKindOfClass:[<span class="type">DTImageTextAttachment</span> <span class="keyword">class</span>]])&#123;</span><br><span class="line">        <span class="type">NSString</span> <span class="operator">*</span>imageURL <span class="operator">=</span> [<span class="type">NSString</span> stringWithFormat:@<span class="string">&quot;%@&quot;</span>, attachment.contentURL];</span><br><span class="line">        <span class="type">DTLazyImageView</span> <span class="operator">*</span>imageView <span class="operator">=</span> [[<span class="type">DTLazyImageView</span> alloc] initWithFrame:frame];</span><br><span class="line">        imageView.delegate <span class="operator">=</span> <span class="keyword">self</span>;<span class="comment">//图片懒加载代理</span></span><br><span class="line">        imageView.contentMode <span class="operator">=</span> <span class="type">UIViewContentModeScaleAspectFit</span>;</span><br><span class="line">        imageView.image <span class="operator">=</span> [(<span class="type">DTImageTextAttachment</span> <span class="operator">*</span>)attachment image];</span><br><span class="line">        imageView.url <span class="operator">=</span> attachment.contentURL;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理gif图片</span></span><br><span class="line">        <span class="keyword">if</span> ([imageURL containsString:@<span class="string">&quot;gif&quot;</span>]) &#123;</span><br><span class="line">           dispatch_async(dispatch_get_global_queue(<span class="type">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>, <span class="number">0</span>), <span class="operator">^</span>&#123;</span><br><span class="line">                <span class="type">NSData</span> <span class="operator">*</span>gifData <span class="operator">=</span> [<span class="type">NSData</span> dataWithContentsOfURL:attachment.contentURL];</span><br><span class="line">                dispatch_async(dispatch_get_main_queue(), <span class="operator">^</span>&#123;</span><br><span class="line">                    imageView.image <span class="operator">=</span> <span class="type">DTAnimatedGIFFromData</span>(gifData);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> imageView;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark  <span class="type">Delegate：DTLazyImageViewDelegate</span></span><br><span class="line"><span class="comment">//懒加载图片代理</span></span><br><span class="line"><span class="operator">-</span> (void)lazyImageView:(<span class="type">DTLazyImageView</span> <span class="operator">*</span>)lazyImageView didChangeImageSize:(<span class="type">CGSize</span>)size &#123;</span><br><span class="line">    <span class="type">NSURL</span> <span class="operator">*</span>url <span class="operator">=</span> lazyImageView.url;</span><br><span class="line">    <span class="type">CGSize</span> imageSize <span class="operator">=</span> size;</span><br><span class="line">    <span class="type">NSPredicate</span> <span class="operator">*</span>pred <span class="operator">=</span> [<span class="type">NSPredicate</span> predicateWithFormat:@<span class="string">&quot;contentURL == %@&quot;</span>, url];</span><br><span class="line">    <span class="type">BOOL</span> didUpdate <span class="operator">=</span> <span class="type">NO</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//update all attachments that match this URL (possibly multiple images with same size)</span></span><br><span class="line">    <span class="comment">//更新所有匹配URL的占位符视图 </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">DTTextAttachment</span> <span class="operator">*</span>oneAttachment <span class="keyword">in</span> [<span class="keyword">self</span>.attributedLabel.layoutFrame textAttachmentsWithPredicate:pred])&#123;</span><br><span class="line">        <span class="comment">//update attachments that have no original size, that also sets the display size</span></span><br><span class="line">        <span class="comment">//更新没有自带尺寸的占位视图(如网络图片) </span></span><br><span class="line">        <span class="keyword">if</span> (<span class="type">CGSizeEqualToSize</span>(oneAttachment.originalSize, <span class="type">CGSizeZero</span>))&#123;</span><br><span class="line">            <span class="comment">//原始图片不带宽高，被识别后修改Html</span></span><br><span class="line">            oneAttachment.originalSize <span class="operator">=</span> imageSize;</span><br><span class="line">          <span class="comment">//使用新拿到的图片尺寸更新HTML字符串 </span></span><br><span class="line">            [<span class="keyword">self</span> configNoSizeImageView:url.absoluteString size:imageSize];</span><br><span class="line">            didUpdate <span class="operator">=</span> <span class="type">YES</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (didUpdate)&#123;    </span><br><span class="line">        <span class="comment">//重新显示富文本</span></span><br><span class="line">        <span class="type">CGSize</span> textSize <span class="operator">=</span> [<span class="keyword">self</span> getAttributedTextHeightHtml:<span class="keyword">self</span>.html with_viewMaxRect:_viewMaxRect];</span><br><span class="line">        <span class="keyword">self</span>.attributedLabel.frame <span class="operator">=</span> <span class="type">CGRectMake</span>(_viewMaxRect.origin.x, _viewMaxRect.origin.y, _viewMaxRect.size.width, textSize.height);</span><br><span class="line">        <span class="keyword">self</span>.attributedLabel.attributedString <span class="operator">=</span> [<span class="keyword">self</span> getAttributedStringWithHtml:<span class="keyword">self</span>.html];</span><br><span class="line">        <span class="keyword">self</span>.attributedLabel.layouter <span class="operator">=</span> <span class="literal">nil</span>;</span><br><span class="line">        [<span class="keyword">self</span>.attributedLabel relayoutText];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark <span class="operator">-</span> <span class="keyword">private</span> <span class="type">Methods</span></span><br><span class="line"><span class="comment">//使用得到的新图片尺寸，更新HtmlString字符串</span></span><br><span class="line"><span class="operator">-</span> (void)configNoSizeImageView:(<span class="type">NSString</span> <span class="operator">*</span>)url size:(<span class="type">CGSize</span>)size&#123;</span><br><span class="line">    <span class="comment">//_viewMaxRect是预设的最大Frame</span></span><br><span class="line">    <span class="type">CGFloat</span> imgSizeScale <span class="operator">=</span> size.height<span class="operator">/</span>size.width;</span><br><span class="line">    <span class="type">CGFloat</span> widthPx <span class="operator">=</span> _viewMaxRect.size.width;</span><br><span class="line">    <span class="type">CGFloat</span> heightPx <span class="operator">=</span> widthPx <span class="operator">*</span> imgSizeScale;</span><br><span class="line">    <span class="type">NSString</span> <span class="operator">*</span>imageInfo <span class="operator">=</span> [<span class="type">NSString</span> stringWithFormat:@<span class="string">&quot;_src=<span class="subst">\&quot;</span>%@<span class="subst">\&quot;</span>&quot;</span>,url];</span><br><span class="line">    <span class="type">NSString</span> <span class="operator">*</span>sizeString <span class="operator">=</span> [<span class="type">NSString</span> stringWithFormat:@<span class="string">&quot;style=<span class="subst">\&quot;</span>width:%.fpx; height:%.fpx;<span class="subst">\&quot;</span>&quot;</span>,widthPx,heightPx];</span><br><span class="line">    <span class="type">NSString</span> <span class="operator">*</span>newImageInfo <span class="operator">=</span> [<span class="type">NSString</span> stringWithFormat:@<span class="string">&quot;_src=<span class="subst">\&quot;</span>%@<span class="subst">\&quot;</span>%@&quot;</span>,url,sizeString];</span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span>.html containsString:imageInfo]) &#123;</span><br><span class="line">        <span class="type">NSString</span> <span class="operator">*</span>newHtml <span class="operator">=</span> [<span class="keyword">self</span>.html stringByReplacingOccurrencesOfString:imageInfo withString:newImageInfo];</span><br><span class="line">        <span class="keyword">self</span>.html <span class="operator">=</span> newHtml;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用HtmlString,和预设的Frame，计算富文本视图自适应后的高度</span></span><br><span class="line"><span class="operator">-</span> (<span class="type">CGSize</span>)getAttributedTextHeightHtml:(<span class="type">NSString</span> <span class="operator">*</span>)htmlString with_viewMaxRect:(<span class="type">CGRect</span>)_viewMaxRect&#123;</span><br><span class="line">    <span class="comment">//获取富文本</span></span><br><span class="line">    <span class="type">NSAttributedString</span> <span class="operator">*</span>attributedString <span class="operator">=</span>  [<span class="keyword">self</span> getAttributedStringWithHtml:htmlString];</span><br><span class="line">    <span class="comment">//获取布局器</span></span><br><span class="line">    <span class="type">DTCoreTextLayouter</span> <span class="operator">*</span>layouter <span class="operator">=</span> [[<span class="type">DTCoreTextLayouter</span> alloc] initWithAttributedString:attributedString];</span><br><span class="line">    <span class="type">NSRange</span> entireString <span class="operator">=</span> <span class="type">NSMakeRange</span>(<span class="number">0</span>, [attributedString length]);</span><br><span class="line">    <span class="comment">//获取Frame</span></span><br><span class="line">    <span class="type">DTCoreTextLayoutFrame</span> <span class="operator">*</span>layoutFrame <span class="operator">=</span> [layouter layoutFrameWithRect:_viewMaxRect range:entireString];</span><br><span class="line">    <span class="comment">//得到大小</span></span><br><span class="line">    <span class="type">CGSize</span> sizeNeeded <span class="operator">=</span> [layoutFrame frame].size;</span><br><span class="line">    <span class="keyword">return</span> sizeNeeded;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-响应事件"><a href="#3-响应事件" class="headerlink" title="3.响应事件"></a>3.响应事件</h5><p>如果我们希望在<code>DTAttributedLabel</code>上操作点击事件，那么对应的我们也应该在<code>Html</code>中使用超链接<code>A</code>标签。这里我们需要用到如下的代理方法如下:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">-</span> (<span class="type">UIView</span> <span class="operator">*</span>)attributedTextContentView:(<span class="type">DTAttributedTextContentView</span> <span class="operator">*</span>)attributedTextContentView</span><br><span class="line">                          viewForLink:(<span class="type">NSURL</span> <span class="operator">*</span>)url</span><br><span class="line">                           identifier:(<span class="type">NSString</span> <span class="operator">*</span>)identifier</span><br><span class="line">                                frame:(<span class="type">CGRect</span>)frame&#123;</span><br><span class="line">    <span class="comment">//此方法需要我们在这里返回一个可以点击响应的控件如Button,然后就可以很方便的处理响应事件了，其中：</span></span><br><span class="line">    <span class="comment">//url:Html中的超链接(可以根据需要设置http、tel、mailto等)</span></span><br><span class="line">    <span class="comment">//identifier:属于该视图的唯一性标识</span></span><br><span class="line">    <span class="comment">//frame:超链接字符串所在的位置,需要将自定义响应按钮设置为此Frame</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意：如果我们需要显示一些输入框之类的视图，也可以借助此方法。</strong></p>
<p>最终效果图：<br><img src="http://182.92.228.41/wp-content/uploads/dtcoretext_DTAttributedLabel_result.png" width="375" align=center/></p>
<h4 id="五、DTAttributedTextView"><a href="#五、DTAttributedTextView" class="headerlink" title="五、DTAttributedTextView"></a>五、DTAttributedTextView</h4><p>其实，<code>DTAttributedTextView</code>和<code>DTAttributedLabel</code>的用法几乎一样；</p>
<p>从其源码上就能看出，<code>DTAttributedLabel</code>继承于<code>DTAttributedTextContentView</code>的，而<code>DTAttributedTextView</code>包含<code>DTAttributedTextContentView</code>属性。可以说<code>DTAttributedTextView</code>就是借助<code>DTAttributedLabel</code>实现的视图。</p>
<p><code>DTAttributedTextView</code>是支持滑动显示的富文本视图，在使用时计算富文本的<code>Frame</code>也就没那么必要了，一般我们都会指定它的<code>Frame</code>，其在这里的用法就不累述了。</p>
<h4 id="六、DTAttributedTextCell"><a href="#六、DTAttributedTextCell" class="headerlink" title="六、DTAttributedTextCell"></a>六、DTAttributedTextCell</h4><p>如果我们需要在单元格上显示富文本，<code>DTCoretText</code>也为我们提供了特有的类来解决这个问题，那就是<code>DTAttributedTextCell</code>。通过这个单元格类，我们可以方便的设置富文本以及获取单元格高度。以下是使用<code>DTAttributedTextCell</code>显示富文本的核心代码：</p>
<h5 id="1-声明控制器内属性"><a href="#1-声明控制器内属性" class="headerlink" title="1. 声明控制器内属性"></a>1. 声明控制器内属性</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@interface</span> <span class="type">TestTableViewController</span> ()<span class="operator">&lt;</span><span class="type">UITableViewDataSource</span>,<span class="type">UITableViewDelegate</span>,<span class="type">DTAttributedTextContentViewDelegate</span>,<span class="type">DTLazyImageViewDelegate</span><span class="operator">&gt;</span></span><br><span class="line"><span class="meta">@property</span>(nonatomic,strong)<span class="type">UITableView</span> <span class="operator">*</span>tableView;</span><br><span class="line"><span class="comment">//普通单元格与富文本单元格</span></span><br><span class="line"><span class="meta">@property</span> (nonatomic, copy) <span class="type">NSString</span> <span class="operator">*</span>cellID_Normal;</span><br><span class="line"><span class="meta">@property</span> (nonatomic, copy) <span class="type">NSString</span> <span class="operator">*</span>cellID_DTCoreText;</span><br><span class="line"><span class="comment">//类似tabelView的缓冲池，用于存放图片大小</span></span><br><span class="line"><span class="meta">@property</span> (nonatomic, strong) <span class="type">NSCache</span> <span class="operator">*</span>imageSizeCache;</span><br><span class="line"><span class="meta">@property</span> (nonatomic,strong)<span class="type">NSCache</span> <span class="operator">*</span>cellCache;</span><br><span class="line"><span class="comment">//表视图数据源</span></span><br><span class="line"><span class="meta">@property</span> (nonatomic, strong) <span class="type">NSArray</span>  <span class="operator">*</span>dataSource;</span><br><span class="line"><span class="comment">//当前表视图是否在滑动</span></span><br><span class="line"><span class="meta">@property</span> (nonatomic,assign)<span class="type">BOOL</span> isScrolling;</span><br><span class="line"></span><br><span class="line"><span class="meta">@end</span></span><br></pre></td></tr></table></figure>

<h5 id="2-表视图代理方法返回单元格及其高度"><a href="#2-表视图代理方法返回单元格及其高度" class="headerlink" title="2.表视图代理方法返回单元格及其高度"></a>2.表视图代理方法返回单元格及其高度</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代理方法：返回单元格</span></span><br><span class="line"><span class="operator">-</span> (<span class="type">UITableViewCell</span> <span class="operator">*</span>)tableView:(<span class="type">UITableView</span> <span class="operator">*</span>)tableView cellForRowAtIndexPath:(<span class="type">NSIndexPath</span> <span class="operator">*</span>)indexPath&#123;</span><br><span class="line">    <span class="keyword">switch</span> (indexPath.section) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:&#123;</span><br><span class="line">            <span class="comment">//普通单元格</span></span><br><span class="line">            <span class="type">UITableViewCell</span> <span class="operator">*</span>cell <span class="operator">=</span> [tableView dequeueReusableCellWithIdentifier:_cellID_Normal];</span><br><span class="line">            cell.textLabel.text <span class="operator">=</span> <span class="keyword">self</span>.dataSource[indexPath.section][indexPath.row];</span><br><span class="line">            <span class="keyword">return</span> cell;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:&#123;</span><br><span class="line">            <span class="comment">//自定义方法，创建富文本类型的单元格</span></span><br><span class="line">            <span class="type">ZSDTCoreTextCell</span> <span class="operator">*</span>dtCell <span class="operator">=</span> (<span class="type">ZSDTCoreTextCell</span> <span class="operator">*</span>) [<span class="keyword">self</span> tableView:tableView prepareCellForIndexPath:indexPath];</span><br><span class="line">            <span class="keyword">return</span> dtCell;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回单元格高度</span></span><br><span class="line"><span class="operator">-</span> (<span class="type">CGFloat</span>)tableView:(<span class="type">UITableView</span> <span class="operator">*</span>)tableView heightForRowAtIndexPath:(nonnull <span class="type">NSIndexPath</span> <span class="operator">*</span>)indexPath&#123;</span><br><span class="line">    <span class="keyword">switch</span> (indexPath.section) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">50</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:&#123;</span><br><span class="line">          <span class="comment">//返回富文本类型单元格的方法</span></span><br><span class="line">            <span class="type">ZSDTCoreTextCell</span> <span class="operator">*</span>cell <span class="operator">=</span> (<span class="type">ZSDTCoreTextCell</span> <span class="operator">*</span>)[<span class="keyword">self</span> tableView:tableView prepareCellForIndexPath:indexPath];</span><br><span class="line">            <span class="keyword">return</span> [cell requiredRowHeightInTableView:tableView];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-懒加载处理无宽高属性的图片"><a href="#3-懒加载处理无宽高属性的图片" class="headerlink" title="3.懒加载处理无宽高属性的图片"></a>3.懒加载处理无宽高属性的图片</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark <span class="operator">-</span> <span class="type">DTAttributedTextContentViewDelegate</span></span><br><span class="line"><span class="comment">//对于没有在Html标签里设置宽高的图片，在这里为其设置占位</span></span><br><span class="line"><span class="operator">-</span> (<span class="type">UIView</span> <span class="operator">*</span>)attributedTextContentView:(<span class="type">DTAttributedTextContentView</span> <span class="operator">*</span>)attributedTextContentView viewForAttachment:(<span class="type">DTTextAttachment</span> <span class="operator">*</span>)attachment frame:(<span class="type">CGRect</span>)frame&#123;</span><br><span class="line">    <span class="keyword">if</span>([attachment isKindOfClass:[<span class="type">DTImageTextAttachment</span> <span class="keyword">class</span>]])&#123;</span><br><span class="line">        <span class="comment">//自定义的ZSDTLazyImageView继承于DTLazyImageView，增加了一个属性textContentView</span></span><br><span class="line">        <span class="comment">//用于更新图片大小</span></span><br><span class="line">        <span class="type">ZSDTLazyImageView</span> <span class="operator">*</span>imageView <span class="operator">=</span> [[<span class="type">ZSDTLazyImageView</span> alloc] initWithFrame:frame];</span><br><span class="line">        imageView.delegate <span class="operator">=</span> <span class="keyword">self</span>;</span><br><span class="line">        imageView.image <span class="operator">=</span> [(<span class="type">DTImageTextAttachment</span> <span class="operator">*</span>)attachment image];</span><br><span class="line">        imageView.textContentView <span class="operator">=</span> attributedTextContentView;</span><br><span class="line">        imageView.url <span class="operator">=</span> attachment.contentURL;</span><br><span class="line">        <span class="keyword">return</span> imageView;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//对于无宽高的图片懒加载，缓存记录其大小,然后执行表视图更新</span></span><br><span class="line"><span class="operator">-</span> (void)lazyImageView:(<span class="type">ZSDTLazyImageView</span> <span class="operator">*</span>)lazyImageView didChangeImageSize:(<span class="type">CGSize</span>)size&#123;</span><br><span class="line">    <span class="type">BOOL</span> needUpdate <span class="operator">=</span> <span class="type">NO</span>;</span><br><span class="line">    <span class="type">NSURL</span> <span class="operator">*</span>url <span class="operator">=</span> lazyImageView.url;</span><br><span class="line">    <span class="type">NSPredicate</span> <span class="operator">*</span>pred <span class="operator">=</span> [<span class="type">NSPredicate</span> predicateWithFormat:@<span class="string">&quot;contentURL == %@&quot;</span>, url];</span><br><span class="line">    <span class="comment">/* update all attachments that matchin this URL (possibly multiple</span></span><br><span class="line"><span class="comment">        images with same size)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">DTTextAttachment</span> <span class="operator">*</span>oneAttachment <span class="keyword">in</span> [lazyImageView.textContentView.layoutFrame textAttachmentsWithPredicate:pred])&#123;</span><br><span class="line">        <span class="comment">// update attachments that have no original size, that also sets the display size</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="type">CGSizeEqualToSize</span>(oneAttachment.originalSize, <span class="type">CGSizeZero</span>))&#123;</span><br><span class="line">            oneAttachment.originalSize <span class="operator">=</span> size;</span><br><span class="line">            <span class="type">NSValue</span> <span class="operator">*</span>sizeValue <span class="operator">=</span> [_imageSizeCache objectForKey:oneAttachment.contentURL];</span><br><span class="line">            <span class="keyword">if</span> (<span class="operator">!</span>sizeValue) &#123;</span><br><span class="line">                <span class="comment">//将图片大小记录在缓存中，但是这种图片的原始尺寸可能很大，所以这里设置图片的最大宽</span></span><br><span class="line">                <span class="comment">//并且计算高</span></span><br><span class="line">                <span class="type">CGFloat</span> aspectRatio <span class="operator">=</span> size.height <span class="operator">/</span> size.width;</span><br><span class="line">                <span class="type">CGFloat</span> width <span class="operator">=</span> <span class="type">ZSToolScreenWidth</span> <span class="operator">-</span> <span class="number">15</span><span class="operator">*</span><span class="number">2</span>;</span><br><span class="line">                <span class="type">CGFloat</span> height <span class="operator">=</span> width <span class="operator">*</span> aspectRatio;</span><br><span class="line">                <span class="type">CGSize</span> newSize <span class="operator">=</span> <span class="type">CGSizeMake</span>(width, height);</span><br><span class="line">                [_imageSizeCache setObject:[<span class="type">NSValue</span> valueWithCGSize:newSize]forKey:url];</span><br><span class="line">            &#125;</span><br><span class="line">            needUpdate <span class="operator">=</span> <span class="type">YES</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (needUpdate)&#123;</span><br><span class="line">        <span class="comment">//有新的图片尺寸被缓存记录的时候，需要刷新表视图</span></span><br><span class="line">        [<span class="keyword">self</span> reloadCurrentCell];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-创建富文本单元格的方法"><a href="#4-创建富文本单元格的方法" class="headerlink" title="4.创建富文本单元格的方法"></a>4.创建富文本单元格的方法</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark <span class="operator">-</span> <span class="keyword">private</span> <span class="type">Methods</span></span><br><span class="line"><span class="comment">//创建富文本单元格，并更新单元格上的数据</span></span><br><span class="line"><span class="comment">//ZSDTCoreTextCell是自定义的继承于DTCoreTextCell的单元格</span></span><br><span class="line"><span class="operator">-</span> (<span class="type">ZSDTCoreTextCell</span> <span class="operator">*</span>)tableView:(<span class="type">UITableView</span> <span class="operator">*</span>)tableView prepareCellForIndexPath:(<span class="type">NSIndexPath</span> <span class="operator">*</span>)indexPath&#123;</span><br><span class="line">    <span class="type">NSString</span> <span class="operator">*</span>key <span class="operator">=</span> [<span class="type">NSString</span> stringWithFormat:@<span class="string">&quot;dtCoreTextCellKEY%ld-%ld&quot;</span>, (long)indexPath.section, (long)indexPath.row];</span><br><span class="line">    <span class="type">ZSDTCoreTextCell</span> <span class="operator">*</span>cell <span class="operator">=</span> [_cellCache objectForKey:key];</span><br><span class="line">    <span class="keyword">if</span> (<span class="operator">!</span>cell)&#123;</span><br><span class="line">        cell <span class="operator">=</span> [[<span class="type">ZSDTCoreTextCell</span> alloc] initWithStyle:<span class="type">UITableViewCellStyleDefault</span> reuseIdentifier:_cellID_DTCoreText];</span><br><span class="line">        cell.attributedTextContextView.edgeInsets <span class="operator">=</span> <span class="type">UIEdgeInsetsMake</span>(<span class="number">0</span>, <span class="number">15</span>, <span class="number">0</span>, <span class="number">15</span>);</span><br><span class="line">        [cell setSelectionStyle:<span class="type">UITableViewCellSelectionStyleNone</span>];</span><br><span class="line">        cell.accessoryType <span class="operator">=</span> <span class="type">UITableViewCellAccessoryNone</span>;</span><br><span class="line">        cell.hasFixedRowHeight <span class="operator">=</span> <span class="type">NO</span>;</span><br><span class="line">        cell.textDelegate <span class="operator">=</span> <span class="keyword">self</span>;</span><br><span class="line">        cell.attributedTextContextView.shouldDrawImages <span class="operator">=</span> <span class="type">YES</span>;</span><br><span class="line">        <span class="comment">//记录在缓存中</span></span><br><span class="line">        [_cellCache setObject:cell forKey:key];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.设置数据</span></span><br><span class="line">    <span class="comment">//2.1为富文本单元格设置Html数据</span></span><br><span class="line">    [cell setHTMLString:<span class="keyword">self</span>.dataSource[indexPath.section][indexPath.row]];</span><br><span class="line">    <span class="comment">//2.2为每个占位图(图片)设置大小，并更新</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">DTTextAttachment</span> <span class="operator">*</span>oneAttachment <span class="keyword">in</span> cell.attributedTextContextView.layoutFrame.textAttachments) &#123;</span><br><span class="line">        <span class="type">NSValue</span> <span class="operator">*</span>sizeValue <span class="operator">=</span> [_imageSizeCache objectForKey:oneAttachment.contentURL];</span><br><span class="line">        <span class="keyword">if</span> (sizeValue) &#123;</span><br><span class="line">            cell.attributedTextContextView.layouter<span class="operator">=</span><span class="literal">nil</span>;</span><br><span class="line">            oneAttachment.displaySize <span class="operator">=</span> [sizeValue <span class="type">CGSizeValue</span>];</span><br><span class="line">            [cell.attributedTextContextView relayoutText];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    [cell.attributedTextContextView relayoutText];</span><br><span class="line">    <span class="keyword">return</span> cell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-处理表视图的刷新"><a href="#5-处理表视图的刷新" class="headerlink" title="5.处理表视图的刷新"></a>5.处理表视图的刷新</h5><p>如果当前表视图在滑动就不执行刷新，因为滑动时候会自动调用表视图的刷新方法</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">-</span> (void)reloadCurrentCell&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.isScrolling) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果当前表视图没有在滑动，就手动刷新当前在屏幕显示的单元格</span></span><br><span class="line">    <span class="type">NSArray</span> <span class="operator">*</span>indexPaths <span class="operator">=</span> [<span class="keyword">self</span>.tableView indexPathsForVisibleRows];</span><br><span class="line">    <span class="keyword">if</span>(indexPaths)&#123;</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), <span class="operator">^</span>&#123;</span><br><span class="line">            [<span class="keyword">self</span>.tableView reloadRowsAtIndexPaths:indexPaths withRowAnimation:<span class="type">UITableViewRowAnimationNone</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> (void)scrollViewDidEndScrollingAnimation:(<span class="type">UIScrollView</span> <span class="operator">*</span>)scrollView&#123;</span><br><span class="line">    _isScrolling <span class="operator">=</span> <span class="type">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> (void)scrollViewDidScroll:(<span class="type">UIScrollView</span> <span class="operator">*</span>)scrollView&#123;</span><br><span class="line">    _isScrolling <span class="operator">=</span> <span class="type">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="6-set方法创建表视图与数据源"><a href="#6-set方法创建表视图与数据源" class="headerlink" title="6.set方法创建表视图与数据源"></a>6.set方法创建表视图与数据源</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark <span class="operator">-</span> <span class="keyword">set</span><span class="operator">/</span><span class="keyword">get</span>方法</span><br><span class="line"><span class="operator">-</span> (<span class="type">UITableView</span> <span class="operator">*</span>)tableView&#123;</span><br><span class="line">    <span class="keyword">if</span> (_tableView <span class="operator">==</span> <span class="literal">nil</span>) &#123;</span><br><span class="line">        _tableView <span class="operator">=</span> [[<span class="type">UITableView</span>  alloc] initWithFrame:<span class="type">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="type">ZSToolScreenWidth</span>, <span class="type">ZSToolScreenHeight</span><span class="operator">-</span><span class="number">64</span>) style:<span class="type">UITableViewStylePlain</span>];</span><br><span class="line">        _tableView.dataSource <span class="operator">=</span> <span class="keyword">self</span>;</span><br><span class="line">        _tableView.delegate <span class="operator">=</span> <span class="keyword">self</span>;</span><br><span class="line">        [_tableView registerClass:[<span class="type">UITableViewCell</span> <span class="keyword">class</span>] <span class="title class_">forCellReuseIdentifier</span>:<span class="title class_">_cellID_Normal</span>];</span><br><span class="line">        //[<span class="title class_">_tableView</span> <span class="title class_">registerClass</span>:[<span class="title class_">ZSDTCoreTextCell</span> <span class="title class_">class</span>] <span class="title class_">forCellReuseIdentifier</span>:<span class="title class_">_cellID_DTCoreText</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title class_">return</span> <span class="title class_">_tableView</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="title class_">NSArray</span> *)<span class="title class_">dataSource</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(_dataSource <span class="operator">==</span> <span class="literal">nil</span>)&#123;</span><br><span class="line">        <span class="type">NSMutableArray</span> <span class="operator">*</span>noramDataArray <span class="operator">=</span> @[].mutableCopy;</span><br><span class="line">        <span class="type">NSMutableArray</span> <span class="operator">*</span>htmlDataArray <span class="operator">=</span> @[].mutableCopy;</span><br><span class="line">        <span class="type">NSArray</span> <span class="operator">*</span>images <span class="operator">=</span> @[@<span class="string">&quot;https://i0.hdslb.com/bfs/archive/d5ad3cf95d32f3d2f2e3471a39120237200d84d8.jpg&quot;</span>,</span><br><span class="line">                           @<span class="string">&quot;https://i0.hdslb.com/bfs/archive/71d2fed927d9351e759f408ca7d66c556c37a6b4.jpg&quot;</span>,</span><br><span class="line">                           @<span class="string">&quot;https://i0.hdslb.com/bfs/archive/7f520b31b67cd5d89dd30b61b40711327bb00288.png&quot;</span>,</span><br><span class="line">                           @<span class="string">&quot;https://i0.hdslb.com/bfs/archive/6edbe81bf74c106087ad139aca169d6e8d9d963b.jpg&quot;</span>,</span><br><span class="line">                           @<span class="string">&quot;https://i0.hdslb.com/bfs/archive/805aa8f7ae722fcc277f425bb9927e29ec1d2468.jpg&quot;</span>,</span><br><span class="line">                           @<span class="string">&quot;https://i0.hdslb.com/bfs/archive/a7c61d94c583363a970d2a2e339eea97f8f32317.jpg&quot;</span>,</span><br><span class="line">                           @<span class="string">&quot;https://i0.hdslb.com/bfs/archive/b447ee1fd63b4cf6f4465a5621cc12898867d26b.jpg&quot;</span>];</span><br><span class="line">        <span class="keyword">for</span>(int i <span class="operator">=</span> <span class="number">0</span>;i<span class="operator">&lt;</span><span class="number">1000</span>;i<span class="operator">++</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i <span class="operator">&lt;</span><span class="number">6</span>)&#123;</span><br><span class="line">                [noramDataArray addObject:[<span class="type">NSString</span> stringWithFormat:@<span class="string">&quot;测试普通单元格:%d&quot;</span>,i]];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//这里提供的Html图片链接，没有宽高属性，代码中已经演示了如何处理</span></span><br><span class="line">            int k <span class="operator">=</span> i <span class="operator">%</span> <span class="number">6</span>;</span><br><span class="line">            <span class="type">NSString</span> <span class="operator">*</span>htmlString <span class="operator">=</span>[<span class="type">NSString</span> stringWithFormat:@<span class="string">&quot;&lt;span style=<span class="subst">\&quot;</span>color:#333;font-size:15px;<span class="subst">\&quot;</span>&gt;&lt;strong&gt;测试富文本单元格%d：&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span style=<span class="subst">\&quot;</span>color:#333;font-size:15px;<span class="subst">\&quot;</span>&gt;记住！砍价是由你自己先砍，砍不动时再由砍价师继续砍；由砍价师多砍下的部分，才按照下列标准收费：&lt;/span&gt;&lt;br/&gt;&lt;span style=<span class="subst">\&quot;</span>color:#333;font-size:15px;<span class="subst">\&quot;</span>&gt;&lt;img src=%@ _src=%@&gt;&lt;/span&gt;&quot;</span>,i,images[k],images[k]];</span><br><span class="line">            [htmlDataArray addObject:htmlString];</span><br><span class="line">        &#125;</span><br><span class="line">        _dataSource <span class="operator">=</span> @[noramDataArray,htmlDataArray];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _dataSource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>DTAttributedTextCell</code>的最终效果图如下：<br><img src="http://182.92.228.41/wp-content/uploads/dtcoretext_DTAttributedTextCell_result.png" width="375" align=center/></p>
<h4 id="七、可能遇到的错误"><a href="#七、可能遇到的错误" class="headerlink" title="七、可能遇到的错误"></a>七、可能遇到的错误</h4><p>原本上，在项目中使用只需将<code>Release-iphones</code>的<code>DTCoreText.framework</code>和<code>DTFoundation.framework</code>中拖入工程就可以使用了。</p>
<p>然而，我在编译工程却会遇到这样一个错误：<code>&quot;image not found&quot;</code></p>
<p>解决方法如下图：<br><img src="http://182.92.228.41/wp-content/uploads/dtcoretext_image_not_found.png" width="600" align=center/></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wuyubeichen.github.io/2019/02/24/iOS%E5%BC%80%E5%8F%91-%E5%B1%8F%E5%B9%95%E6%97%8B%E8%BD%AC%E9%80%82%E9%85%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Author">
      <meta itemprop="description" content="iOS Developer, Beijing China">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="梧雨北辰的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/02/24/iOS%E5%BC%80%E5%8F%91-%E5%B1%8F%E5%B9%95%E6%97%8B%E8%BD%AC%E9%80%82%E9%85%8D/" class="post-title-link" itemprop="url">iOS开发-屏幕旋转适配</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-02-24 14:58:39" itemprop="dateCreated datePublished" datetime="2019-02-24T14:58:39+08:00">2019-02-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-29 09:39:32" itemprop="dateModified" datetime="2022-08-29T09:39:32+08:00">2022-08-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">iOS开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>前段时间抽空总结了一下<code>iOS</code>视频播放的基本用法，发现这其中还有一个我们无法绕过的问题，那就是播放界面的旋转与适配。的确，视频播放与游戏类型的<code>App</code>经常会遇到这个的问题。由于至今接手的项目中不常涉及这块知识疏于总结，在搜索了一些资料后也发现都很散乱，所以决定在这里重新整理一下。</p>
<p><strong>主要内容：</strong></p>
<ol>
<li>最让人纠结的三种枚举 </li>
<li>两种屏幕旋转的触发方式 </li>
<li>屏幕旋转控制的优先级 </li>
<li>开启屏幕旋转的全局权限 </li>
<li>开启屏幕旋转的局部权限(视图控制器) </li>
<li>实现需求：项目主要界面竖屏，部分界面横屏 </li>
<li>默认横屏无效的问题 </li>
<li>关于旋转后的适配问题 </li>
<li><code>APP</code>启动即全屏</li>
</ol>
<h4 id="一、最让人纠结的三种枚举"><a href="#一、最让人纠结的三种枚举" class="headerlink" title="一、最让人纠结的三种枚举"></a>一、最让人纠结的三种枚举</h4><p>刚开始接触屏幕旋转这块知识的时候，最让人抓狂的也许就是三种相关的枚举类型了，它们就是：</p>
<ol>
<li><code>UIDeviceOrientation</code></li>
<li><code>UIInterfaceOrientation</code></li>
<li><code>UIInterfaceOrientationMask</code></li>
</ol>
<h5 id="1-设备方向UIDeviceOrientation"><a href="#1-设备方向UIDeviceOrientation" class="headerlink" title="1.设备方向UIDeviceOrientation"></a>1.设备方向UIDeviceOrientation</h5><p><code>UIDeviceOrientation</code>：</p>
<ol>
<li>这是硬件设备(<code>iPhone</code>、<code>iPad</code>等)本身的当前旋转方向，共有<code>7</code>种(包括一种未知的情况)；</li>
<li>设备方向只能取值，不能设置；</li>
<li>判断设备的方向是以<code>Home</code>键的位置作为参照的；</li>
</ol>
<p><code>UIDeviceOrientation</code>在源码中的定义如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Portrait 表示纵向，Landscape 表示横向。</span></span><br><span class="line">typedef <span class="type">NS_ENUM</span>(<span class="type">NSInteger</span>, <span class="type">UIDeviceOrientation</span>) &#123;</span><br><span class="line"></span><br><span class="line">     <span class="type">UIDeviceOrientationUnknown</span>,</span><br><span class="line">     <span class="type">UIDeviceOrientationPortrait</span>,           <span class="comment">// Device oriented vertically, home button on the bottom</span></span><br><span class="line">     <span class="type">UIDeviceOrientationPortraitUpsideDown</span>, <span class="comment">// Device oriented vertically, home button on the top</span></span><br><span class="line">     <span class="type">UIDeviceOrientationLandscapeLeft</span>,      <span class="comment">// Device oriented horizontally, home button on the right</span></span><br><span class="line">     <span class="type">UIDeviceOrientationLandscapeRight</span>,     <span class="comment">// Device oriented horizontally, home button on the left</span></span><br><span class="line">     <span class="type">UIDeviceOrientationFaceUp</span>,             <span class="comment">// Device oriented flat, face up</span></span><br><span class="line">     <span class="type">UIDeviceOrientationFaceDown</span>            <span class="comment">// Device oriented flat, face down</span></span><br><span class="line">   &#125; __TVOS_PROHIBITED;</span><br></pre></td></tr></table></figure>
<p>获取设备当前设备的旋转方向使用：<code>[UIDevice currentDevice].orientation</code>；</p>
<p>为了监测设备方向的变化，可以在<code>Appdelegate</code>文件中使用通知如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="type">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span> selector:<span class="meta">@selector</span>(onDeviceOrientationDidChange)</span><br><span class="line">                     name:<span class="type">UIDeviceOrientationDidChangeNotification</span></span><br><span class="line">                                               object:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">[[<span class="type">UIDevice</span> currentDevice] beginGeneratingDeviceOrientationNotifications];</span><br><span class="line"></span><br><span class="line"> <span class="operator">-</span> (<span class="type">BOOL</span>)onDeviceOrientationDidChange&#123;</span><br><span class="line">    <span class="comment">//获取当前设备Device</span></span><br><span class="line">    <span class="type">UIDevice</span> <span class="operator">*</span>device <span class="operator">=</span> [<span class="type">UIDevice</span> currentDevice] ;</span><br><span class="line">    <span class="comment">//识别当前设备的旋转方向</span></span><br><span class="line">    <span class="keyword">switch</span> (device.orientation) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">UIDeviceOrientationFaceUp</span>:</span><br><span class="line">            <span class="type">NSLog</span>(@<span class="string">&quot;屏幕幕朝上平躺&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">UIDeviceOrientationFaceDown</span>:</span><br><span class="line">            <span class="type">NSLog</span>(@<span class="string">&quot;屏幕朝下平躺&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">UIDeviceOrientationUnknown</span>:</span><br><span class="line">            <span class="comment">//系统当前无法识别设备朝向，可能是倾斜</span></span><br><span class="line">            <span class="type">NSLog</span>(@<span class="string">&quot;未知方向&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">UIDeviceOrientationLandscapeLeft</span>:</span><br><span class="line">            <span class="type">NSLog</span>(@<span class="string">&quot;屏幕向左橫置&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">UIDeviceOrientationLandscapeRight</span>:</span><br><span class="line">            <span class="type">NSLog</span>(@<span class="string">&quot;屏幕向右橫置&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">UIDeviceOrientationPortrait</span>:</span><br><span class="line">            <span class="type">NSLog</span>(@<span class="string">&quot;屏幕直立&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">UIDeviceOrientationPortraitUpsideDown</span>:</span><br><span class="line">            <span class="type">NSLog</span>(@<span class="string">&quot;屏幕直立，上下顛倒&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="type">NSLog</span>(@<span class="string">&quot;無法识别&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-页面方向UIInterfaceOrientation"><a href="#2-页面方向UIInterfaceOrientation" class="headerlink" title="2.页面方向UIInterfaceOrientation"></a>2.页面方向UIInterfaceOrientation</h5><p><code>UIInterfaceOrientation</code>是开发的程序界面的当前旋转方向，它是可以设置的；</p>
<p><code>UIInterfaceOrientation</code>的源码定义如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// Note that UIInterfaceOrientationLandscapeLeft is equal to UIDeviceOrientationLandscapeRight (and vice versa).</span></span><br><span class="line">    <span class="comment">// This is because rotating the device to the left requires rotating the content to the right.</span></span><br><span class="line">    typedef <span class="type">NS_ENUM</span>(<span class="type">NSInteger</span>, <span class="type">UIInterfaceOrientation</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">UIInterfaceOrientationUnknown</span>               <span class="operator">=</span> <span class="type">UIDeviceOrientationUnknown</span>,</span><br><span class="line">        <span class="type">UIInterfaceOrientationPortrait</span>              <span class="operator">=</span> <span class="type">UIDeviceOrientationPortrait</span>,</span><br><span class="line">        <span class="type">UIInterfaceOrientationPortraitUpsideDown</span>    <span class="operator">=</span> <span class="type">UIDeviceOrientationPortraitUpsideDown</span>,</span><br><span class="line">        <span class="type">UIInterfaceOrientationLandscapeLeft</span>         <span class="operator">=</span> <span class="type">UIDeviceOrientationLandscapeRight</span>,</span><br><span class="line">        <span class="type">UIInterfaceOrientationLandscapeRight</span>        <span class="operator">=</span> <span class="type">UIDeviceOrientationLandscapeLeft</span></span><br><span class="line">    &#125; __TVOS_PROHIBITED;</span><br></pre></td></tr></table></figure>
<p>值得注意的两个枚举：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UIInterfaceOrientationLandscapeLeft</span> <span class="operator">=</span> <span class="type">UIDeviceOrientationLandscapeRight</span>, </span><br><span class="line"><span class="type">UIInterfaceOrientationLandscapeRight</span> <span class="operator">=</span> <span class="type">UIDeviceOrientationLandscapeLeft</span></span><br></pre></td></tr></table></figure>
<p>我们可以发现<code>设备方向</code>与<code>页面方向</code>的枚举值大多是可以对应上的。只有左右旋转的时候是<code>UIInterfaceOrientationLandscapeLeft</code> 与<code>UIDeviceOrientationLandscapeRight</code>相等，<strong>反之亦然，这是因为向左旋转设备需要旋转程序界面右边的内容。</strong></p>
<h5 id="3-页面方向UIInterfaceOrientationMask"><a href="#3-页面方向UIInterfaceOrientationMask" class="headerlink" title="3.页面方向UIInterfaceOrientationMask"></a>3.页面方向UIInterfaceOrientationMask</h5><p><code>UIInterfaceOrientationMask</code>是<code>iOS6</code>之后增加的一种枚举，其源码如下:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef <span class="type">NS_OPTIONS</span>(<span class="type">NSUInteger</span>, <span class="type">UIInterfaceOrientationMask</span>) &#123;</span><br><span class="line">    <span class="type">UIInterfaceOrientationMaskPortrait</span> <span class="operator">=</span> (<span class="number">1</span> <span class="operator">&lt;&lt;</span> <span class="type">UIInterfaceOrientationPortrait</span>),</span><br><span class="line">    <span class="type">UIInterfaceOrientationMaskLandscapeLeft</span> <span class="operator">=</span> (<span class="number">1</span> <span class="operator">&lt;&lt;</span> <span class="type">UIInterfaceOrientationLandscapeLeft</span>),</span><br><span class="line">    <span class="type">UIInterfaceOrientationMaskLandscapeRight</span> <span class="operator">=</span> (<span class="number">1</span> <span class="operator">&lt;&lt;</span> <span class="type">UIInterfaceOrientationLandscapeRight</span>),</span><br><span class="line">    <span class="type">UIInterfaceOrientationMaskPortraitUpsideDown</span> <span class="operator">=</span> (<span class="number">1</span> <span class="operator">&lt;&lt;</span> <span class="type">UIInterfaceOrientationPortraitUpsideDown</span>),</span><br><span class="line">    <span class="type">UIInterfaceOrientationMaskLandscape</span> <span class="operator">=</span> (<span class="type">UIInterfaceOrientationMaskLandscapeLeft</span> <span class="operator">|</span> <span class="type">UIInterfaceOrientationMaskLandscapeRight</span>),</span><br><span class="line">    <span class="type">UIInterfaceOrientationMaskAll</span> <span class="operator">=</span> (<span class="type">UIInterfaceOrientationMaskPortrait</span> <span class="operator">|</span> <span class="type">UIInterfaceOrientationMaskLandscapeLeft</span> <span class="operator">|</span> <span class="type">UIInterfaceOrientationMaskLandscapeRight</span> <span class="operator">|</span> <span class="type">UIInterfaceOrientationMaskPortraitUpsideDown</span>),</span><br><span class="line">    <span class="type">UIInterfaceOrientationMaskAllButUpsideDown</span> <span class="operator">=</span> (<span class="type">UIInterfaceOrientationMaskPortrait</span> <span class="operator">|</span> <span class="type">UIInterfaceOrientationMaskLandscapeLeft</span> <span class="operator">|</span> <span class="type">UIInterfaceOrientationMaskLandscapeRight</span>),</span><br><span class="line">&#125; __TVOS_PROHIBITED;</span><br></pre></td></tr></table></figure>
<p>我们已经知道<code>UIDeviceOrientation</code>与<code>UIInterfaceOrientation</code>的区别在于：前者是真实的设备方向，后者是页面方向；</p>
<p>而<code>UIInterfaceOrientation</code>和<code>UIInterfaceOrientationMask</code>的区别是什么呢？其实观察源码，<strong>我们就会发现，这是一种为了支持多种UIInterfaceOrientation而定义的类型</strong>；</p>
<p>下面的示例将很好的说明这点：</p>
<p>在<code>iOS6</code>之后，控制单个界面的旋转我们通常是下面三个方法来控制：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法1</span></span><br><span class="line"><span class="operator">-</span> (<span class="type">BOOL</span>)shouldAutorotate <span class="type">NS_AVAILABLE_IOS</span>(<span class="number">6_0</span>) __TVOS_PROHIBITED;</span><br><span class="line"><span class="comment">//方法2</span></span><br><span class="line"><span class="operator">-</span> (<span class="type">UIInterfaceOrientationMask</span>)supportedInterfaceOrientations <span class="type">NS_AVAILABLE_IOS</span>(<span class="number">6_0</span>) __TVOS_PROHIBITED;</span><br><span class="line"><span class="comment">// Returns interface orientation masks.</span></span><br><span class="line"><span class="comment">//方法3</span></span><br><span class="line"><span class="operator">-</span> (<span class="type">UIInterfaceOrientation</span>)preferredInterfaceOrientationForPresentation <span class="type">NS_AVAILABLE_IOS</span>(<span class="number">6_0</span>) __TVOS_PROHIBITED;</span><br></pre></td></tr></table></figure>
<p>方法2：用于设置当前界面支持的所有方向，所以返回值是<code>UIInterfaceOrientationMask</code>，更加方便的表达支持多方向旋转的情况；</p>
<p>方法3：用于设置进入界面默认支持的方向，使用了返回值类型<code>UIInterfaceOrientation</code>，默认进入界面的方向是个确定的方向，所以使用<code>UIInterfaceOrientation</code>更适合；</p>
<h4 id="二、两种屏幕旋转的触发方式"><a href="#二、两种屏幕旋转的触发方式" class="headerlink" title="二、两种屏幕旋转的触发方式"></a>二、两种屏幕旋转的触发方式</h4><p>我们开发的<code>App</code>的，大多情况都是大多界面支持竖屏，几个特别的界面支持旋转横屏，两种界面相互切换，触发其旋转有两种情况：</p>
<h5 id="情况1：系统没有关闭自动旋转屏幕功能"><a href="#情况1：系统没有关闭自动旋转屏幕功能" class="headerlink" title="情况1：系统没有关闭自动旋转屏幕功能"></a>情况1：系统没有关闭自动旋转屏幕功能</h5><p>这种情况，支持旋转的界面跟随用户手持设备旋转方向自动旋转。我们需要在当前视图控制器中添加如下方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.决定当前界面是否开启自动转屏，如果返回NO，后面两个方法也不会被调用，只是会支持默认的方向</span></span><br><span class="line"><span class="operator">-</span> (<span class="type">BOOL</span>)shouldAutorotate &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="type">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.返回支持的旋转方向</span></span><br><span class="line"><span class="comment">//iPad设备上，默认返回值UIInterfaceOrientationMaskAllButUpSideDwon</span></span><br><span class="line"><span class="comment">//iPad设备上，默认返回值是UIInterfaceOrientationMaskAll</span></span><br><span class="line"><span class="operator">-</span> (<span class="type">UIInterfaceOrientationMask</span>)supportedInterfaceOrientations&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="type">UIInterfaceOrientationMaskAll</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.返回进入界面默认显示方向</span></span><br><span class="line"><span class="operator">-</span> (<span class="type">UIInterfaceOrientation</span>)preferredInterfaceOrientationForPresentation &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="type">UIInterfaceOrientationPortrait</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="情况2：单个界面强制旋转"><a href="#情况2：单个界面强制旋转" class="headerlink" title="情况2：单个界面强制旋转"></a>情况2：单个界面强制旋转</h5><p>在程序界面，通过点击等方式切换到横屏(尤其是视频播放的情况)，有以下两种方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法1：</span></span><br><span class="line"><span class="operator">-</span> (void)setInterfaceOrientation:(<span class="type">UIDeviceOrientation</span>)orientation &#123;</span><br><span class="line">      <span class="keyword">if</span> ([[<span class="type">UIDevice</span> currentDevice]   respondsToSelector:<span class="meta">@selector</span>(setOrientation:)]) &#123;</span><br><span class="line">          [[<span class="type">UIDevice</span> currentDevice] setValue:[<span class="type">NSNumber</span> numberWithInteger:orientation]     </span><br><span class="line">                                       forKey:@<span class="string">&quot;orientation&quot;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法2：</span></span><br><span class="line"><span class="operator">-</span> (void)setInterfaceOrientation:(<span class="type">UIInterfaceOrientation</span>)orientation &#123;</span><br><span class="line">   <span class="keyword">if</span> ([[<span class="type">UIDevice</span> currentDevice] respondsToSelector:<span class="meta">@selector</span>(setOrientation:)]) &#123;</span><br><span class="line">            <span class="type">SEL</span> selector <span class="operator">=</span> <span class="type">NSSelectorFromString</span>(@<span class="string">&quot;setOrientation:&quot;</span>);</span><br><span class="line">            <span class="type">NSInvocation</span> <span class="operator">*</span>invocation <span class="operator">=</span> [<span class="type">NSInvocation</span> invocationWithMethodSignature:[<span class="type">UIDevice</span>     </span><br><span class="line">        instanceMethodSignatureForSelector:selector]];</span><br><span class="line">            [invocation setSelector:selector];</span><br><span class="line">            [invocation setTarget:[<span class="type">UIDevice</span> currentDevice]];</span><br><span class="line">            int val <span class="operator">=</span> orientation;</span><br><span class="line">            [invocation setArgument:<span class="operator">&amp;</span>val atIndex:<span class="number">2</span>];</span><br><span class="line">            [invocation invoke];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>注意：使用这两个方法的时候，也要确保<code>shouldAutorotate</code>方法返回<code>YES</code>，这样这两个方法才会生效。还要注意两者使用的参数类型不同；</p>
<h4 id="三、屏幕旋转控制的优先级"><a href="#三、屏幕旋转控制的优先级" class="headerlink" title="三、屏幕旋转控制的优先级"></a>三、屏幕旋转控制的优先级</h4><p>事实上，如果我们只用上面的方法来控制旋转的开启与关闭，并不能符合我们的需求，而且方法无效。这是因为我们忽略了旋转权限优先级的问题；</p>
<p>屏幕旋转的设置有<code>3</code>个地方：</p>
<ol>
<li><code>Xcode</code>的<code>General</code>设置；</li>
<li><code>info.plist</code>的设置；</li>
<li>通过代码设置；</li>
</ol>
<p>这么多的设置很是繁杂，但是这些其实都是在不同级别上实现旋转的设置，我们会遇到设置后无效的情况，这就很可能是被上一级别控制的原因；</p>
<p>这里先有个大致的了解，控制屏幕旋转优先级为：<strong>工程Target属性配置(全局权限) &#x3D; Appdelegate&amp;&amp;Window &gt; 根视图控制器&gt; 普通视图控制器。</strong></p>
<h4 id="四、开启屏幕旋转的全局权限"><a href="#四、开启屏幕旋转的全局权限" class="headerlink" title="四、开启屏幕旋转的全局权限"></a>四、开启屏幕旋转的全局权限</h4><p>这里我使用<code>全局权限</code>来描述这个问题可能不太准确，其实是设置我们的设备能够支持的方向有哪些，这也是实现旋转的前提；</p>
<p>开启屏幕旋转的全局权限有三种方法，包括通过<code>Xcode</code>直接配置的两种方法和代码控制的一种方法。</p>
<p>这三种方法作用相同，但是由于代码的控制在程序启动之后，所以也是最有效的。下面分别对三种方法的用法介绍：</p>
<h5 id="1-Device-Orientation属性配置"><a href="#1-Device-Orientation属性配置" class="headerlink" title="1.Device Orientation属性配置"></a>1.Device Orientation属性配置</h5><p>我们创建了新工程，<code>Xcode</code>就默认替我们选择了支持旋转的几个方向，这就是<code>Device Orientation</code>属性的默认配置。在<code>Xcode</code>中依次打开：<code>General</code>—&gt;<code>Deployment Info</code>—&gt;<code>Device Orientation</code>,我们可以看到默认支持的设备方向如下：</p>
<img src="http://182.92.228.41/wp-content/uploads/screen-rotation-device-orientation.png">

<p>可以发现，<code>UpsideDown</code>没有被默认支持，因为对于<code>iPhone</code>即使勾选也没有<code>UpSideDown</code>的旋转效果。我们可以在这里勾选或者取消以修改支持的旋转方向。如果是<code>iPad</code>设备勾选之后会同时支持四个方向；</p>
<p><strong>特殊情况：对于iPhone，如果四个属性我们都选或者都不选，效果和默认的情况一样。</strong></p>
<h5 id="2-Info-Plist设置"><a href="#2-Info-Plist设置" class="headerlink" title="2.Info.Plist设置"></a>2.Info.Plist设置</h5><p>其实我们设置了<code>Device Orientation</code>之后，再到<code>info.plist</code>中查看<code>Supported interface orientation</code>，我们会看到：</p>
<img src="http://182.92.228.41/wp-content/uploads/screen_rotation_info_plist.png">

<p>没错，此时<code>Supported interface orientation</code>里的设置和<code>UIDevice Orientation</code>的值一致的，并且我们在这里增加或者删除其中的值，<code>UIDevice Orientation</code>的值也会随之变化，两者属于同一种设置；</p>
<h5 id="3-Appdelegate-amp-amp-Window中设置"><a href="#3-Appdelegate-amp-amp-Window中设置" class="headerlink" title="3.Appdelegate&amp;&amp;Window中设置"></a>3.Appdelegate&amp;&amp;Window中设置</h5><p>正常情况下，我们的<code>App</code>从<code>Appdelegate</code>中启动，而<code>Appdelegate</code>所持有唯一的<code>Window</code>对象是全局的，所以在<code>Appdelegate</code>文件中设置屏幕旋转也是全局有效的。</p>
<p>下面的代码设置了只支持竖屏和右旋转：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">-</span> (<span class="type">UIInterfaceOrientationMask</span>)application:(<span class="type">UIApplication</span> <span class="operator">*</span>)application supportedInterfaceOrientationsForWindow:(<span class="type">UIWindow</span> <span class="operator">*</span>)window &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>  <span class="type">UIInterfaceOrientationMaskPortrait</span> <span class="operator">|</span> <span class="type">UIInterfaceOrientationMaskLandscapeLeft</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意：<strong>如果我们实现了Appdelegate的这一方法，那么我们的App的全局旋转设置将以这里的为准，即使前两种方法的设置与这里的不同。</strong></p>
<h4 id="五、开启屏幕旋转的局部权限-视图控制器"><a href="#五、开启屏幕旋转的局部权限-视图控制器" class="headerlink" title="五、开启屏幕旋转的局部权限(视图控制器)"></a>五、开启屏幕旋转的局部权限(视图控制器)</h4><p>在设置了全局所支持的旋转方向后，接着就开始设置具体的控制器界面了。我们在上面已经说明了关于旋转的优先级了。而这里主要涉及了三种视图控制器：</p>
<ol>
<li><code>UITabbarViewController</code></li>
<li><code>UINavigationBarController</code></li>
<li><code>UIViewController</code></li>
</ol>
<p>自全局权限开启之后，接下来具有最高权限的就是<code>Window</code>的根视图控制器<code>rootViewController</code>了。如果我们要具体控制单个界面<code>UIViewController</code>的旋转就必须先看一下根视图控制器的配置情况了；</p>
<p>当然，在一般情况下，我们的项目都是用<code>UITabbarViewController</code>作为<code>Window</code>的根视图控制器，然后管理着若干个导航控制器<code>UINavigationBarController</code>，再由导航栏控制器去管理普通的视图控制器<code>UIViewController</code>；</p>
<p><strong>若以此为例的话，关于旋转的优先级从高到低就是UITabbarViewController&gt;UINavigationBarController &gt;UIViewController了。如果具有高优先级的控制器关闭了旋转设置，那么低优先级的控制器是无法做到旋转的</strong>；</p>
<p>比如说我们设置要单个视图控制器可以自动旋转，这需要在视图控制器中增加<code>shouldAutorotate</code>方法返回<code>YES</code>或者<code>NO</code>来控制。但如果存在上层根视图控制器，而我们只在这个视图控制器中实现方法，会发现这个方法是不走的，因为这个方法被上层根视图控制器拦截了；</p>
<p>理解这个原理后，我们有两种方法实现自动可控的旋转设置：</p>
<h5 id="方法1：逐级设置各视图控制器，高优先级的视图控制器影响低优先级控制器"><a href="#方法1：逐级设置各视图控制器，高优先级的视图控制器影响低优先级控制器" class="headerlink" title="方法1：逐级设置各视图控制器，高优先级的视图控制器影响低优先级控制器"></a>方法1：逐级设置各视图控制器，高优先级的视图控制器影响低优先级控制器</h5><p>解决上述的问题我们需要设置<code>UITabbarViewController</code>如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//是否自动旋转</span></span><br><span class="line"><span class="operator">-</span>(<span class="type">BOOL</span>)shouldAutorotate&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.selectedViewController.shouldAutorotate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//支持哪些屏幕方向</span></span><br><span class="line"><span class="operator">-</span> (<span class="type">UIInterfaceOrientationMask</span>)supportedInterfaceOrientations &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span>.selectedViewController supportedInterfaceOrientations];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认方向</span></span><br><span class="line"><span class="operator">-</span> (<span class="type">UIInterfaceOrientation</span>)preferredInterfaceOrientationForPresentation&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span>.selectedViewController preferredInterfaceOrientationForPresentation];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设置导航控制器<code>UINavigationController</code>如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//是否自动旋转</span></span><br><span class="line"><span class="comment">//返回导航控制器的顶层视图控制器的自动旋转属性，因为导航控制器是以栈的原因叠加VC的</span></span><br><span class="line"><span class="comment">//topViewController是其最顶层的视图控制器，</span></span><br><span class="line"><span class="operator">-</span>(<span class="type">BOOL</span>)shouldAutorotate&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.topViewController.shouldAutorotate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//支持哪些屏幕方向</span></span><br><span class="line"><span class="operator">-</span> (<span class="type">UIInterfaceOrientationMask</span>)supportedInterfaceOrientations &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span>.topViewController supportedInterfaceOrientations];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认方向</span></span><br><span class="line"><span class="operator">-</span> (<span class="type">UIInterfaceOrientation</span>)preferredInterfaceOrientationForPresentation&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span>.topViewController preferredInterfaceOrientationForPresentation];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里，我们就应该明白了，其实就是高优先级的视图控制器要跟随低优先级控制器的旋转配置。这样就能够达到目的;</p>
<h5 id="方法2-另辟蹊径，使用模态视图"><a href="#方法2-另辟蹊径，使用模态视图" class="headerlink" title="方法2: 另辟蹊径，使用模态视图"></a>方法2: 另辟蹊径，使用模态视图</h5><p>使用模态视图可以不受这种根视图控制器优先级的限制。这个也很容易理解，模态弹出的视图控制器是隔离出来的，不受根视图控制的影响。具体的设置和普通视图器代码相同，这里就不累述了；</p>
<h4 id="六、实现需求：项目主要界面竖屏，部分界面横屏"><a href="#六、实现需求：项目主要界面竖屏，部分界面横屏" class="headerlink" title="六、实现需求：项目主要界面竖屏，部分界面横屏"></a>六、实现需求：项目主要界面竖屏，部分界面横屏</h4><p>这其实也是一个我们做屏幕旋转最常见的需求，在根据上面的讲述之后，我们实现这个需求会很容易，但是具体的实现却有着不同的思路，我在这里总结了两种方法：</p>
<h5 id="方法1：使用基类控制器逐级控制"><a href="#方法1：使用基类控制器逐级控制" class="headerlink" title="方法1：使用基类控制器逐级控制"></a>方法1：使用基类控制器逐级控制</h5><p>具体步骤：</p>
<ol>
<li>开启全局权限设置项目支持的旋转方向；</li>
<li>根据第五节中的方法1，自定义标签控制器和导航控制器来设置屏幕的自动旋转；</li>
<li>自定义基类控制器设置不支持自动转屏，并默认只支持竖屏；</li>
<li>对项目中需要转屏幕的控制器开启自动转屏、设置支持的旋转方向并设置默认方向；</li>
</ol>
<p><code>Demo1</code>链接: <a target="_blank" rel="noopener" href="https://github.com/DreamcoffeeZS/Demo_TestRotatesOne.git">https://github.com/DreamcoffeeZS/Demo_TestRotatesOne.git</a></p>
<h5 id="方法2：Appdelegate增设旋转属性"><a href="#方法2：Appdelegate增设旋转属性" class="headerlink" title="方法2：Appdelegate增设旋转属性"></a>方法2：Appdelegate增设旋转属性</h5><p>具体步骤：</p>
<ol>
<li>在<code>Applegate</code>文件中增加一个用于记录当前屏幕是否横屏的属性；</li>
<li>需要横屏的界面，进入界面后强制横屏，离开界面时恢复竖屏；</li>
</ol>
<p><code>Demo2</code>链接: <a target="_blank" rel="noopener" href="https://github.com/DreamcoffeeZS/Demo_TestRotatesTwo.git">https://github.com/DreamcoffeeZS/Demo_TestRotatesTwo.git</a></p>
<h4 id="七、默认横屏无效的问题"><a href="#七、默认横屏无效的问题" class="headerlink" title="七、默认横屏无效的问题"></a>七、默认横屏无效的问题</h4><p>在上面的项目中，我们可能会遇到一个关于默认横屏的问题，把它拿出来细说一下。</p>
<p>我们项目中有支持竖屏的<code>界面A</code>，也有支持横竖屏的<code>界面B</code>，而且<code>界面B</code>需要进入时就显示横屏。从<code>界面A</code>到<code>界面B</code>中，如果我们使用第五节中的方法1会遇到无法显示默认横屏的情况，因为没有旋转设备，<code>shouldAutorotate</code>就没被调用，也就没法显示我们需要的横屏。这里有两个解决方法：</p>
<h5 id="方法1：在自定义导航控制器中增加以下方法"><a href="#方法1：在自定义导航控制器中增加以下方法" class="headerlink" title="方法1：在自定义导航控制器中增加以下方法"></a>方法1：在自定义导航控制器中增加以下方法</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark <span class="operator">-</span><span class="type">UINavigationControllerDelegate</span></span><br><span class="line"><span class="comment">//不要忘记设置delegate</span></span><br><span class="line"><span class="operator">-</span> (void)navigationController:(<span class="type">UINavigationController</span> <span class="operator">*</span>)navigationController didShowViewController:(<span class="type">UIViewController</span> <span class="operator">*</span>)viewController animated:(<span class="type">BOOL</span>)animated &#123;</span><br><span class="line">    [<span class="keyword">self</span> presentViewController:[<span class="type">UIViewController</span> new] animated:<span class="type">NO</span> completion:<span class="operator">^</span>&#123;</span><br><span class="line">        [<span class="keyword">self</span> dismissViewControllerAnimated:<span class="type">NO</span> completion:<span class="literal">nil</span>];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法的缺点是，原理上利用弹出模态视图来调用转屏，造成切换界面的时候有闪烁效果，体验不佳。所以这里也只是提供一种思路，不推荐使用；</p>
<h5 id="方法2-在需要默认横屏的界面里设置，进入时强制横屏，离开时强制竖屏"><a href="#方法2-在需要默认横屏的界面里设置，进入时强制横屏，离开时强制竖屏" class="headerlink" title="方法2:在需要默认横屏的界面里设置，进入时强制横屏，离开时强制竖屏"></a>方法2:在需要默认横屏的界面里设置，进入时强制横屏，离开时强制竖屏</h5><p>关于这种使用，这个具体可以参考第五节中的<code>demo2</code></p>
<p><strong>注意：两种方法不可同时使用</strong></p>
<h4 id="八、关于旋转后的适配问题"><a href="#八、关于旋转后的适配问题" class="headerlink" title="八、关于旋转后的适配问题"></a>八、关于旋转后的适配问题</h4><p>屏幕旋转的实现会带来相应的<code>UI</code>适配问题，我们需要针对不同方向下的界面重新调整视图布局。首先我们要能够监测到屏幕旋转事件，这里分为两种情况：</p>
<h4 id="1-视图控制器UIViewController里的监测"><a href="#1-视图控制器UIViewController里的监测" class="headerlink" title="1.视图控制器UIViewController里的监测"></a>1.视图控制器UIViewController里的监测</h4><p>当发生转屏事件的时候，下面的<code>UIViewControoller</code>方法会监测到视图<code>View</code>的大小变化，从而帮助我们适配</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">This method is called when the view controller&#x27;s view&#x27;s size is</span></span><br><span class="line"><span class="comment">changed by its parent (i.e. for the root view controller when its window rotates or is resized).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">If you override this method, you should either call super to</span></span><br><span class="line"><span class="comment">propagate the change to children or manually forward the </span></span><br><span class="line"><span class="comment">change to children.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="operator">-</span> (void)viewWillTransitionToSize:(<span class="type">CGSize</span>)size </span><br><span class="line">withTransitionCoordinator:(id <span class="operator">&lt;</span><span class="type">UIViewControllerTransitionCoordinator</span><span class="operator">&gt;</span>)coordinator <span class="type">NS_AVAILABLE_IOS</span>(<span class="number">8_0</span>);</span><br></pre></td></tr></table></figure>

<p>从注释里可以看出此方法在屏幕旋转的时候被调用，我们使用时候也应该首先调用<code>super</code>方法，具体代码使用示例如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//屏幕旋转之后，屏幕的宽高互换，我们借此判断重新布局</span></span><br><span class="line"><span class="comment">//横屏：size.width &gt; size.height</span></span><br><span class="line"><span class="comment">//竖屏: size.width &lt; size.height</span></span><br><span class="line"><span class="operator">-</span> (void)viewWillTransitionToSize:(<span class="type">CGSize</span>)size withTransitionCoordinator:(id<span class="operator">&lt;</span><span class="type">UIViewControllerTransitionCoordinator</span><span class="operator">&gt;</span>)coordinator&#123;</span><br><span class="line">    [<span class="keyword">super</span> viewWillTransitionToSize:size withTransitionCoordinator:coordinator];</span><br><span class="line">    <span class="keyword">if</span> (size.width <span class="operator">&gt;</span> size.height) &#123;</span><br><span class="line">        <span class="comment">//横屏设置，为防止遮挡键盘,调整输入视图的高度</span></span><br><span class="line">        <span class="keyword">self</span>.textView_height.constant <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//竖屏设置</span></span><br><span class="line">        <span class="keyword">self</span>.textView_height.constant <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-子视图横竖屏监测"><a href="#2-子视图横竖屏监测" class="headerlink" title="2.子视图横竖屏监测"></a>2.子视图横竖屏监测</h5><p>如果是类似于表视图的单元格，要监测到屏幕变化实现适配，我们需要用到<code>layoutSubviews</code>方法，因为屏幕切换横竖屏时会触发此方法，然后我们根据状态栏的位置就可以判断横竖屏了，代码示例如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">-</span> (void)layoutSubviews &#123;</span><br><span class="line">    [<span class="keyword">super</span> layoutSubviews];</span><br><span class="line">     <span class="comment">//通过状态栏电池图标判断横竖屏</span></span><br><span class="line">    <span class="keyword">if</span> ([<span class="type">UIApplication</span> sharedApplication].statusBarOrientation <span class="operator">==</span> <span class="type">UIInterfaceOrientationMaskPortrait</span>) &#123;</span><br><span class="line">        <span class="comment">//竖屏布局</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//横屏布局</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="九、APP启动即全屏"><a href="#九、APP启动即全屏" class="headerlink" title="九、APP启动即全屏"></a>九、APP启动即全屏</h4><p>有时项目需要从<code>App</code>启动就默认是横屏，这里有个很方便的方法，就是我们在<code>Device Orientation</code>属性配置里设置如下：</p>
<img src="http://182.92.228.41/wp-content/uploads/screen_rotation_all_screen.png">

<p>但是只这样处理的话，会让项目只支持横屏，所以我们可以在<code>Appdelegate</code>里再次调整我们所支持的方向，方法已经说过，这里就不累述了;</p>
<h4 id="最后总结："><a href="#最后总结：" class="headerlink" title="最后总结："></a>最后总结：</h4><p>关于屏幕旋转的使用大致总结到这里了，如果存在疏漏与错误欢迎路过的朋友指正！谢谢~</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wuyubeichen.github.io/2019/02/20/iOS%E5%BC%80%E5%8F%91-%E5%A4%9ATarget%E9%85%8D%E7%BD%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Author">
      <meta itemprop="description" content="iOS Developer, Beijing China">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="梧雨北辰的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/02/20/iOS%E5%BC%80%E5%8F%91-%E5%A4%9ATarget%E9%85%8D%E7%BD%AE/" class="post-title-link" itemprop="url">iOS开发-多Target配置</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-02-20 17:20:47" itemprop="dateCreated datePublished" datetime="2019-02-20T17:20:47+08:00">2019-02-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-29 09:39:32" itemprop="dateModified" datetime="2022-08-29T09:39:32+08:00">2022-08-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">iOS开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>我们在iOS开发中可能会遇到同时开发多个类似项目的情况。这些项目大同小异，有诸多代码可以共用，如果每个项目都分别开发，这在后期的迭代中会十分繁琐。为了解决这个问题，使用多Target开发是一种比较好的选择，本文就这一技术实现进行简要总结。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2019/02/20/iOS%E5%BC%80%E5%8F%91-%E5%A4%9ATarget%E9%85%8D%E7%BD%AE/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wuyubeichen.github.io/2019/02/18/iOS%E5%BC%80%E5%8F%91-CPU%E6%9E%B6%E6%9E%84%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Author">
      <meta itemprop="description" content="iOS Developer, Beijing China">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="梧雨北辰的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/02/18/iOS%E5%BC%80%E5%8F%91-CPU%E6%9E%B6%E6%9E%84%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">iOS开发-CPU架构问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-02-18 18:18:44" itemprop="dateCreated datePublished" datetime="2019-02-18T18:18:44+08:00">2019-02-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-29 09:39:32" itemprop="dateModified" datetime="2022-08-29T09:39:32+08:00">2022-08-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">iOS开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>首先，之所以提到CPU架构的问题，其实是因为我们iOS开发使用的静态库与动态库与之紧密相连。每一个开发的App都要运行在模拟器或者真机上，在编译的时候，Xcode需要去分析当前运行平台的CPU架构，然后确定所使用的静态库是否支持这个CPU架构。如果不支持就会报错。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2019/02/18/iOS%E5%BC%80%E5%8F%91-CPU%E6%9E%B6%E6%9E%84%E9%97%AE%E9%A2%98/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wuyubeichen.github.io/2019/02/14/Charles%E6%8A%93%E5%8C%85HTTP%E3%80%81HTTPS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Author">
      <meta itemprop="description" content="iOS Developer, Beijing China">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="梧雨北辰的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/02/14/Charles%E6%8A%93%E5%8C%85HTTP%E3%80%81HTTPS/" class="post-title-link" itemprop="url">Charles抓包HTTP、HTTPS</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-02-14 16:16:49" itemprop="dateCreated datePublished" datetime="2019-02-14T16:16:49+08:00">2019-02-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-29 09:39:31" itemprop="dateModified" datetime="2022-08-29T09:39:31+08:00">2022-08-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">网络原理</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>抓包分析数据在移动开发中十分重要，可以帮助我们更快的了解数据构成，提高开发效率。但是在苹果要求上线的App必须使用HTTS之后，HTTPS数据包的抓取分析较为麻烦，在此总结了在mac上使用Charles抓包的详细步骤。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2019/02/14/Charles%E6%8A%93%E5%8C%85HTTP%E3%80%81HTTPS/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wuyubeichen.github.io/2018/08/08/Python%E5%AD%A6%E4%B9%A005-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B(04)-set%E4%B8%8Edict/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Author">
      <meta itemprop="description" content="iOS Developer, Beijing China">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="梧雨北辰的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/08/08/Python%E5%AD%A6%E4%B9%A005-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B(04)-set%E4%B8%8Edict/" class="post-title-link" itemprop="url">Python学习05-数据类型(04)-set与dict</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-08-08 23:39:33" itemprop="dateCreated datePublished" datetime="2018-08-08T23:39:33+08:00">2018-08-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-29 09:39:32" itemprop="dateModified" datetime="2022-08-29T09:39:32+08:00">2022-08-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index"><span itemprop="name">Python</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>区别于序列型数据类型(<code>str</code>、<code>list</code>、<code>tuple</code>)，此篇学习到的是无序数据类型：<code>set</code>和<code>dict</code>；</p>
<h4 id="一、集合set"><a href="#一、集合set" class="headerlink" title="一、集合set"></a>一、集合set</h4><ol>
<li>集合<code>set</code>使用<code>&#123;&#125;</code>表示，定义一个空的集合使用<code>set()</code>;</li>
<li>集合中的数据无序存放的，因此也不能使用索引取值和切片操作；</li>
<li>集合中的元素是非重复的；</li>
<li>从数学的角度理解，集合可以实现差集<code>(&#39;-&#39;)</code>、交集<code>(&#39;&amp;&#39;)</code>、并集<code>(&#39;|&#39;)</code></li>
</ol>
<h5 id="测试1：创建集合有如下两种方法，-其中的元素是非重复的"><a href="#测试1：创建集合有如下两种方法，-其中的元素是非重复的" class="headerlink" title="测试1：创建集合有如下两种方法， 其中的元素是非重复的"></a>测试1：创建集合有如下两种方法， 其中的元素是非重复的</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>set1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(set1)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;set&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(set1)</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>set2 = <span class="built_in">set</span>([<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">6</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(set2)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;set&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(set2)</span><br><span class="line">&#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>&#125;</span><br></pre></td></tr></table></figure>

<h5 id="测试2：集合之间的操作"><a href="#测试2：集合之间的操作" class="headerlink" title="测试2：集合之间的操作"></a>测试2：集合之间的操作</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>set2 - set1</span><br><span class="line">&#123;<span class="number">4</span>, <span class="number">6</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>set1 &amp; set2</span><br><span class="line">&#123;<span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>set1 | set2</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>&#125;</span><br></pre></td></tr></table></figure>

<h5 id="测试3：向集合中添加和删除元素"><a href="#测试3：向集合中添加和删除元素" class="headerlink" title="测试3：向集合中添加和删除元素"></a>测试3：向集合中添加和删除元素</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>set1.add(<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(set1)</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>set1.add(<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(set1)</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>set1.remove(<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(set1)</span><br><span class="line">&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br></pre></td></tr></table></figure>


<h4 id="二、字典dict"><a href="#二、字典dict" class="headerlink" title="二、字典dict"></a>二、字典dict</h4><ol>
<li>字典<code>dict</code>使用<code>&#123;&#125;</code>表示，其中的键值对使用逗号将分开，定义一个空字典可以使用<code>&#123;&#125;</code>；</li>
<li>字典的数据是无序存放的，因此也不能使用索引取值和切片操作；</li>
<li>字典的元素是非重复的，新值会覆盖旧值;</li>
<li>字典的<code>key</code>不一定非要是字符串，也可以是数字等，但<code>key</code>必须不可变，比如<code>list</code>不可以作为<code>key</code>，<code>tuple</code>可以；</li>
</ol>
<h5 id="测试1：创建一个字典，并且通过key增加新的值"><a href="#测试1：创建一个字典，并且通过key增加新的值" class="headerlink" title="测试1：创建一个字典，并且通过key增加新的值"></a>测试1：创建一个字典，并且通过key增加新的值</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict1 = &#123;<span class="string">&quot;1&quot;</span>:<span class="string">&quot;one&quot;</span>, <span class="string">&quot;2&quot;</span>:<span class="string">&quot;two&quot;</span>, <span class="string">&quot;3&quot;</span>:<span class="string">&quot;three&quot;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(dict1)</span><br><span class="line">&#123;<span class="string">&#x27;1&#x27;</span>: <span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;2&#x27;</span>: <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;3&#x27;</span>: <span class="string">&#x27;three&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<h5 id="测试2：一个key只能对应一个value，多次对一个key放入value，后面的值会把前面的值覆盖掉"><a href="#测试2：一个key只能对应一个value，多次对一个key放入value，后面的值会把前面的值覆盖掉" class="headerlink" title="测试2：一个key只能对应一个value，多次对一个key放入value，后面的值会把前面的值覆盖掉"></a>测试2：一个key只能对应一个value，多次对一个key放入value，后面的值会把前面的值覆盖掉</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict1[<span class="string">&quot;1&quot;</span>]=<span class="string">&quot;oneone&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(dict1)</span><br><span class="line">&#123;<span class="string">&#x27;1&#x27;</span>: <span class="string">&#x27;oneone&#x27;</span>, <span class="string">&#x27;2&#x27;</span>: <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;3&#x27;</span>: <span class="string">&#x27;three&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<h5 id="测试3：key不存在时取值报错，若要避免报错，有两种方法"><a href="#测试3：key不存在时取值报错，若要避免报错，有两种方法" class="headerlink" title="测试3：key不存在时取值报错，若要避免报错，有两种方法"></a>测试3：key不存在时取值报错，若要避免报错，有两种方法</h5><ul>
<li>方法1：使用<code>in</code>判断<code>key</code>是否在当前的字典中</li>
<li>方法2：使用字典的<code>get</code>方法，<code>key</code>不存在时会返回<code>None</code>，或者自定义返回的<code>value</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict1[<span class="string">&quot;5&quot;</span>]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">KeyError: <span class="string">&#x27;5&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;5&quot;</span> <span class="keyword">in</span> dict1</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(dict1.get(<span class="string">&quot;5&quot;</span>))</span><br><span class="line"><span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(dict1.get(<span class="string">&quot;5&quot;</span>,-<span class="number">1</span>))</span><br><span class="line">-<span class="number">1</span></span><br></pre></td></tr></table></figure>




      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Author</p>
  <div class="site-description" itemprop="description">iOS Developer, Beijing China</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">38</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Author</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  


</body>
</html>
