<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>梧雨北辰的博客</title>
  
  <subtitle>天行健，君子以自强不息！</subtitle>
  <link href="https://wuyubeichen.github.io/atom.xml" rel="self"/>
  
  <link href="https://wuyubeichen.github.io/"/>
  <updated>2022-08-18T07:05:34.033Z</updated>
  <id>https://wuyubeichen.github.io/</id>
  
  <author>
    <name>Zhou Shuai</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Mach-O简单分析</title>
    <link href="https://wuyubeichen.github.io/2021/11/02/mach-o%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/"/>
    <id>https://wuyubeichen.github.io/2021/11/02/mach-o%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/</id>
    <published>2021-11-02T14:58:08.000Z</published>
    <updated>2022-08-18T07:05:34.033Z</updated>
    
    <content type="html"><![CDATA[<p><strong>主要内容：</strong></p><ol><li><code>Mach-O</code>的读写特性</li><li>查看命令文档</li><li>查看<code>Mach-O</code></li><li>查看<code>Symbol</code></li><li>配置<code>Mach-O</code>终端调试工具</li></ol><h4 id="一、Mach-O的读写特性"><a href="#一、Mach-O的读写特性" class="headerlink" title="一、Mach-O的读写特性"></a>一、Mach-O的读写特性</h4><p><code>Mach-O</code>文件其实等价于： <code>文件配置 + 二进制代码</code>；</p><p><code>Mach-O</code>文件是可读可写的，分析<code>Mach-O</code>文件的结构，可以解释程序运行中的许多问题；</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a9d64afd74384beaa9e32663f3857dfc~tplv-k3u1fbpfcp-watermark.image" alt="MachO-简化结构.png"></p><h5 id="1-Mach-O可读"><a href="#1-Mach-O可读" class="headerlink" title="1. Mach-O可读"></a>1. Mach-O可读</h5><ol><li><code>Header</code>：提供读取所需的身份信息，包括<code>CPU类型</code>、<code>文件类型</code>等；</li><li><code>Load Commands</code>：提供读取所需的文件的信息，以<code>Load Command _TEXT</code>为例，其中记录有<ol><li><code>_TEXT</code>代码段的起始位置；</li><li><code>_TEXT</code>代码段的大小；</li></ol></li><li><code>__TEXT</code>,<code>__DATA</code>,<code>符号表</code>等，这些都是代码编译后的文件、数据存放的位置；</li></ol><h5 id="2-Mach-O可写"><a href="#2-Mach-O可写" class="headerlink" title="2.Mach-O可写"></a>2.Mach-O可写</h5><ol><li><code>Mach-O</code>能被执行是因为有签名，当我们修改了<code>Mach-O</code>文件，需要重新签名才能被苹果系统所接受；</li><li>破解软件都需要重新签名，正是这种原因；</li></ol><h4 id="二、查看命令文档"><a href="#二、查看命令文档" class="headerlink" title="二、查看命令文档"></a>二、查看命令文档</h4><p>有时候，需要在终端查询一些命令的具体用法，有两种方式(以查询<code>nm</code>命令为例)：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">man nm      <span class="comment">//推荐使用</span></span><br><span class="line">nm <span class="operator">--</span>help   </span><br></pre></td></tr></table></figure><p>当终端里显示<code>nm</code>的使用文档后，还可快速定位查询，以查询<code>&quot;-a&quot;</code>参数为例：</p><ul><li><code>/-a</code>：快速匹配文档中<code>-a</code>的位置；</li><li><code>n</code>：向下定位<code>-a</code>位置；</li><li><code>N</code>：向上定位<code>-a</code>位置；</li><li><code>q</code>：退出文档查看；</li></ul><h4 id="三、查看Mach-O"><a href="#三、查看Mach-O" class="headerlink" title="三、查看Mach-O"></a>三、查看Mach-O</h4><h5 id="1-常用的查看命令"><a href="#1-常用的查看命令" class="headerlink" title="1.常用的查看命令"></a>1.常用的查看命令</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查看Header（$&#123;MACH_PATH&#125;表示Mach-O文件位置）</span></span><br><span class="line">objdump <span class="operator">--</span>macho <span class="operator">--</span><span class="keyword">private</span><span class="operator">-</span>header $&#123;<span class="type">MACH_PATH</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看Header 和 Load commands</span></span><br><span class="line">objdump <span class="operator">--</span>macho <span class="operator">--</span><span class="keyword">private</span><span class="operator">-</span>headers $&#123;<span class="type">MACH_PATH</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看__TEXT</span></span><br><span class="line">objdump <span class="operator">--</span>macho <span class="operator">-</span>d $&#123;<span class="type">MACH_PATH</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看符号表</span></span><br><span class="line">objdump <span class="operator">--</span>macho <span class="operator">--</span>syms $&#123;<span class="type">MACH_PATH</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看导出符号</span></span><br><span class="line">objdump <span class="operator">--</span>macho <span class="operator">--</span>exports<span class="operator">-</span>trie $&#123;<span class="type">MACH_PATH</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看间接符号表</span></span><br><span class="line">objdump <span class="operator">--</span>macho <span class="operator">--</span><span class="keyword">indirect</span><span class="operator">-</span>symbols $&#123;<span class="type">MACH_PATH</span>&#125;</span><br></pre></td></tr></table></figure><h5 id="2-测试查看命令"><a href="#2-测试查看命令" class="headerlink" title="2.测试查看命令"></a>2.测试查看命令</h5><p>为了避免过多文件的干扰，创建测试工程时，选择选择<code>MacOS</code> -&gt;<code>Command Line Tool</code>；</p><p>进入工程后，在<code>main.m</code>文件中写入代码如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#<span class="keyword">import</span> &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">int global_init_value <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="keyword">static</span> int static_init_value <span class="operator">=</span> <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char <span class="operator">*</span> argv[]) &#123;</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;%d&quot;</span>, static_init_value);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Xcode</code>运行成功后，<code>Products</code>下的黑色文件即<code>Mach-O可执行文件</code>，如下图：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/71a980af83aa4486889b61d4afbec224~tplv-k3u1fbpfcp-watermark.image" alt="MachO-可执行文件位置.png"></p><p>切换到可执行文件的目录下，使用<code>objdump</code>命令，查看<code>Header</code>:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump <span class="operator">--</span>macho <span class="operator">--</span><span class="keyword">private</span><span class="operator">-</span>header <span class="type">MachOTest</span></span><br></pre></td></tr></table></figure><p>终端的打印结果如下：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5a50badce80f40c4b20043043fef1a14~tplv-k3u1fbpfcp-watermark.image" alt="objdump-查看Header.png"></p><p>使用<code>objdump</code>命令，查看<code>Header</code>以及<code>Load commands</code>：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump <span class="operator">--</span>macho <span class="operator">--</span><span class="keyword">private</span><span class="operator">-</span>headers <span class="type">MachOTest</span></span><br></pre></td></tr></table></figure><p>终端的打印结果如下：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/166474471e0a4d969591eb433827d636~tplv-k3u1fbpfcp-watermark.image" alt="objdump-查看Header&amp;Commands.png"></p><p>如上，我们在<code>Mach-O</code>文件的<code>Load Commands</code>中，可以找到<code>程序入口函数</code>以及<code>依赖系统动态库</code>的相关信息；</p><h4 id="四、查看Symbol"><a href="#四、查看Symbol" class="headerlink" title="四、查看Symbol"></a>四、查看Symbol</h4><p>查看符号，除了可以使用<code>objdump</code>命令以外，还可以使用<code>nm</code>命令；</p><h5 id="1-nm命令简介"><a href="#1-nm命令简介" class="headerlink" title="1.nm命令简介"></a>1.nm命令简介</h5><ol><li><code>nm</code>是<code>name</code>的缩写，它显示指定文件中的符号信息，文件可以是对象文件、可执行文件或对象文件库；</li><li>如果文件中没有包含符号信息，<code>nm</code>报告该情况，但不把他解释为出错；</li><li><code>nm</code>缺省情况下报告十进制符号表示法下的数字值；</li></ol><p>可以在终端使用<code>man nm</code>命令查看其具体用法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">%</span> man nm</span><br><span class="line">nm <span class="operator">-</span> display name list (symbol table)</span><br></pre></td></tr></table></figure><p>即，<code>nm</code>是一个可以查看展示符号表信息的命令。</p><h5 id="2-常用命令参数"><a href="#2-常用命令参数" class="headerlink" title="2.常用命令参数"></a>2.常用命令参数</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">-</span>a <span class="comment">//显示符号表所有内容</span></span><br><span class="line"><span class="operator">-</span>p <span class="comment">//不排序，显示符号本来的顺序</span></span><br><span class="line"><span class="operator">-</span>g <span class="comment">//显示全局符号</span></span><br><span class="line"><span class="operator">-</span>r <span class="comment">//逆转排序</span></span><br><span class="line"><span class="operator">-</span>u <span class="comment">//显示未定义符号</span></span><br><span class="line"><span class="operator">-</span>m <span class="comment">//显示N_SECT类型的符号(Mach-O符号)显示</span></span><br></pre></td></tr></table></figure><h5 id="3-使用举例"><a href="#3-使用举例" class="headerlink" title="3.使用举例"></a>3.使用举例</h5><p>使用<code>nm</code>命令，查看<code>MachO</code>可执行文件中的符号：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nm <span class="operator">-</span>pa $&#123;<span class="type">MACH_PATH</span>&#125;</span><br></pre></td></tr></table></figure><p>终端的打印结果如下：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4ba8fff296804a5180a7ec427f862bf0~tplv-k3u1fbpfcp-watermark.image" alt="nm-查看符号.png"></p><p>其中，第二列符号标签的含义如下：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0df1fe934d0943beb02b34a2da3a2df5~tplv-k3u1fbpfcp-watermark.image" alt="nm-符号类型.png"></p><p>注：标记<code>①</code>的<code>Type</code>，⼩写代表本地符号(<code>local symbol</code>);</p><h4 id="五、配置Mach-O终端测试工具"><a href="#五、配置Mach-O终端测试工具" class="headerlink" title="五、配置Mach-O终端测试工具"></a>五、配置Mach-O终端测试工具</h4><p>如上的调试过程十分繁琐，每次都需要等到程序运行完成，然后再切换到终端测试命令。为了更方便分析<code>Mach-O</code>，这里可以对工程进一步配置，使其运行时可直接将结果打印在终端里，具体的步骤如下：</p><h5 id="1-测试将Xcode打印重定向到终端"><a href="#1-测试将Xcode打印重定向到终端" class="headerlink" title="1.测试将Xcode打印重定向到终端"></a>1.测试将Xcode打印重定向到终端</h5><p>1.新建一个终端，使用<code>tty</code>命令获取其标识位置：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1a6712973a5b484ea17dd1a96e79a31e~tplv-k3u1fbpfcp-watermark.image" alt="TTYDemo-获取终端位置.png"></p><p>2.在<code>Xcode</code>中依次打开: <code>Build Phases</code> -&gt;<code>Run Script</code>，输入脚本命令使其能够在运行时打印：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f992f9d1db0c4b808ed2493246f1372d~tplv-k3u1fbpfcp-watermark.image" alt="TTYDemo-配置RunScript.png"></p><p>3.运行工程，可以看到终端的打印如下</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/72c865804e78457b9a27a54a2e36b31b~tplv-k3u1fbpfcp-watermark.image" alt="TTYDemo-测试RunScript.png"></p><h5 id="2-测试Xcode脚本命令执行项目中的代码"><a href="#2-测试Xcode脚本命令执行项目中的代码" class="headerlink" title="2.测试Xcode脚本命令执行项目中的代码"></a>2.测试Xcode脚本命令执行项目中的代码</h5><p>虽然成功打印信息到终端，但是<code>&quot;Hello world&quot;</code>这段信息却是固定的，为了动态获取执行参数，我们可以自定义配置文件，并在其中定义如下的参数：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DEBUG_URL</span> <span class="operator">=</span> www.debug.com</span><br></pre></td></tr></table></figure><p>然后，修改<code>Run Script</code>：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="string">&quot;Hello World&quot;</span> <span class="operator">&gt;</span> <span class="operator">/</span>dev<span class="operator">/</span>ttys000</span><br><span class="line">echo $&#123;<span class="type">DEBUG_URL</span>&#125; <span class="operator">&gt;</span> <span class="operator">/</span>dev<span class="operator">/</span>ttys000</span><br></pre></td></tr></table></figure><p>终端打印结果：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Hello</span> <span class="type">World</span></span><br><span class="line">www.debug.com</span><br></pre></td></tr></table></figure><p>这里就说明，<code>Xcode</code>脚本执行与配置文件是在同一个环境下，我们可以做到将配置文件中的各种参数传递给脚本中使用。</p><h5 id="3-实现通过脚本命令打印符号信息"><a href="#3-实现通过脚本命令打印符号信息" class="headerlink" title="3. 实现通过脚本命令打印符号信息"></a>3. 实现通过脚本命令打印符号信息</h5><p>在具备以上条件后，可以实现通过脚本命令打印符号信息到终端，具体的做法如下：</p><p>将执行命令的操作定义在一个脚本文件中，并起名<code>xcode_run_cmd.sh</code>，其中的关键代码如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RunCMDToTTY</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> [[ <span class="operator">!</span> <span class="operator">-</span>e <span class="string">&quot;$TTY&quot;</span> ]]; then</span><br><span class="line">        <span class="type">EchoError</span> <span class="string">&quot;=======================&quot;</span></span><br><span class="line">        <span class="type">EchoError</span> <span class="string">&quot;ERROR: Not Config tty to output.&quot;</span></span><br><span class="line">        exit <span class="operator">-</span><span class="number">1</span></span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> [[ <span class="operator">-</span>n <span class="string">&quot;$CMD&quot;</span> ]]; then</span><br><span class="line">        <span class="type">RunCommand</span> <span class="string">&quot;$CMD&quot;</span> $&#123;<span class="type">CMD_FLAG</span>&#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="type">EchoError</span> <span class="string">&quot;========================&quot;</span></span><br><span class="line">        <span class="type">EchoError</span> <span class="string">&quot;ERROR:Failed to run CMD. THE CMD must not null&quot;</span></span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">EchoError</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> [[ <span class="operator">-</span>n <span class="string">&quot;$TTY&quot;</span> ]]; then</span><br><span class="line">        echo <span class="string">&quot;$@&quot;</span> <span class="number">1</span><span class="operator">&gt;&amp;</span><span class="number">2</span><span class="operator">&gt;</span><span class="variable">$TTY</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        echo <span class="string">&quot;$@&quot;</span> <span class="number">1</span><span class="operator">&gt;&amp;</span><span class="number">2</span></span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">RunCommand</span>() &#123;</span><br><span class="line">  <span class="keyword">if</span> [[ <span class="operator">-</span>n <span class="string">&quot;$VERBOSE_SCRIPT_LOGGING&quot;</span> ]]; then</span><br><span class="line">      <span class="keyword">if</span> [[ <span class="operator">-</span>n <span class="string">&quot;$TTY&quot;</span> ]]; then</span><br><span class="line">          echo <span class="string">&quot;♦ $@&quot;</span> <span class="number">1</span><span class="operator">&gt;</span><span class="variable">$TTY</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">          echo <span class="string">&quot;♦ $*&quot;</span></span><br><span class="line">      fi</span><br><span class="line">      echo <span class="string">&quot;-----------------------------------------&quot;</span> <span class="number">1</span><span class="operator">&gt;</span><span class="variable">$TTY</span></span><br><span class="line">  fi</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> [[ <span class="operator">-</span>n <span class="string">&quot;$TTY&quot;</span> ]]; then</span><br><span class="line">      echo `$@ <span class="operator">&amp;&gt;</span><span class="variable">$TTY</span>`</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">      <span class="string">&quot;$@&quot;</span></span><br><span class="line">  fi</span><br><span class="line">  <span class="keyword">return</span> $<span class="operator">?</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">RunCMDToTTY</span></span><br></pre></td></tr></table></figure><p>然后，在配置文件里增加三个参数：<code>CMD</code>，<code>CMD_FLAG</code>，<code>TTY</code>，即需要在.<code>xcconfig</code>中进行定义:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Config-TestProject.debug.xcconfig</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// DEBUG_URL = www.debug.com</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// MACHO_PATH：Mach-O文件路径，即可执行文件路径，这里用到了环境变量来表示具体路径</span></span><br><span class="line"><span class="comment">// TTY = 终端位置标识</span></span><br><span class="line"><span class="comment">// CMD：运行命令</span></span><br><span class="line"><span class="comment">// CMD_FLAG = 命令参数</span></span><br><span class="line"></span><br><span class="line"><span class="type">MACHO_PATH</span> <span class="operator">=</span> $&#123;<span class="type">BUILD_DIR</span>&#125;<span class="operator">/</span>$(<span class="type">CONFIGURATION</span>)$(<span class="type">EFFECTIVE_PLATFORM_NAME</span>)<span class="operator">/</span>$&#123;<span class="type">PRODUCT_NAME</span>&#125;.app<span class="operator">/</span>$&#123;<span class="type">PRODUCT_NAME</span>&#125;</span><br><span class="line"><span class="type">TTY</span> <span class="operator">=</span> <span class="operator">/</span>dev<span class="operator">/</span>ttys000</span><br><span class="line"><span class="type">CMD</span> <span class="operator">=</span> nm</span><br><span class="line"><span class="type">CMD_FLAG</span> <span class="operator">=</span> <span class="operator">-</span>pa $&#123;<span class="type">MACHO_PATH</span>&#125;</span><br></pre></td></tr></table></figure><p>配置完成后的工程如下：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ea2322ca186a45308e88b39fe840514e~tplv-k3u1fbpfcp-watermark.image" alt="TTYDemo-配置文件.png"></p><p>最后，我们需要更改<code>Run Script</code>指令，使其执行脚本文件：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c1a81edf316474bbcc0b5107869a7bd~tplv-k3u1fbpfcp-watermark.image" alt="TTYDemo-配置脚本Script.png"></p><p>此时，再次运行项目，就可以直接在控制台看到使用<code>nm</code>命令分析得到的<code>Mach-O</code>信息了，而且我们可以更换<code>CMD</code>，<code>CMD_FLAG</code>参数，用以调试更多的其他命令。</p><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><ol><li><a href="https://github.com/DreamcoffeeZS/TestProjects.git">文中演示使用的Demo仓库</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;主要内容：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;Mach-O&lt;/code&gt;的读写特性&lt;/li&gt;
&lt;li&gt;查看命令文档&lt;/li&gt;
&lt;li&gt;查看&lt;code&gt;Mach-O&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;查看&lt;code&gt;Symbol&lt;/code</summary>
      
    
    
    
    <category term="iOS高级" scheme="https://wuyubeichen.github.io/categories/iOS%E9%AB%98%E7%BA%A7/"/>
    
    
    <category term="iOS底层" scheme="https://wuyubeichen.github.io/tags/iOS%E5%BA%95%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>Mach-O文件结构</title>
    <link href="https://wuyubeichen.github.io/2021/11/02/mach-o%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/"/>
    <id>https://wuyubeichen.github.io/2021/11/02/mach-o%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/</id>
    <published>2021-11-02T14:57:35.000Z</published>
    <updated>2022-08-18T07:05:34.031Z</updated>
    
    <content type="html"><![CDATA[<p><strong>主要内容：</strong></p><ol><li>理解可执行文件</li><li>理解<code>Mach-O</code>文件</li><li><code>Mach-O</code>文件结构</li><li><code>Mach Header</code></li><li><code>Load Commands</code></li><li><code>Data</code></li><li>理解大小端模式</li><li>理解通用二进制文件</li></ol><h4 id="一、理解可执行文件"><a href="#一、理解可执行文件" class="headerlink" title="一、理解可执行文件"></a>一、理解可执行文件</h4><h5 id="1-可执行文件"><a href="#1-可执行文件" class="headerlink" title="1.可执行文件"></a>1.可执行文件</h5><ol><li><code>进程</code>，其实就是<code>可执行文件</code>在内存中加载得到的结果；</li><li><code>可执行文件</code>必须是操作系统可理解的格式，而且不同系统的<code>可执行文件</code>的格式也是不同的；</li></ol><h5 id="2-不同平台的可执行文件"><a href="#2-不同平台的可执行文件" class="headerlink" title="2.不同平台的可执行文件"></a>2.不同平台的可执行文件</h5><ul><li><code>Linux：ELF</code>文件</li><li><code>Windows</code>：<code>PE32／PE32+</code>文件</li><li><code>OS和iOS</code>：<code>Mach-O(Mach Object)</code>文件</li></ul><h4 id="二、理解Mach-O文件"><a href="#二、理解Mach-O文件" class="headerlink" title="二、理解Mach-O文件"></a>二、理解Mach-O文件</h4><p>作为<code>iOS</code>，<code>iPadOS</code>、<code>macOS</code>平台的可执行文件格式，<code>Mach-O</code>文件涉及App启动运行、<code>bitcode</code>分析、 <code>crash</code>符号化等诸多多个功能：</p><h5 id="1-Mach-O文件"><a href="#1-Mach-O文件" class="headerlink" title="1. Mach-O文件"></a>1. Mach-O文件</h5><ol><li><code>Mach-O</code>文件是<code>iOS</code>，<code>iPadOS</code>、<code>macOS</code>平台的可执行文件格式。对应系统通过应用二进制接口(<code>application binary interface</code>，缩写为<code>ABI</code>)来运行该格式的文件；</li><li><code>Mach-O</code>格式用来替代<code>BSD</code>系统中的<code>a.out</code>格式，保存了在编译和链接过程中产生的<code>机器代码和数据</code>，从而为静态链接和动态链接的代码提供单一文件格式。</li><li><code>Mach-O</code>提供了更强的扩展性，以及更快的符号表信息访问速度；</li></ol><h5 id="2-Mach-O格式的常见文件类型"><a href="#2-Mach-O格式的常见文件类型" class="headerlink" title="2.Mach-O格式的常见文件类型"></a>2.Mach-O格式的常见文件类型</h5><ol><li><code>Executable</code>：可执行文件(<code>.out</code> <code>.o</code>)；</li><li><code>Dylib</code>：动态链接库；</li><li><code>Bundle</code>：不能被链接，只能在运行时使用<code>dlopen()</code>加载；</li><li><code>Image</code>：包含<code>Executable</code>、<code>Dylib</code>和<code>Bundle</code>；</li><li><code>Framework</code>：包含<code>Dylib</code>、资源文件和头文件的文件夹；</li></ol><h4 id="三、Mach-O文件结构"><a href="#三、Mach-O文件结构" class="headerlink" title="三、Mach-O文件结构"></a>三、Mach-O文件结构</h4><h5 id="1-查看Mach-O的两种方法"><a href="#1-查看Mach-O的两种方法" class="headerlink" title="1.查看Mach-O的两种方法"></a>1.查看Mach-O的两种方法</h5><ol><li>使用<code>MachOView</code>软件，可直接查看<code>MachO</code>文件的结构；</li><li>使用终端命令<code>objdump</code>；</li></ol><h5 id="2-查看Mach-O文件结构"><a href="#2-查看Mach-O文件结构" class="headerlink" title="2.查看Mach-O文件结构"></a>2.查看Mach-O文件结构</h5><p>使用<code>MachOView</code>查看<code>Mach-O</code>，效果如下：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4a8b3e13b48e48bb8896b325d4b2bf82~tplv-k3u1fbpfcp-watermark.image" alt="MachO-文件结构2.png"></p><p><code>Mach-O</code>文件中包含三个主要的部分：</p><ol><li><code>Header</code>：头部，描述<code>CPU</code>类型、文件类型、加载命令的条数大小等信息；</li><li><code>Load Commands</code>：加载命令，其条数和大小已经在<code>header</code>中被提供；</li><li><code>Data</code>：数据段；</li></ol><p>其他的信息还有：</p><ol><li><code>Dynamic Loader Info</code>：动态库加载信息</li><li><code>Function Starts</code>：入口函数</li><li><code>Symbol Table</code>：符号表</li><li><code>Dynamic Symbol Table</code>： 动态库符号表</li><li><code>String Table</code>：字符串表</li></ol><h4 id="四、Mach-Header-可执行文件头"><a href="#四、Mach-Header-可执行文件头" class="headerlink" title="四、Mach Header(可执行文件头)"></a>四、Mach Header(可执行文件头)</h4><h5 id="1-功能总结"><a href="#1-功能总结" class="headerlink" title="1.功能总结"></a>1.功能总结</h5><ol><li><code>Header</code>是链接器加载时最先读取的内容，因为它决定了一些<code>基础架构</code>、<code>系统类型</code>等信息；</li><li><code>Header</code>包含整个<code>Mach-O</code>文件的关键信息，如<code>CPU类型</code>、<code>文件类型</code>、<code>加载命令的条数大小</code>等信息，使得系统能够迅速定位<code>Mach-O</code>文件的运行环境；</li><li><code>Header</code>针对<code>32</code>位和<code>64</code>位架构的<code>CPU</code>，分别对应<code>mach_header</code>和<code>mach_header_64</code>的结构体；</li></ol><h5 id="2-源码分析"><a href="#2-源码分析" class="headerlink" title="2.源码分析"></a>2.源码分析</h5><p><code>Header</code>被定义在<code>loader.h</code>文件中，具体代码如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">mach_header_64</span> &#123;</span><br><span class="line">    uint32_t    magic;          <span class="comment">// 32位或者64位，系统内核用来判断是否是mach-o格式</span></span><br><span class="line">    cpu_type_t  cputype;        <span class="comment">// CPU架构类型，比如ARM</span></span><br><span class="line">    cpu_subtype_t   cpusubtype; <span class="comment">// CPU的具体类型，例如arm64、armv7</span></span><br><span class="line">    uint32_t    filetype;       <span class="comment">// mach-o文件类型, 可执行文件、目标文件或者静态库和动态库</span></span><br><span class="line">    uint32_t    ncmds;          <span class="comment">// LoadCommands加载命令的条数（加载命令紧跟header之后）</span></span><br><span class="line">    uint32_t    sizeofcmds;     <span class="comment">// 全部LoadCommands加载命令的大小</span></span><br><span class="line">    uint32_t    flags;          <span class="comment">// 标志位标识二进制文件支持的功能，主要是和系统加载、链接有关</span></span><br><span class="line">    uint32_t    reserved;       <span class="comment">// 保留字段(相比于32位多出的字段)</span></span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>由于<code>可执行文件</code>、<code>目标文件</code>或者<code>静态库</code>和<code>动态库</code>等都是<code>Mach-O</code>格式，所以才需要<code>filetype</code>来说明。常用的文件类型有以下几种：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#define <span class="type">MH_OBJECT</span>   <span class="number">0x1</span>     <span class="comment">/* 目标文件*/</span></span><br><span class="line">#define <span class="type">MH_EXECUTE</span>  <span class="number">0x2</span>     <span class="comment">/* 可执行文件*/</span></span><br><span class="line">#define <span class="type">MH_DYLIB</span>    <span class="number">0x6</span>     <span class="comment">/* 动态库*/</span></span><br><span class="line">#define <span class="type">MH_DYLINKER</span> <span class="number">0x7</span>     <span class="comment">/* 动态链接器*/</span></span><br><span class="line">#define <span class="type">MH_DSYM</span>     <span class="number">0xa</span>     <span class="comment">/* 存储二进制文件符号信息，用于debug分析*/</span></span><br></pre></td></tr></table></figure><h5 id="3-MachOView演示"><a href="#3-MachOView演示" class="headerlink" title="3.MachOView演示"></a>3.MachOView演示</h5><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eaa795545a904c93a9b0d1cc3e7061d3~tplv-k3u1fbpfcp-zoom-1.image"></p><h4 id="五、Load-Commands"><a href="#五、Load-Commands" class="headerlink" title="五、Load Commands"></a>五、Load Commands</h4><h5 id="1-功能总结-1"><a href="#1-功能总结-1" class="headerlink" title="1.功能总结"></a>1.功能总结</h5><ol><li><code>Load Commands</code>是加载命令的列表，用于描述<code>Data</code>在二进制文件和虚拟内存中的布局信息；</li><li><code>Load Commands</code>记录了很多信息，例如动态链接器的位置、程序的入口、依赖库的信息、代码的位置、符号表的位置等；</li><li><code>Load commands</code>由内核定义，不同版本的<code>command</code>数量不同，其条数和大小记录在<code>header</code>中；</li><li><code>Load commands</code>的<code>type</code>是以<code>LC_</code>为前缀常量，譬如<code>LC_SEGMENT</code>、<code>LC_SYMTAB</code>等；</li></ol><h5 id="2-代码分析"><a href="#2-代码分析" class="headerlink" title="2..代码分析"></a>2..代码分析</h5><p><code>Load Command</code>被定义在<code>loader.h</code>文件中，具体代码如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">load_command</span> &#123;</span><br><span class="line">    uint32_t cmd;       <span class="comment">/* 加载命令的类型 */</span></span><br><span class="line">    uint32_t cmdsize;   <span class="comment">/* 加载命令的大小 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>每个<code>Load Command</code>都有独立的结构，但是所有结构的前两个字段是固定的。比如<code>LC_SEGMENT_64</code>，这是一个读取<code>segment</code>、<code>section</code>有关命令，具体代码如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">segment_command_64</span> &#123; <span class="comment">/* for 64-bit architectures */</span></span><br><span class="line">    uint32_t    cmd;          <span class="comment">// 表示加载命令类型</span></span><br><span class="line">    uint32_t    cmdsize;      <span class="comment">// 表示加载命令大小（还包括了紧跟其后的nsects个section的大小）</span></span><br><span class="line">    char        segname[<span class="number">16</span>];  <span class="comment">// 16个字节的段名字</span></span><br><span class="line">    uint64_t    vmaddr;       <span class="comment">// 段的虚拟内存起始地址</span></span><br><span class="line">    uint64_t    vmsize;       <span class="comment">// 段的虚拟内存大小</span></span><br><span class="line">    uint64_t    fileoff;      <span class="comment">// 段在文件中的偏移量</span></span><br><span class="line">    uint64_t    filesize;     <span class="comment">// 段在文件中的大小</span></span><br><span class="line">    vm_prot_t   maxprot;      <span class="comment">// 段页面所需要的最高内存保护（4 = r，2 = w，1 = x）</span></span><br><span class="line">    vm_prot_t   initprot;     <span class="comment">// 段页面初始的内存保护</span></span><br><span class="line">    uint32_t    nsects;       <span class="comment">// 段中section数量</span></span><br><span class="line">    uint32_t    flags;        <span class="comment">// 标志位</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="六、Data"><a href="#六、Data" class="headerlink" title="六、Data"></a>六、Data</h4><h5 id="1-功能总结-2"><a href="#1-功能总结-2" class="headerlink" title="1.功能总结"></a>1.功能总结</h5><ol><li><code>Data</code>中存储了实际的数据与代码，主要包含方法、符号表、动态符号表、动态库加载信息(重定向、符号绑定等)等；</li><li><code>Data</code>中的排布完全按照<code>Load Command</code>中的描述；</li><li><code>Data</code>由<code>Segment</code>（段）和 <code>Section</code> （节）的方式来组成，通常，<code>Data</code>拥有多个<code>segment</code>，每个<code>segment</code>可以有零到多个<code>section</code>节；</li><li>不同的<code>segment</code>都有一段<code>虚拟地址</code>映射到进程的地址空间；</li></ol><p>几乎所有的<code>Mach-O</code>文件都包含<code>3</code>个<code>segment</code></p><ol><li><strong>__TEXT</strong>：代码段，只读可执行，存储<code>函数的二进制代码(__text)</code>，<code>常量字符串(__cstring)</code>，<code>OC的类/方法名</code>等信息</li><li><strong>__DATA</strong>：数据段， 可读可写，存储<code>OC的字符串(__cfstring)</code>，以及<code>运行时的元数据：class/protocol/method</code>，以及全局变量，静态变量等；</li><li><strong>__LINKEDIT</strong>：只读，存储启动<code>App</code>需要的信息，如 <code>bind &amp; rebase 的地址</code>、函数的名称和地址等信息​；</li></ol><h5 id="2-源码分析-1"><a href="#2-源码分析-1" class="headerlink" title="2.源码分析"></a>2.源码分析</h5><p>在<code>Data</code>区中，<code>Section</code>占了很大的比例，而且在<code>Mach-O</code>中集中体现在<code>__TEXT</code>和<code>__DATA</code>两段里。</p><p><code>Section</code>被定义在<code>loader.h</code>文件中，具体代码如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">section_64</span> &#123; <span class="comment">/* for 64-bit architectures */</span></span><br><span class="line">    char        sectname[<span class="number">16</span>];   <span class="comment">// 当前section的名称</span></span><br><span class="line">    char        segname[<span class="number">16</span>];    <span class="comment">// section所在的segment名称</span></span><br><span class="line">    uint64_t    addr;       <span class="comment">// 内存中起始位置</span></span><br><span class="line">    uint64_t    size;       <span class="comment">// section大小</span></span><br><span class="line">    uint32_t    offset;     <span class="comment">// section的文件偏移</span></span><br><span class="line">    uint32_t    align;    <span class="comment">// 字节大小对齐</span></span><br><span class="line">    uint32_t    reloff;     <span class="comment">// 重定位入口的文件偏移</span></span><br><span class="line">    uint32_t    nreloc;   <span class="comment">// 重定位入口数量</span></span><br><span class="line">    uint32_t    flags;      <span class="comment">// 标志，section的类型和属性</span></span><br><span class="line">    uint32_t    reserved1;  <span class="comment">// 保留（用于偏移量或索引）</span></span><br><span class="line">    uint32_t    reserved2;  <span class="comment">// 保留（用于count或sizeof）</span></span><br><span class="line">    uint32_t    reserved3;  <span class="comment">// 保留</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="七、理解大小端模式"><a href="#七、理解大小端模式" class="headerlink" title="七、理解大小端模式"></a>七、理解大小端模式</h4><p>分析<code>Mach-O文</code>件时，经常会看到内存地址相关的内容，这里就涉及到了大小端模式的概念；</p><ol><li>小端模式：数据的低字节，保存在内存的低地址；</li><li>大端模式：数据的低字节，保存在内存的高地址；</li></ol><p><code>iOS</code>设备的处理器是基于<code>ARM</code>架构的，默认是采用<strong>小端模式</strong>(低字节放低位）读取数据的，而网络和蓝牙传输数据通常是用的<strong>大端模式</strong>(低字节放高位)：</p><p>下面以<code>unsigned int value = 0x12345678</code>为例，分别看看在两种字节序下其存储情况，我们可以用<code>unsigned char buf[4]</code>来表示<code>value</code></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Little</span><span class="operator">-</span><span class="type">Endian</span>: 低地址存放低位，如下：</span><br><span class="line">低地址 <span class="operator">------------------&gt;</span> 高地址</span><br><span class="line"><span class="number">0x78</span>    <span class="number">0x56</span>    <span class="number">0x34</span>    <span class="number">0x12</span></span><br><span class="line"></span><br><span class="line"><span class="type">Big</span><span class="operator">-</span><span class="type">Endian</span>: 低地址存放高位，如下：</span><br><span class="line">低地址 <span class="operator">-----------------&gt;</span> 高地址</span><br><span class="line"><span class="number">0x12</span>    <span class="number">0x34</span>    <span class="number">0x56</span>    <span class="number">0x78</span></span><br></pre></td></tr></table></figure><p>内存地址</p><p>小端模式存放内容</p><p>大端模式存放内容</p><p>0x4000</p><p>0x78</p><p>0x12</p><p>0x4001</p><p>0x56</p><p>0x34</p><p>0x4002</p><p>0x34</p><p>0x56</p><p>0x4003</p><p>0x12</p><p>0x78</p><h4 id="八、理解通用二进制文件"><a href="#八、理解通用二进制文件" class="headerlink" title="八、理解通用二进制文件"></a>八、理解通用二进制文件</h4><h5 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h5><ol><li>通用二进制文件的存储结构，是将多种架构的<code>Mach-O</code>文件打包在一起，<code>CPU</code>在读取该二进制文件时可以自动检测并选用合适的架构；</li><li>通用二进制文件会同时存储多种架构，所以比单一架构的二进制文件大很多，会占用大量的磁盘空间。但由于系统运行时会自动选择最合适的，不相关的架构代码，不会占用内存空间，所以执行效率提高了；</li><li>通用二进制格式也被称为胖二进制格式；</li></ol><h5 id="2-通用二进制格式分析"><a href="#2-通用二进制格式分析" class="headerlink" title="2.通用二进制格式分析"></a>2.通用二进制格式分析</h5><p>通用二进制格式的定义在<code>&lt;mach-o/fat.h&gt;</code>中:</p><ol><li>下载<a href="https://opensource.apple.com/tarballs/xnu/">xnu</a>后，依次在 <code>xnu -&gt; EXTERNAL_HEADERS -&gt;mach-o</code>中找到该文件。</li><li>通用二进制文件有两个重要结构体：<code>fat_header</code>、<code>fat_arch</code>；</li></ol><p>两个结构体的定义如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> - magic：可以让系统内核读取该文件时知道是通用二进制文件</span></span><br><span class="line"><span class="comment"> - nfat_arch：表明下面有多个fat_arch结构体，即通用二进制文件包含多少个Mach-O</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">fat_header</span> &#123;</span><br><span class="line">    uint32_t    magic;      <span class="comment">/* FAT_MAGIC */</span></span><br><span class="line">    uint32_t    nfat_arch;  <span class="comment">/* number of structs that follow */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> fat_arch是描述Mach-O</span></span><br><span class="line"><span class="comment"> - cputype 和 cpusubtype：说明Mach-O适用的平台</span></span><br><span class="line"><span class="comment"> - offset（偏移）、size（大小）、align（页对齐）描述了Mach-O二进制位于通用二进制文件的位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">fat_arch</span> &#123;</span><br><span class="line">    cpu_type_t  cputype;    <span class="comment">/* cpu specifier (int) */</span></span><br><span class="line">    cpu_subtype_t   cpusubtype; <span class="comment">/* machine specifier (int) */</span></span><br><span class="line">    uint32_t    offset;     <span class="comment">/* file offset to this object file */</span></span><br><span class="line">    uint32_t    size;       <span class="comment">/* size of this object file */</span></span><br><span class="line">    uint32_t    align;      <span class="comment">/* alignment as a power of 2 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><ol><li><a href="https://opensource.apple.com/tarballs/xnu/">xnu</a></li><li><a href="https://opensource.apple.com/source/xnu/xnu-4903.221.2/EXTERNAL_HEADERS/mach-o/">Mach-O官方源码</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;主要内容：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;理解可执行文件&lt;/li&gt;
&lt;li&gt;理解&lt;code&gt;Mach-O&lt;/code&gt;文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Mach-O&lt;/code&gt;文件结构&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Mach Header&lt;</summary>
      
    
    
    
    <category term="iOS高级" scheme="https://wuyubeichen.github.io/categories/iOS%E9%AB%98%E7%BA%A7/"/>
    
    
    <category term="iOS底层" scheme="https://wuyubeichen.github.io/tags/iOS%E5%BA%95%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>iOS编译原理</title>
    <link href="https://wuyubeichen.github.io/2021/11/02/ios%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    <id>https://wuyubeichen.github.io/2021/11/02/ios%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/</id>
    <published>2021-11-02T14:56:55.000Z</published>
    <updated>2022-08-18T07:05:34.028Z</updated>
    
    <content type="html"><![CDATA[<p><strong>主要内容:</strong></p><ol><li>理解<code>C</code>、<code>C++</code>以及<code>OC</code>的关系</li><li>编译型语言与解释型语言</li><li>编译器<code>LLVM</code>与<code>CLang</code></li><li>理解<code>iOS</code>编译流程</li><li>预处理</li><li>编译</li><li>汇编</li><li>链接</li></ol><h4 id="一、理解C、C-以及OC的关系"><a href="#一、理解C、C-以及OC的关系" class="headerlink" title="一、理解C、C++以及OC的关系"></a>一、理解C、C++以及OC的关系</h4><h5 id="1-C语言"><a href="#1-C语言" class="headerlink" title="1.C语言"></a>1.C语言</h5><ol><li><code>C</code>语言是一门面向过程的计算机编程语言，既可用于系统软件开发，也适用于应用软件开发；</li><li><code>C</code>语言编译器普遍存在于各种不同的操作系统中，例如<code>Microsoft Windows</code>,<code>Mac OS X</code>, <code>Linux</code>, <code>Unix</code>等；</li><li><code>C</code>语言的设计影响了众多后来的编程语言，例如<code>C++</code>、<code>Objective-C</code>、<code>Java</code>、<code>C#</code>等；</li></ol><h5 id="2-C-语言"><a href="#2-C-语言" class="headerlink" title="2.C++语言"></a>2.C++语言</h5><ol><li>兼容了<code>C</code>语言面向过程特点，但又进行了扩充和完善；</li><li>作为一种面向对象的语言，具有封装、多继承、多态等特性；</li></ol><h5 id="3-Objective-C语言"><a href="#3-Objective-C语言" class="headerlink" title="3.Objective-C语言"></a>3.Objective-C语言</h5><ol><li>扩展了<code>C</code>语言的能力，使其具备面向对象设计的能力，相当于<code>C</code>的超集；</li><li><code>OC</code>代码中也可以有<code>C</code>和<code>C++</code>语句，它可以调用<code>C</code>函数，也可以通过<code>C++</code>对象访问方法；</li></ol><h5 id="4-OC与C-的比较"><a href="#4-OC与C-的比较" class="headerlink" title="4.OC与C++的比较"></a>4.OC与C++的比较</h5><ol><li><code>OC</code>与<code>C++</code>都是从<code>C</code>语言演变而来面向对象设计语言，也都兼容标准的<code>C</code>语言；但它们属于不同的面向对象学派；</li><li>两者最大的不同在于：<code>OC</code>提供了运行时的动态绑定机制，而<code>C++</code>是编译时静态绑定，并通过嵌入类和虚函数来模拟实现；</li><li><code>OC</code>在编译阶段降低了编译要求提高了灵活性，而<code>C++</code>则是提高了编译要求，在编译过程中就发现更多的潜在错误，在运行前改正，降低了灵活性；</li></ol><p>以下面的代码为例，在编译期间，<code>C++</code>认为是错误的，而<code>OC</code>则认为没有问题：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NSString</span> <span class="operator">*</span>test <span class="operator">=</span>(id) [[<span class="type">NSArray</span> alloc] <span class="keyword">init</span>];</span><br></pre></td></tr></table></figure><p><code>OC</code>与<code>C++</code>在使用细节上的不同如下：</p><ol><li>定型：<code>OC</code>是动态定型，可以允许根据字符串名字来访问方法和类，还可以动态链接和添加类；</li><li>继承：<code>OC</code>不支持多继承，<code>C++</code>支持多继承；</li><li>函数调用：<code>OC</code>通过消息传递实现函数调用，而<code>C++</code>直接进行函数调用；</li><li>接口：<code>OC</code>采用<code>Protocol</code>形式来定义接口，而<code>C++</code>采用虚函数形式来定义接口；</li><li>重载：<code>OC</code>不允许同一个类中两个方法有相同的名字(即使只是参数类型不同)，但<code>C++</code>可以；</li></ol><h4 id="二、编译型语言与解释型语言"><a href="#二、编译型语言与解释型语言" class="headerlink" title="二、编译型语言与解释型语言"></a>二、编译型语言与解释型语言</h4><p><code>Objective-C</code>属于编译型语言，这是为了保证<code>iPhone</code>的执行效率；</p><h5 id="1-编译型语言"><a href="#1-编译型语言" class="headerlink" title="1.编译型语言"></a>1.编译型语言</h5><ol><li>程序运行前，必须先通过<code>编译器</code>生成<code>机器码</code>，机器码直接通过<code>CPU</code>执行，运行时不需要重新翻译；</li><li>程序执行效率高，但依赖编译器，调试周期长、跨平台性差些；</li><li>代表语言：<code>C</code>、<code>C++</code>、<code>OC</code>等；</li></ol><h5 id="2-解释型语言"><a href="#2-解释型语言" class="headerlink" title="2.解释型语言"></a>2.解释型语言</h5><ol><li>程序运行前，不需要进行编译，而是以文本方式存储程序代码，运行时需要解释器解释后再运行；</li><li>程序执行效率低下，但是程序具有动态性，运行后也可以随时增加和更新代码来改变程序逻辑；</li><li>代表语言：<code>Javascript</code>、<code>Python</code>等；</li></ol><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/651ade0e8b42478994d08c42356d218f~tplv-k3u1fbpfcp-watermark.image" alt="编译原理-语言的分类.jpg"></p><h4 id="三、编译器LLVM与CLang"><a href="#三、编译器LLVM与CLang" class="headerlink" title="三、编译器LLVM与CLang"></a>三、编译器LLVM与CLang</h4><h5 id="1-编译器"><a href="#1-编译器" class="headerlink" title="1.编译器"></a>1.编译器</h5><p>概念：把一种编程语言(<code>原始语言</code>)转换为另一种编程语言(目标语言)的程序;</p><p>大多数编译器都分<code>前端</code>和<code>后端</code>两部分：</p><ul><li>前端：负责<code>词法分析</code>、<code>语法分析</code>、<code>生成中间代码</code>；</li><li>后端：以<code>中间代码</code>作为输入，进行与架构无关的代码优化，接着针对不同架构生成不同的机器码；</li></ul><p>补充：</p><ol><li>前后端以<code>中间代码</code>作为媒介，使得前后端可以独立的变化，互不影响；</li><li>这样的好处在于：新增一门语言只需要修改前端，而新增一种<code>CPU</code>架构只需要修改后端即可；</li></ol><h5 id="2-LLVM与Clang"><a href="#2-LLVM与Clang" class="headerlink" title="2.LLVM与Clang"></a>2.LLVM与Clang</h5><p><code>LLVM</code>是苹果当前使用的编译器：</p><ol><li><code>LLVM</code>是一套编译器基础设施项目，为自由软件，以<code>C++</code>写成，包含一系列模块化的编译器组件和工具链，用来开发编译器<code>前端</code>和<code>后端</code>；</li><li>基于 <code>LLVM</code> 衍生出了一些强大的子项目，比如：<code>Clang</code> 和 <code>LLDB</code>。</li></ol><p><code>CLang</code>基于<code>LLVM</code>，是一个高度模块化开发的轻量级编译器；</p><ol><li><code>CLang</code>主要来自苹果电脑的支持，同时支持<code>C</code>、<code>Objective-C</code>以及<code>C++</code>；</li><li><code>CLang</code>用于替代<code>Xcode5</code>版本前使用的<code>GCC</code>，编译速度提高了<code>3</code>倍：</li></ol><h5 id="3-理解iOS中的编译器"><a href="#3-理解iOS中的编译器" class="headerlink" title="3.理解iOS中的编译器"></a>3.理解iOS中的编译器</h5><ol><li>在<code>iOS</code>开发中，通常<code>LLVM</code>被认为是编译器的后端，而<code>Clang</code>是作为编译器的前端；</li><li>二者以 <code>IR</code>（中间代码）作为媒介，这样前后端分离，使得前后端可以独立的变化，互不影响；</li><li><code>C</code> 语言家族的前端是 <code>clang</code>，<code>swift</code> 的前端是 <code>swiftc</code>，但二者的后端都是 <code>LLVM</code>；</li></ol><h4 id="四、理解iOS编译流程"><a href="#四、理解iOS编译流程" class="headerlink" title="四、理解iOS编译流程"></a>四、理解iOS编译流程</h4><h5 id="1-编译流程图"><a href="#1-编译流程图" class="headerlink" title="1.编译流程图"></a>1.编译流程图</h5><p><a href="http://llvm.org/docs/">LLVM的编译过程</a>相当复杂，<code>iOS</code>代码运行需要经过：<code>预处理</code>、<code>编译</code>、<code>汇编</code>、<code>链接</code>四个关键阶段，具体的流程如下图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8b0e10d16e16408d86cf70758c4b8e03~tplv-k3u1fbpfcp-watermark.image" alt="编译原理-编译流程.png"></p><h5 id="2-准备测试文件"><a href="#2-准备测试文件" class="headerlink" title="2.准备测试文件"></a>2.准备测试文件</h5><p>以<code>OC</code>语言为例，详细分析代码的编译流程，准备一个<code>main.m</code>文件的内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="comment">/// 增加注释：宏定义Name</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Name <span class="string">&quot;梧雨北辰&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> &#123;</span><br><span class="line">    NSLog(@<span class="string">&quot;Hello, %s&quot;</span>, Name);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="五、预处理-Prepressing"><a href="#五、预处理-Prepressing" class="headerlink" title="五、预处理(Prepressing)"></a>五、预处理(Prepressing)</h4><h5 id="1-主要功能"><a href="#1-主要功能" class="headerlink" title="1.主要功能"></a>1.主要功能</h5><ol><li>替换宏：替换代码中各种宏定义，如定义的常量、函数等；</li><li>导入头文件：将<code>#include</code>包含的文件插入到该指令位置等；</li><li>清理注释：删除所有注释：<code>//</code> 、<code>/*</code> <code>*/</code>等；</li><li>条件编译：处理<code>#if</code>、<code>#ifdef</code>，<code>#endif</code>等类似的条件编译；</li><li>添加行号和文件名标识：以便于编译时编译器能够显示警告和错误的所在行号；</li></ol><h5 id="2-查看预处理结果"><a href="#2-查看预处理结果" class="headerlink" title="2.查看预处理结果"></a>2.查看预处理结果</h5><p>使用<code>xcrun</code>命令，在终端执行预处理操作：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun clang <span class="operator">-</span><span class="type">E</span> main.m</span><br></pre></td></tr></table></figure><p>终端显示效果如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">1</span> <span class="string">&quot;main.m&quot;</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;&lt;built-in&gt;&quot;</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="operator">...</span></span><br><span class="line"></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;/Applications/Xcode13.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/System/Library/Frameworks/Foundation.framework/Headers/FoundationLegacySwiftCompatibility.h&quot;</span> <span class="number">1</span> <span class="number">3</span></span><br><span class="line"># <span class="number">193</span> <span class="string">&quot;/Applications/Xcode13.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/System/Library/Frameworks/Foundation.framework/Headers/Foundation.h&quot;</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"># <span class="number">2</span> <span class="string">&quot;main.m&quot;</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line">int main(int argc, const char <span class="operator">*</span> argv[]) &#123;</span><br><span class="line"> <span class="type">NSLog</span>(@<span class="string">&quot;Hello, %s&quot;</span>, <span class="string">&quot;梧雨北辰&quot;</span>);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果分析：</p><ol><li>预处理后的文件中，注释已经被清理，宏定义也已经被替换；</li><li>预处理后的文件有很多行，因为该过程中导入了头文件(<code>Foundation.h</code>)，而且这个过程是递归的；</li></ol><h4 id="六、编译-Compilation"><a href="#六、编译-Compilation" class="headerlink" title="六、编译(Compilation)"></a>六、编译(Compilation)</h4><h5 id="1-词法分析-Lexical-Analysis"><a href="#1-词法分析-Lexical-Analysis" class="headerlink" title="1. 词法分析(Lexical Analysis)"></a>1. 词法分析(Lexical Analysis)</h5><p>主要功能：通过扫描器，分割识别源代码符号(如大小括号、<code>=</code>、字符串)；</p><p>使用<code>xcrun</code>命令，在终端执行词法分析操作：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun clang <span class="operator">-</span>fmodules <span class="operator">-</span>fsyntax<span class="operator">-</span>only <span class="operator">-</span><span class="type">Xclang</span> <span class="operator">-</span>dump<span class="operator">-</span>tokens main.m</span><br></pre></td></tr></table></figure><p>终端显示效果如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">annot_module_include &#x27;#<span class="keyword">import</span> &lt;Foundation/Foundation.h&gt;</span><br><span class="line"><span class="operator">/</span>&#x27;     <span class="type">Loc</span><span class="operator">=&lt;</span>main.m:<span class="number">1</span>:<span class="number">1</span><span class="operator">&gt;</span></span><br><span class="line">int &#x27;int&#x27;  [<span class="type">StartOfLine</span>]  <span class="type">Loc</span><span class="operator">=&lt;</span>main.m:<span class="number">4</span>:<span class="number">1</span><span class="operator">&gt;</span></span><br><span class="line">identifier &#x27;main&#x27;  [<span class="type">LeadingSpace</span>]</span><br><span class="line"></span><br><span class="line"><span class="operator">......</span></span><br><span class="line"></span><br><span class="line">r_brace &#x27;&#125;&#x27;    [<span class="type">StartOfLine</span>]  <span class="type">Loc</span><span class="operator">=&lt;</span>main.m:<span class="number">7</span>:<span class="number">1</span><span class="operator">&gt;</span></span><br><span class="line">eof &#x27;&#x27;        <span class="type">Loc</span><span class="operator">=&lt;</span>main.m:<span class="number">10</span>:<span class="number">1</span><span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><p>结果分析：</p><ol><li>每个被分割的源代码符号都被记录了位置，方便后续定位错误；</li><li>比如<code>Loc=&lt;main.m:4:1&gt;</code> 就表示：<code>&#39;int&#39;</code>这个符号是从源文件<code>main.m</code>的第<code>4</code>行的第<code>1</code>个字符开始的；</li></ol><h5 id="2-语法分析-Semantic-Analysis"><a href="#2-语法分析-Semantic-Analysis" class="headerlink" title="2.语法分析(Semantic Analysis)"></a>2.语法分析(Semantic Analysis)</h5><p>主要功能：对源代码符号进行分析，验证语法是否正确，最后生成<code>AST</code>语法树；</p><p>使用<code>xcrun</code>命令，查看语法分析结果：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun clang <span class="operator">-</span>fsyntax<span class="operator">-</span>only <span class="operator">-</span><span class="type">Xclang</span> <span class="operator">-</span>ast<span class="operator">-</span>dump main.c  <span class="keyword">open</span> <span class="operator">-</span>f</span><br></pre></td></tr></table></figure><p><code>AST</code>语法树：</p><ol><li>是抽象语法树，结构上比代码更精简，遍历速度更快；</li><li>能够更快的进行静态检查，同时生成<code>IR</code>(中间代码)；</li></ol><h5 id="3-静态分析-Static-Analysis"><a href="#3-静态分析-Static-Analysis" class="headerlink" title="3.静态分析(Static Analysis)"></a>3.静态分析(Static Analysis)</h5><p>主要功能：对<code>AST</code>树进行遍历分析，包括<code>类型检查</code>、<code>方法实现检查</code>，会及时提示错误；</p><h5 id="4-生成中间代码-Code-Generation"><a href="#4-生成中间代码-Code-Generation" class="headerlink" title="4.生成中间代码(Code Generation)"></a>4.生成中间代码(Code Generation)</h5><p>主要功能：<code>CodeGen</code>负责将<code>AST</code>语法树自顶向下遍历，逐步翻译成<code>IR</code>中间代码；</p><p><code>IR</code>中间代码：</p><ol><li>这是一种更接近于机器码的语言，使得编译器被分为前端和后端，不同的平台可以利用各自的编译器将中间代码，转化为适合不同平台的机器码；</li><li>对于<code>iOS</code>系统来说，<code>IR</code>中间代码生成的就是<code>Mach-O</code>可执行文件;</li><li><code>IR</code>是前端的输出，后端的输入；</li></ol><h4 id="七、汇编-Assembly"><a href="#七、汇编-Assembly" class="headerlink" title="七、汇编(Assembly)"></a>七、汇编(Assembly)</h4><p>输出<code>中间代码</code>标志着前端工作的完成，接下来将进入后端的处理流程。</p><h5 id="1-LLVM优化中间代码"><a href="#1-LLVM优化中间代码" class="headerlink" title="1.LLVM优化中间代码"></a>1.LLVM优化中间代码</h5><p>中间代码<code>IR</code>进入后端，<code>LLVM</code>会对其进行优化：</p><ol><li><code>Optimization Level</code></li><li><code>bitcode</code></li></ol><h5 id="2-生成汇编代码"><a href="#2-生成汇编代码" class="headerlink" title="2.生成汇编代码"></a>2.生成汇编代码</h5><p><code>LLVM</code>对<code>IR</code>进行优化后，会针对不同架构生成不同汇编代码；</p><p>汇编阶段的目的：</p><ol><li>将代码汇编化，并将符号进行归类；</li><li>将外部导入符号，放到重定位符号表；</li><li>最后生成一个或多个<code>.o</code>目标文件；</li></ol><p>使用<code>xcrun</code>命令，生成汇编文件：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun clang <span class="operator">-</span><span class="type">S</span> main.m <span class="operator">-</span>o main.s</span><br></pre></td></tr></table></figure><p>打开<code>.s</code>文件，摘取内容如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    .section    __TEXT,__text,regular,pure_instructions</span><br><span class="line">    .build_version macos, <span class="number">11</span>, <span class="number">0</span> sdk_version <span class="number">11</span>, <span class="number">3</span></span><br><span class="line">    .globl  _main                           ## <span class="operator">--</span> <span class="type">Begin</span> function main</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    callq   _NSLog</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">.subsections_via_symbols</span><br></pre></td></tr></table></figure><p>可以看到，汇编文件中的<code>NSLog</code>操作已经被转化为汇编命令形式的调用，即<code>callq _NSLog</code>；</p><h5 id="3-生成目标文件"><a href="#3-生成目标文件" class="headerlink" title="3.生成目标文件"></a>3.生成目标文件</h5><p>该阶段是<code>汇编器</code>将<code>汇编代码</code>转换为<code>机器代码</code>，并输出<code>目标文件</code>，即<code>.o</code>文件；</p><p>使用<code>xcrun</code>命令，生成目标文件:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun clang <span class="operator">-</span>fmodules <span class="operator">-</span>c main.m <span class="operator">-</span>o main.o</span><br></pre></td></tr></table></figure><p>使用<code>file</code>命令，查看目标文件类型:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">%</span> file main.o</span><br><span class="line">main.o: <span class="type">Mach</span><span class="operator">-</span><span class="type">O</span> <span class="number">64</span><span class="operator">-</span>bit object x86_64</span><br></pre></td></tr></table></figure><p>可以看到，汇编器生成<code>Mach-O</code>格式的文件，而且是<code>object</code>类型，即目标文件类型：</p><ol><li><code>Mach-O</code>文件是用于<code>iOS</code>和<code>OS</code>平台上的文件类型；</li><li><code>Mach-O</code>作为<code>a.out</code>格式的替代，提供了更强的扩展性，也提升了符号表中信息的访问速度；</li></ol><p>使用<code>xcrun</code>命令，查看下<code>main.o</code>中的符号：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun nm <span class="operator">-</span>nm main.o</span><br></pre></td></tr></table></figure><p>终端显示效果如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">                 (undefined) external _NSLog</span><br><span class="line">                 (undefined) external ___CFConstantStringClassReference</span><br><span class="line"><span class="number">0000000000000000</span> (__TEXT,__text) external _main</span><br></pre></td></tr></table></figure><p>可以看到，此时我们使用的<code>NSLog</code>函数，对应着<code>_NSLog</code>符号：</p><ol><li><code>undefined</code>：表示在当前文件暂时找不到符号<code>_NSLog</code>；</li><li><code>external</code>：表示这个符号是外部可以访问的，对应表示文件私有的符号是<code>non-external</code>；</li></ol><h4 id="八、链接-Linking"><a href="#八、链接-Linking" class="headerlink" title="八、链接(Linking)"></a>八、链接(Linking)</h4><p>主要功能：符号解析、重定位、合并目标文件，最终生成可执行文件；</p><h5 id="1-使用xcrun命令执行链接，得到可执行文件"><a href="#1-使用xcrun命令执行链接，得到可执行文件" class="headerlink" title="1.使用xcrun命令执行链接，得到可执行文件"></a>1.使用xcrun命令执行链接，得到可执行文件</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun clang main.o <span class="operator">-</span>o main</span><br></pre></td></tr></table></figure><h5 id="2-使用file命令，查看文件类型"><a href="#2-使用file命令，查看文件类型" class="headerlink" title="2.使用file命令，查看文件类型"></a>2.使用file命令，查看文件类型</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">%</span> file main</span><br><span class="line">main: <span class="type">Mach</span><span class="operator">-</span><span class="type">O</span> <span class="number">64</span><span class="operator">-</span>bit executable x86_64</span><br><span class="line"><span class="operator">%</span> <span class="operator">./</span>main</span><br><span class="line"><span class="number">2021</span><span class="operator">-</span><span class="number">10</span><span class="operator">-</span><span class="number">01</span> <span class="number">19</span>:<span class="number">06</span>:<span class="number">41.846</span> main[<span class="number">5663</span>:<span class="number">660299</span>] <span class="type">Hello</span>, 梧雨北辰</span><br></pre></td></tr></table></figure><p>结果分析：虽然还是<code>Mach-O</code>格式，但此时已经是<code>executable</code>类型了，即可执行文件。而且运行该文件后也打印出了预期的结果；</p><h5 id="3-再次使用xcrun命令，查看可执行文件的符号表"><a href="#3-再次使用xcrun命令，查看可执行文件的符号表" class="headerlink" title="3.再次使用xcrun命令，查看可执行文件的符号表"></a>3.再次使用xcrun命令，查看可执行文件的符号表</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">%</span> xcrun nm <span class="operator">-</span>nm main</span><br><span class="line">                 (undefined) external _NSLog (from <span class="type">Foundation</span>)</span><br><span class="line">                 (undefined) external ___CFConstantStringClassReference (from <span class="type">CoreFoundation</span>)</span><br><span class="line">                 (undefined) external dyld_stub_binder (from libSystem)</span><br><span class="line"><span class="number">0000000100000000</span> (__TEXT,__text) [referenced dynamically] external __mh_execute_header</span><br><span class="line">0000000100003f40 (__TEXT,__text) external _main</span><br><span class="line"><span class="number">0000000100008008</span> (__DATA,__data) non<span class="operator">-</span>external __dyld_private</span><br></pre></td></tr></table></figure><p>结果分析：<code>_NSLog</code>符号依然是<code>undefined</code>，不过此时多了一些信息，即<code>from Foundation</code>，表示这个符号来自于<code>Foundation</code>，会在运行时动态绑定；</p><h5 id="4-链接阶段的主要任务"><a href="#4-链接阶段的主要任务" class="headerlink" title="4.链接阶段的主要任务"></a>4.链接阶段的主要任务</h5><p>1.符号解析</p><p>将每个符号引用和对应的符号定义关联起来；</p><ul><li>链接器链接多文件时会创建符号表，用于记录所有已经定义和未定义的符号；<ol><li>出现相同符号，会报错：<code>&quot;ld:dumplicate symbols&quot;</code>；</li><li>在其他目标文件里没有找到到符号，会报错：<code>&quot;Undefined symbols&quot;</code>；</li></ol></li><li>另外，链接器在整理函数的符号调用关系时，可以帮助我们理清那些函数没有被调用，并自动去除掉；</li></ul><p>2.重定位</p><p>将变量名、函数名这些符号定义与一个内存位置关联起来；</p><ul><li>因为只有通过了绑定，机器才知道需要操作什么内存地址；</li><li>否则，我们就需要在写代码时给每个指令设置好内存地址，不仅操作繁琐，而且容易引起出错；</li></ul><p>3.合并目标文件</p><p>将多个<code>.m文件</code>编译产生的<code>.o</code>目标文件与其他<code>Mach-O</code>文件(如<code>dylib</code>、<code>a</code>、<code>tbd</code>），合成一个<code>Mach-O</code>格式的可执行文件；</p><ul><li>通常项目都会包含多个文件，不同文件之间的<code>变量</code>和<code>接口函数</code>就会产生相互依赖关系；</li><li>程序运行前，需要使用链接器将多个文件里的符号和地址绑定起来，才能保证整个程序里的变量、接口的正常调用；</li></ul><h5 id="5-理解静态链接与动态链接"><a href="#5-理解静态链接与动态链接" class="headerlink" title="5.理解静态链接与动态链接"></a>5.理解静态链接与动态链接</h5><p>静态链接：作用于编译期，链接后的文件依然可能会存在一些<code>&quot;undefined&quot;</code>的符号。但是这些符号都会被记录下来，在运行时再通过<code>dlopen</code>和<code>dlsym</code>动态链接绑定；</p><p>动态链接：作用于运行时，这样的优势在于：诸多类似<code>UIKit</code>这样的共享库将不必包含在每一个<code>App</code>包里。比如：我们使用到的<code>UIKit</code>系统库，等到点击<code>App</code>真正开始运行之前，才会去链接依赖的<code>UIKit</code>，链接完成再运行<code>App</code>；</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;主要内容:&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;理解&lt;code&gt;C&lt;/code&gt;、&lt;code&gt;C++&lt;/code&gt;以及&lt;code&gt;OC&lt;/code&gt;的关系&lt;/li&gt;
&lt;li&gt;编译型语言与解释型语言&lt;/li&gt;
&lt;li&gt;编译器&lt;code&gt;LLVM&lt;/co</summary>
      
    
    
    
    <category term="iOS高级" scheme="https://wuyubeichen.github.io/categories/iOS%E9%AB%98%E7%BA%A7/"/>
    
    
    <category term="编译原理" scheme="https://wuyubeichen.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Xcode多环境配置</title>
    <link href="https://wuyubeichen.github.io/2021/11/02/Xcode%E5%A4%9A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <id>https://wuyubeichen.github.io/2021/11/02/Xcode%E5%A4%9A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</id>
    <published>2021-11-02T14:54:10.000Z</published>
    <updated>2022-08-18T07:05:34.025Z</updated>
    
    <content type="html"><![CDATA[<p><strong>主要内容：</strong></p><ol><li>区分<code>Project</code>、<code>Target</code>、<code>Scheme</code></li><li>多<code>Target</code> 配置</li><li><code>Scheme</code>配置</li><li><code>xcconfig</code>文件配置</li></ol><h4 id="一、区分Project、Target、Scheme"><a href="#一、区分Project、Target、Scheme" class="headerlink" title="一、区分Project、Target、Scheme"></a>一、区分Project、Target、Scheme</h4><ul><li><code>Project</code>：是一个项目的整体，相当于一个仓库，包括了所有的代码和资源文件；</li><li><code>Target</code>：相当于一个具体的产品，包含了对于代码，资源文件的具体使用规则和配置；</li><li><code>Scheme</code>: 对指定<code>Target</code>的环境进行配置；</li></ul><p>总结：一个<code>Project</code>可以包含多个<code>Target</code>，也就是说通过不同<code>Target</code>我们可以生成不同的<code>APP</code>；</p><p>多环境配置的三种方法：</p><ol><li>多<code>target</code>配置;</li><li><code>Scheme</code>配置;</li><li><code>xcconfig</code>文件配置;</li></ol><h4 id="二、多Target-配置"><a href="#二、多Target-配置" class="headerlink" title="二、多Target 配置"></a>二、多Target 配置</h4><h5 id="1-总结特点"><a href="#1-总结特点" class="headerlink" title="1.总结特点"></a>1.总结特点</h5><ul><li>优点：方便管理代码，资源文件，比如在<code>Compile Sources</code>、<code>Copy Bundle Resources</code>里根据需要增加或者删除需要编译的代码和资源；</li><li>缺点：配置繁琐，涉及多个<code>info.plist</code>文件、宏定义等，大量的修改人容易错乱；</li></ul><h5 id="2-基本步骤"><a href="#2-基本步骤" class="headerlink" title="2.基本步骤"></a>2.基本步骤</h5><p>1.创建新<code>target</code></p><p>选中已有<code>target</code>，右键选择<code>Duplicate</code>，会拷贝创建出与原<code>Target</code>相同配置的新<code>Target</code>；</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c065c372995d416693dc6ccef0508622~tplv-k3u1fbpfcp-watermark.image" alt="Target配置-Duplicate.png"></p><p>2.修改新<code>target</code>的配置</p><p>由于拷贝得到的<code>target</code>仍使用旧的配置，为了使用新<code>target</code>，所以我们还需要一些额外设置：</p><ol><li><p>修改新<code>Target</code>名字；</p></li><li><p>修改新<code>info.plist</code>名字；</p></li><li><p>修改<code>Build Settings</code> -&gt; <code>Packaging</code> -&gt; <code>info.plist File</code> 与 <code>Product Bundle identifier</code>；</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/928bf7525e524884a4ede350865c0536~tplv-k3u1fbpfcp-watermark.image" alt="Target配置-修改名字.png"></p></li></ol><p>3.修改<code>Scheme</code>名字</p><p>进入<code>Scheme Manager</code>，修改<code>Scheme</code>的名字，这里并非必须，修改是为了更加方便识别;</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/89f60813eda548c6932e74d1b22a6083~tplv-k3u1fbpfcp-watermark.image" alt="Target配置-Scheme.png"></p><p>4.为了区别不同的<code>Target</code>，增加预定义宏</p><p>配置<code>OC</code>工程：<code>Build Settings</code> -&gt; <code>Preprocessor Macros</code></p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/21ec401d7c3a4fd7a806e38d861bf8da~tplv-k3u1fbpfcp-watermark.image" alt="Target配置-OC添加宏.png"></p><p>配置<code>Swift</code>工程：<code>Build Settings</code> -&gt; <code>Other Swift Flags</code></p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2fde31bff98e443fa485c6b368ff4842~tplv-k3u1fbpfcp-watermark.image" alt="Target配置-Swift添加宏.png"></p><p>理解<code>-D</code>用法：</p><ol><li><code>swiftc</code>编译器中，需要添加一个<code>-D</code>的<code>option</code>，代表将条件编译标志标记为<code>true</code>；</li><li>至于<code>-D</code>的说明，也可以使用控制台命令查看：<code>swiftc --help grep &#39;-D&#39;</code></li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">-</span><span class="type">D</span> <span class="operator">&lt;</span>value<span class="operator">&gt;</span>  <span class="type">Marks</span> a conditional compilation flag <span class="keyword">as</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>5.测试<code>target</code>多环境</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">#if</span> <span class="type">DEV</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Project DEV&quot;</span>)</span><br><span class="line"><span class="keyword">#else</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Project Normal&quot;</span>)</span><br><span class="line"><span class="keyword">#endif</span></span><br></pre></td></tr></table></figure><h4 id="三、Scheme配置"><a href="#三、Scheme配置" class="headerlink" title="三、Scheme配置"></a>三、Scheme配置</h4><p>配置<code>Scheme</code>实现多环境，其实是通过设置多种<code>configurations</code>的方式，具体步骤如下:</p><h5 id="1-增加新configration"><a href="#1-增加新configration" class="headerlink" title="1.增加新configration"></a>1.增加新configration</h5><p>进入<code>Project</code> -&gt; <code>Info</code> -&gt; <code>Configurations</code>，在这里可以看到已经存在的<code>Debug</code>、<code>Release</code>等配置。点击<code>“+”</code>，可以在这里增加新的<code>configuration</code>(以<code>Dev</code>为例);</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6aa48beefddf4ad9bd70c985a600f608~tplv-k3u1fbpfcp-watermark.image" alt="Scheme配置-增加configration.png"></p><h5 id="2-切换多环境"><a href="#2-切换多环境" class="headerlink" title="2.切换多环境"></a>2.切换多环境</h5><p>增加<code>configuration</code>后，在<code>Edit Scheme</code>时，也会多出一种<code>configration</code>。我们在<code>run</code>的时候，就可以手动切换<code>configration</code>使用不同的环境；</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0ef3d7a5ee5c48cf95c878f3b53e8451~tplv-k3u1fbpfcp-watermark.image" alt="Scheme配置-切换configration.png"></p><h5 id="3-多Scheme"><a href="#3-多Scheme" class="headerlink" title="3.多Scheme"></a>3.多Scheme</h5><p>每次手动切换<code>configration</code>较为繁琐，我们还可以使用不同的<code>Scheme</code>直接对应不同的配置；</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8579731f6eeb4f979f042ec456bec16f~tplv-k3u1fbpfcp-watermark.image" alt="Scheme配置-New-Scheme.png"></p><h5 id="4-测试Scheme多环境"><a href="#4-测试Scheme多环境" class="headerlink" title="4.测试Scheme多环境"></a>4.测试Scheme多环境</h5><p>1.<code>Build Setting</code> -&gt; <code>User-Defined</code>里自定义<code>Host_URL</code>，再对不同的<code>configration</code>配置不同的值；</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fdffb0e428024bf793cdc242ff491d41~tplv-k3u1fbpfcp-watermark.image" alt="Scheme配置-User-HOST_URL.png"></p><p>2.将<code>Host_URL</code>以变量的方式配置<code>到info.plist</code>文件中；</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/81de9bcb9a1241d9b280a363d5683c2e~tplv-k3u1fbpfcp-watermark.image" alt="Scheme配置-Info-HOST_URL.png"></p><p>3.读取<code>info.plist</code>，手动切换<code>configration</code>或者使用不同的<code>Scheme</code>运行，将得到不同的信息；</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> path <span class="operator">=</span> <span class="type">Bundle</span>.main.path(forResource: <span class="string">&quot;Info&quot;</span>, ofType: <span class="string">&quot;plist&quot;</span>) <span class="keyword">else</span> &#123; <span class="keyword">return</span>&#125;</span><br><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> infoDic <span class="operator">=</span> <span class="type">NSDictionary</span>(contentsOfFile: path) <span class="keyword">else</span> &#123;<span class="keyword">return</span>&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> host_url <span class="operator">=</span> infoDic[<span class="string">&quot;HOST_URL&quot;</span>] &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;HOST_URL:<span class="subst">\(host_url)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="四、xcconfig配置文件"><a href="#四、xcconfig配置文件" class="headerlink" title="四、xcconfig配置文件"></a>四、xcconfig配置文件</h4><p><code>xcconfig</code>配置文件：</p><ol><li><code>.xcconfig</code>配置文件，可以帮助我们以文件的形式配置<code>build settings</code>里的内容；</li><li><code>.xcconfig</code>的文件的内容，是以<code>key-value</code>形式构成的；</li><li>增加<code>.xcconfig</code>文件后，依然可以继续在<code>build settings</code>里增加配置项目，并不会覆盖；</li></ol><h5 id="1-查看配置文件"><a href="#1-查看配置文件" class="headerlink" title="1.查看配置文件"></a>1.查看配置文件</h5><p>其实，若使用<code>Cocoapods</code>管理第三方库，就已经自动生成了<code>Debug</code>和<code>Release</code>配置文件。</p><p>查看配置：<code>Xcode</code> -&gt; <code>PROJECT</code> -&gt; <code>info</code> -&gt; <code>Configurations</code></p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e6c883e12ae461788fa93e177c45c19~tplv-k3u1fbpfcp-watermark.image" alt="xxconfig-pods配置.png"></p><h5 id="2-自定义配置文件"><a href="#2-自定义配置文件" class="headerlink" title="2.自定义配置文件"></a>2.自定义配置文件</h5><ol><li><code>Commd +N</code> -&gt; 搜索<code>Configuration Setting File</code>，保存名称以”<code>目录名-App名.环境</code>“为格式， 如”<code>Config-TestProject.debug</code>“；</li><li>在<code>.xcconfig</code>文件里写入配置，而这里用到的<code>key</code>其实都是<code>build settings</code>配置选项的缩写，具体可查看网站<a href="https://xcodebuildsettings.com/">Xcode Build Settings</a>；</li></ol><p>举例：在配置文件中写入以下配置：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SLASH</span> <span class="operator">=</span> <span class="operator">/</span></span><br><span class="line"><span class="type">HOST_URL</span> <span class="operator">=</span> http:$&#123;<span class="type">SLASH</span>&#125;<span class="operator">/</span><span class="number">1234</span></span><br><span class="line"><span class="type">OTHER_LDFLAGS</span> <span class="operator">=</span>  <span class="operator">-</span>framework <span class="string">&quot;AFNetworking&quot;</span></span><br><span class="line"><span class="type">HEADER_SEARCH_PATHS</span> <span class="operator">=</span> <span class="operator">/</span>abcd<span class="operator">/</span>efg</span><br></pre></td></tr></table></figure><p>此时执行编译后，在<code>build settings</code>里搜索查看<code>Other Linker Flags</code>、<code>Header Search Paths</code>，这些配置都已经被成功修改；</p><h5 id="3-特殊符号问题"><a href="#3-特殊符号问题" class="headerlink" title="3.特殊符号问题"></a>3.特殊符号问题</h5><p>在写入配置信息时，其中<code>url</code>的<code>//</code>会被认为是注释。此时，我们可以先定义一个变量<code>SLASH = /</code>， 如下代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SLASH</span> <span class="operator">=</span> <span class="operator">/</span></span><br><span class="line"><span class="type">HOST_URL</span> <span class="operator">=</span> http:$&#123;<span class="type">SLASH</span>&#125;<span class="operator">/</span><span class="number">5678</span></span><br></pre></td></tr></table></figure><h5 id="4-增加约束条件"><a href="#4-增加约束条件" class="headerlink" title="4.增加约束条件"></a>4.增加约束条件</h5><p>某些情况下，我们需要为配置增加约束条件，如只在<code>Debug</code>环境下、<code>SDK</code>是模拟器，且架构是<code>x86_64</code>的情况下才会<code>link</code>这个<code>frameworkName</code>，则需要如下配置：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">OTHER_LDFLAGS</span>[config<span class="operator">=</span><span class="type">Debug</span>][sdk<span class="operator">=</span>iphonesimulator<span class="operator">*</span>][arch<span class="operator">=</span>x86_64] <span class="operator">=</span> <span class="operator">-</span>framework <span class="string">&quot;frameworkName&quot;</span></span><br></pre></td></tr></table></figure><h5 id="5-xcconfig文件冲突问题"><a href="#5-xcconfig文件冲突问题" class="headerlink" title="5.xcconfig文件冲突问题"></a>5.xcconfig文件冲突问题</h5><p>我们习惯于使用<code>cocoapods</code>管理第三方，由其生成的配置文件和我们自定义的配置文件就会冲突，因为一个环境只能配置一个<code>.xcconfig</code>文件：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1717a5a897ba4feeb8c4da0550330622~tplv-k3u1fbpfcp-watermark.image" alt="xxconfig-pods冲突.png"></p><p>而且，此时更新<code>Pods</code>也会警告：已经存在其他的配置文件，<code>Pods</code>设置的.<code>xcconfig</code>文件不会生效；</p><p>解决方案：在自定义配置文件中使用关键<code>include</code>命令，引入<code>pods</code>的配置文件，使其生效：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意：这里需要根据debug、release等不同的环境，分别设置</span></span><br><span class="line">#include <span class="string">&quot;Pods/Target Support Files/Pods-TestProject/Pods-TestProject.debug.xcconfig&quot;</span></span><br></pre></td></tr></table></figure><h5 id="6-xcconfig关键字冲突问题"><a href="#6-xcconfig关键字冲突问题" class="headerlink" title="6.xcconfig关键字冲突问题"></a>6.xcconfig关键字冲突问题</h5><p>将<code>Pods</code>生成的<code>.xcconfig</code>文件通过<code>include</code>导入自定义的配置文件中后，如果两者都对同一个<code>key</code>进行过配置，就会导致前者无效的问题。</p><p>比如，两者都对相同的<code>Other Link Flags</code>进行配置，查看<code>Build Setting</code>后，会发现<code>Pods</code>生成的<code>.xcconfig</code>没有生效；</p><p>解决方案：使用<code>inherited</code>进行继承，在自定义配置文件中配置如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">OTHER_LDFLAGS</span> <span class="operator">=</span> $(inherited) <span class="operator">-</span>framework <span class="string">&quot;AFNetworking&quot;</span></span><br></pre></td></tr></table></figure><h5 id="7-测试-xcconfig多环境"><a href="#7-测试-xcconfig多环境" class="headerlink" title="7.测试.xcconfig多环境"></a>7.测试.xcconfig多环境</h5><ol><li>在不同的<code>.xcconfig</code>定义不同的<code>HOST_URL</code>，并以类似上文的步骤在<code>info.plist</code>中增加配置；</li><li>切换到不同的<code>configration</code>下运行项目，将会得到不同的<code>HOST_URL</code>；</li></ol><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><ol><li><a href="https://github.com/DreamcoffeeZS/TestProjects/tree/main/01.MachO%E4%B8%8E%E7%AC%A6%E5%8F%B7">本文测试Demo地址</a></li><li><a href="https://www.jianshu.com/p/3508e9fff7cc">iOS多Target开发相似App</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;主要内容：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;区分&lt;code&gt;Project&lt;/code&gt;、&lt;code&gt;Target&lt;/code&gt;、&lt;code&gt;Scheme&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;多&lt;code&gt;Target&lt;/code&gt; 配置&lt;/li&gt;
</summary>
      
    
    
    
    <category term="iOS高级" scheme="https://wuyubeichen.github.io/categories/iOS%E9%AB%98%E7%BA%A7/"/>
    
    
    <category term="Xcode" scheme="https://wuyubeichen.github.io/tags/Xcode/"/>
    
  </entry>
  
  <entry>
    <title>Python学习(2)：环境安装与运行</title>
    <link href="https://wuyubeichen.github.io/2018/10/02/Python%E5%AD%A6%E4%B9%A002-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E8%BF%90%E8%A1%8C/"/>
    <id>https://wuyubeichen.github.io/2018/10/02/Python%E5%AD%A6%E4%B9%A002-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E8%BF%90%E8%A1%8C/</id>
    <published>2018-10-02T15:40:57.000Z</published>
    <updated>2022-08-18T07:05:34.063Z</updated>
    
    <content type="html"><![CDATA[<p>Python作为一门跨平台语言，能够在不同的操作系统上很好的运行。当前主流计算机的操作系统有Windows，Mac OS，Linux三种，而在不同操作系统上安装Pyhton环境会有些许不同。</p><p><strong>选择Python版本</strong>： Python目前有两个版本，一个是2.x版本，一个是3.x版本，两个版本互不兼容。但由于3.x版本越来越流行，所以我们都应该选择3.x版本进行安装。</p><h1 id="一、Windows安装Python"><a href="#一、Windows安装Python" class="headerlink" title="一、Windows安装Python"></a>一、Windows安装Python</h1><p>Windows操作系统并没有内置Python环境，需要独立安装。</p><h3 id="1-下载Python"><a href="#1-下载Python" class="headerlink" title="1.下载Python"></a>1.下载Python</h3><p>进入<a href="https://www.python.org/">Python官网</a>，选择Downloads-&gt;Windows-&gt;选择Python版本下载 <img src="https://img-blog.csdn.net/20180507151159166?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RyZWFtY29mZmVlWlM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"> <strong>选择系统版本</strong>: x86-64(简称x64)支持64位系统安装，x84支持32位系统安装</p><p><strong>选择安装方式</strong>: web-based: 通过网络安裝，下载的文件很小，点击运行会从网络下载安装Python; executable: 下载后得到完整的Python，在本机安装； embeddable zip file: 下载得到打包成zip的Python</p><h3 id="2-安装Python-exe"><a href="#2-安装Python-exe" class="headerlink" title="2.安装Python.exe"></a>2.安装Python.exe</h3><p>运行下载的Python.exe，勾选Add Python to PATH(添加后可以在window的命令行下运行Python)，然后选择Customize Installation，按照提示即可完成Python的安装。 <img src="https://img-blog.csdn.net/20180507151211550?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RyZWFtY29mZmVlWlM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><h1 id="二、Mac-OS与Linux安装Python"><a href="#二、Mac-OS与Linux安装Python" class="headerlink" title="二、Mac OS与Linux安装Python"></a>二、Mac OS与Linux安装Python</h1><p>这两种系统其实已经替我们安装好了Python，而无需像Windows那样的下载安装，而且系统中提供两种Python的版本； 终端中输入Python：进入低版本Python环境； 终端中输入Python3：进入新版本Python3环境； 如果想在终端关闭Python环境，使用contrl + d命令</p><h1 id="三、Python的三种运行方式"><a href="#三、Python的三种运行方式" class="headerlink" title="三、Python的三种运行方式"></a>三、Python的三种运行方式</h1><h3 id="1-使用自带的交互式解释器：REPL-Read、Eval、Print、Loop-运行环境"><a href="#1-使用自带的交互式解释器：REPL-Read、Eval、Print、Loop-运行环境" class="headerlink" title="1.使用自带的交互式解释器：REPL(Read、Eval、Print、Loop)运行环境"></a>1.使用自带的交互式解释器：REPL(Read、Eval、Print、Loop)运行环境</h3><p>在安装了Python环境之后，可以直接在Python自带的交互式解释器中编写和运行Python代码。</p><h4 id="步骤1：进入Python运行环境"><a href="#步骤1：进入Python运行环境" class="headerlink" title="步骤1：进入Python运行环境"></a>步骤1：进入Python运行环境</h4><p>Windows系统需要搜索IDLE或者在windows终端界面中输入python，进入python的编译运行环境，而Linux和Mac OS系统：使用terminal命令进入终端，并输入python或者python3命令进入Python环境。</p><h4 id="步骤2：编写和运行Python，以Mac为例"><a href="#步骤2：编写和运行Python，以Mac为例" class="headerlink" title="步骤2：编写和运行Python，以Mac为例"></a>步骤2：编写和运行Python，以Mac为例</h4><p>在Mac上的Python环境中编写代码如：print(“Hello World”)，按下回车即可执行代码，效果图如下： <img src="https://img-blog.csdn.net/20180507151232514?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RyZWFtY29mZmVlWlM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><h3 id="2-命令行执行Python脚本"><a href="#2-命令行执行Python脚本" class="headerlink" title="2.命令行执行Python脚本"></a>2.命令行执行Python脚本</h3><h4 id="步骤1：创建脚本文件"><a href="#步骤1：创建脚本文件" class="headerlink" title="步骤1：创建脚本文件"></a>步骤1：创建脚本文件</h4><p>使用任意的文本编辑器，写入Python代码如：print(“Hello World”)，并将文件保存为demo.py，注意后缀一定要是py。</p><h4 id="步骤2：系统终端中执行脚本文件"><a href="#步骤2：系统终端中执行脚本文件" class="headerlink" title="步骤2：系统终端中执行脚本文件"></a>步骤2：系统终端中执行脚本文件</h4><p>Windows系统中的Python环境是我们下载的指定版本的，所以可以直接进入终端中执行命令：“python + 文件名.py”。而对于Linux和Mac OS系统，有两种不同的执行方式。 使用低版本Python运行脚本文件：python + 文件名.py 使用新版本Python运行脚本文件：python3 + 文件名.py <img src="https://img-blog.csdn.net/20180507151743478?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RyZWFtY29mZmVlWlM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"> 注意：一定要在python脚本的当前目录下操作。 另外，在系统终端关于python的其他命令如下： <img src="https://img-blog.csdn.net/20180507151246287?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RyZWFtY29mZmVlWlM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p><h3 id="3-集成开发环境-IDE-Integrated-Development-Environment-：Pycharm"><a href="#3-集成开发环境-IDE-Integrated-Development-Environment-：Pycharm" class="headerlink" title="3.集成开发环境(IDE:Integrated Development Environment)：Pycharm"></a>3.集成开发环境(IDE:Integrated Development Environment)：Pycharm</h3><p>PyCharm 是由 JetBrains 打造的一款 Python IDE，支持 macOS、 Windows、 Linux 系统。 PyCharm 功能 : 调试、语法高亮、Project管理、代码跳转、智能提示、自动完成、单元测试、版本控制……</p><p><a href="https://www.jetbrains.com/pycharm/download/">官方下载地址</a> <a href="http://xclient.info/s/pycharm.html?t=680034e137bc7cc9b41bad81241e03e932425016#versions">破解下载地址</a> <img src="https://img-blog.csdn.net/20180507151333200?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RyZWFtY29mZmVlWlM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Python作为一门跨平台语言，能够在不同的操作系统上很好的运行。当前主流计算机的操作系统有Windows，Mac OS，Linux三种，而在不同操作系统上安装Pyhton环境会有些许不同。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;选择Python版本&lt;/strong&gt;： Pytho</summary>
      
    
    
    
    <category term="Python" scheme="https://wuyubeichen.github.io/categories/Python/"/>
    
    
    <category term="Python" scheme="https://wuyubeichen.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python学习(1)：入门与导学</title>
    <link href="https://wuyubeichen.github.io/2018/10/01/Python%E5%AD%A6%E4%B9%A001-%E5%85%A5%E9%97%A8%E4%B8%8E%E5%AF%BC%E5%AD%A6/"/>
    <id>https://wuyubeichen.github.io/2018/10/01/Python%E5%AD%A6%E4%B9%A001-%E5%85%A5%E9%97%A8%E4%B8%8E%E5%AF%BC%E5%AD%A6/</id>
    <published>2018-10-01T15:39:33.000Z</published>
    <updated>2022-08-18T07:05:34.061Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Life is simple ,I use Python.</strong></p><p>代码：代码是现实世界事物在计算机世界中的映射 编程：将现实世界中事物用计算机语言来描述</p><p>最近在网上找了一些资料在学习Python，就想把每次的学习内容记录下来，这也是为了避免新学的东西容易遗忘。自己选择Python只有一个原因，那就是兴趣。作为一个iOS开发者，我也很好奇，传说中无所不能的Python到底是怎样的一种语言，使用Python是否也能做出一些有意思的事情，比如爬虫、机器学习等。下面的系列文章就是我的Python学习之旅。</p><h1 id="一、了解Python"><a href="#一、了解Python" class="headerlink" title="一、了解Python"></a>一、了解Python</h1><p>Python并不是一门新兴的语言，反而是诞生于上世纪90年代初的语言。 随着大数据与人工智能的流行，Python逐步的流行起来。Python就像一个技术的润滑剂，大多数互联网公司或多或少都会用到，可以在开发中解决大大小小的很多问题。根据TIOBE语言排行，Python的语言排行为第四位，热度上升很快，其流行程度可见一斑。</p><p>说明：本系列文章是本人的Python学习记录，在1-9篇都是在Python自带的解释器IDLE中编写和运行代码。在实际开发中专业的开发工具使用Pycharm，而做一些轻量化的开发使用的是Sublime text3或者Visual Studio Code</p><h1 id="二、Python能做些什么"><a href="#二、Python能做些什么" class="headerlink" title="二、Python能做些什么"></a>二、Python能做些什么</h1><p>Pyhotn几乎是万能的，相对于其他语言可以做的事情很多。</p><p>1.爬虫</p><p>2.大数据与数据分析(Spark)</p><p>3.自动化运维与自动化测试</p><p>4.Web开发：Flask，Diango</p><p>5.机器学习：Tensor Flow</p><p>6.胶水语言：混合其他如C++、Java等来编程。能够把用其他语言制作的各种模块(尤其是C&#x2F;C++)很轻松的结合在一起。</p><h1 id="三、Pthon特点"><a href="#三、Pthon特点" class="headerlink" title="三、Pthon特点"></a>三、Pthon特点</h1><p>1.Python语法简洁，灵活，优雅，哲学，编写程序容易阅读;</p><p>一种有趣的说法是：Python的语言风格是Pythonic，也就是很Python的意思。就像我们阅读英文短文一样。</p><p>2.Python支持跨平台，可以运行在Windows、Linux以及MacOS。</p><p>3.Python是面向对象的动态语言，既有动态脚本的特性，又有面向对象的特性，非常具有自己的特点。</p><p>4.Python拥有极为强大而丰富的标准库与第三方库，比如电子邮件，比如图形GUI界面;</p><p>5.Python易于上手，难于精通;</p><p>6.Python的语言靠缩进区分代码块，不强制每句代码添加分号；也不需要花括号确定作用域。</p><p>7.Python依靠缩进区分作用域，因此不支持代码压缩，常常以源代码形式的存在，开源性较好。</p><h1 id="四、Python的缺点"><a href="#四、Python的缺点" class="headerlink" title="四、Python的缺点"></a>四、Python的缺点</h1><h2 id="1-运行效率低"><a href="#1-运行效率低" class="headerlink" title="1.运行效率低"></a>1.运行效率低</h2><p>Python主要缺点就是一个字：慢，其相对于C、C++、Java运行效率较慢。</p><p>这主要是因为Pyhton是一种解释性语言，对于当前主流的编程语言大致可分为两类：编译型语言(C、C++)和解释型语言(Javascript、Python)。</p><p><strong>编译型语言</strong>： 程序在执行之前需要一个专门的编译过程，把程序编译成为机器语言的文件，运行时不需要重新翻译，直接使用编译的结果就行了。程序执行效率高，依赖编译器，跨平台性差些。如C、C++、Delphi等. [1]</p><p><strong>解释型语言</strong>： 解释性语言编写的程序不进行预先编译，以文本方式存储程序代码。在发布程序时，看起来省了道编译工序。但是，在运行程序的时候，解释性语言必须先解释再运行</p><p>运行效率与开发效率，鱼与熊掌不可兼得。类似汇编和C的运行效率很高，但是却不适合做web开发。对于语言的选择，适合的才是最好的。</p><h2 id="2-不能加密"><a href="#2-不能加密" class="headerlink" title="2.不能加密"></a>2.不能加密</h2><p>python依靠缩进来编写代码，代码不能被压缩和混淆，所以这也注定了Python代码不能被加密的特性。</p><h1 id="五、Python之禅"><a href="#五、Python之禅" class="headerlink" title="五、Python之禅"></a>五、Python之禅</h1><p>Python的交互式编译器内嵌了几句话(输入import this)，被开发者称之为Pyhon之禅，包含了Python编程的一种大致思想和规范。</p><p>1.Simple is better than complex</p><p>简洁胜于复杂</p><p>2.Now is better than never ，Although never is often better than right now</p><p>做也许好过不做，但不加思索就动手还不如不做</p><h1 id="六、Python学习的相关资料"><a href="#六、Python学习的相关资料" class="headerlink" title="六、Python学习的相关资料"></a>六、Python学习的相关资料</h1><p><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000">廖雪峰Python3的官方网站</a></p><p><a href="http://www.runoob.com/python/python-tutorial.html">Python基本教程</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;Life is simple ,I use Python.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;代码：代码是现实世界事物在计算机世界中的映射 编程：将现实世界中事物用计算机语言来描述&lt;/p&gt;
&lt;p&gt;最近在网上找了一些资料在学习Python，就想把每次的学习内容记</summary>
      
    
    
    
    <category term="Python" scheme="https://wuyubeichen.github.io/categories/Python/"/>
    
    
    <category term="Python" scheme="https://wuyubeichen.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Swift学习10-协议</title>
    <link href="https://wuyubeichen.github.io/2018/08/10/Swift%E5%AD%A6%E4%B9%A010-%E5%8D%8F%E8%AE%AE/"/>
    <id>https://wuyubeichen.github.io/2018/08/10/Swift%E5%AD%A6%E4%B9%A010-%E5%8D%8F%E8%AE%AE/</id>
    <published>2018-08-10T10:10:47.000Z</published>
    <updated>2022-08-19T08:12:32.575Z</updated>
    
    <content type="html"><![CDATA[<p><strong>协议</strong>：是定义一些规范(属性、功能方法)，然后由类、结构体或者枚举遵循并实现这些规范，这一过程被称为遵循了协议；</p><p><strong>主要内容：</strong></p><ol><li>协议的基本语法</li><li>定义协议与实现协议</li><li>协议与构造器</li><li>协议作为类型</li><li>协议实现委托代理模式</li><li>通过扩展遵循协议</li><li>协议类型的集合</li><li>协议继承协议</li><li>类类型专属协议</li><li>协议合成</li><li>检查协议的一致性</li><li>协议的可选性</li><li>协议扩展</li></ol><h4 id="一、协议的基本语法"><a href="#一、协议的基本语法" class="headerlink" title="一、协议的基本语法"></a>一、协议的基本语法</h4><p>下面是协议的一些基本语法：</p><h5 id="1-定义一个协议"><a href="#1-定义一个协议" class="headerlink" title="1.定义一个协议"></a>1.定义一个协议</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">SomeProtocol</span> &#123;</span><br><span class="line">    <span class="comment">//这里是协议的定义部分</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protocol</span> <span class="title class_">AnotherProtocol</span>&#123;</span><br><span class="line">    <span class="comment">//这里是协议的定义部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-自定义类型遵循协议使用冒号，遵循多个协议时，各协议间使用逗号分隔"><a href="#2-自定义类型遵循协议使用冒号，遵循多个协议时，各协议间使用逗号分隔" class="headerlink" title="2.自定义类型遵循协议使用冒号，遵循多个协议时，各协议间使用逗号分隔"></a>2.自定义类型遵循协议使用冒号，遵循多个协议时，各协议间使用逗号分隔</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SomeStructure</span>: <span class="title class_">SomeProtocol</span>, <span class="title class_">AnotherProtocol</span> &#123;</span><br><span class="line">    <span class="comment">//这里是结构体的定义部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-拥有父类的类在遵循协议时，需要将父类名放在协议名之前，以逗号分隔"><a href="#3-拥有父类的类在遵循协议时，需要将父类名放在协议名之前，以逗号分隔" class="headerlink" title="3.拥有父类的类在遵循协议时，需要将父类名放在协议名之前，以逗号分隔"></a>3.拥有父类的类在遵循协议时，需要将父类名放在协议名之前，以逗号分隔</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SomeClass</span>: <span class="title class_">SomeSuperClass</span>, <span class="title class_">SomeProtocol</span>, <span class="title class_">AnotherProtocol</span> &#123;</span><br><span class="line">    <span class="comment">//这里是类的定义部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二、定义协议与实现协议"><a href="#二、定义协议与实现协议" class="headerlink" title="二、定义协议与实现协议"></a>二、定义协议与实现协议</h4><p>协议可以要求遵循协议的类型提供特定的<strong>属性</strong>、<strong>方法</strong>，<strong>构造器</strong>。如果协议中的属性和方法没有实现，就会报错；除此之外，我们还需要注意一些具体的使用规则如下： <strong>属性要求：</strong></p><ol><li>协议可以定义实例属性和类型属性(使用static);</li><li>协议不指定属性是存储属性还是计算型属性，只指定属性名称和类型以及读写性;</li><li>协议指定属性的读取类型，使用的get和set，中间不能使用逗号；</li><li>协议总是使用var关键字来声明变量属性;</li><li>不能给协议属性设置默认值，因为默认值被看做是一种实现;</li></ol><p><strong>方法要求：</strong></p><ol><li>协议可以定义实例方法和类方法(使用static);</li><li>协议定义函数时不能添加函数的实现，同时，传入的参数也不能使用默认参数；</li><li>如果协议定义的实例方法会改变实例本身，需要在定义的方法名前使用mutating；这使得结构体和枚举能够遵循此协议并满足此方法要求。</li></ol><p>下面具体演示一个协议的使用：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span>  <span class="title class_">PersonProtocol</span>&#123;</span><br><span class="line">    <span class="comment">//1.定义属性</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> personCount: <span class="type">Int</span> &#123;<span class="keyword">get</span>&#125;</span><br><span class="line">    <span class="keyword">var</span> name:<span class="type">String</span>&#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        <span class="keyword">set</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> nickName:<span class="type">String</span>&#123;<span class="keyword">get</span> <span class="keyword">set</span>&#125; <span class="comment">//要求可读可写，则该属性不能是常量属性或者只读的计算型属性</span></span><br><span class="line">    <span class="keyword">var</span> birthPlace:<span class="type">String</span>&#123;<span class="keyword">get</span>&#125;   <span class="comment">//只要求可读，若代码需要，实现时也是可写的</span></span><br><span class="line">    <span class="keyword">var</span> age:<span class="type">Int</span>&#123;<span class="keyword">get</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.定义函数</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">play</span>()</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">eat</span>(<span class="params">food</span>:<span class="type">String</span>)</span><br><span class="line">    <span class="comment">//func fed(food:string = &quot;defaultfood”) 错误，不能使用默认参数</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">changeNickName</span>(<span class="params">newName</span>:<span class="type">String</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span>:<span class="title class_">PersonProtocol</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> personCount <span class="operator">=</span> <span class="number">0</span>        <span class="comment">//类属性</span></span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">var</span> nickName: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>          <span class="comment">//这种形式的声明就代表可读可写</span></span><br><span class="line">    <span class="keyword">let</span> birthPlace: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;beijing&quot;</span> <span class="comment">//将只读属性设置为let，在合适位置给其设置默认值就好了</span></span><br><span class="line">    <span class="keyword">var</span> age:<span class="type">Int</span> <span class="operator">=</span> <span class="number">10</span></span><br><span class="line">    <span class="comment">//其实，只读类型的属性也可以设置为var,这相当于是对其进行扩展，不仅遵循了原来的get，还增加了set</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">play</span>() &#123;</span><br><span class="line">        <span class="comment">//类方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">eat</span>(<span class="params">food</span>: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="comment">//普通实例方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">changeNickName</span>(<span class="params">newName</span>: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="comment">//实例方法中修改了实例属性</span></span><br><span class="line">        <span class="keyword">self</span>.nickName <span class="operator">=</span> newName</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试代码：</span></span><br><span class="line"><span class="keyword">var</span> student:<span class="type">Student</span> <span class="operator">=</span> <span class="type">Student</span>()</span><br><span class="line">student.age <span class="operator">=</span> <span class="number">18</span></span><br><span class="line"><span class="keyword">var</span> stu:<span class="type">PersonProtocol</span> <span class="operator">=</span> student <span class="comment">//这里协议也当做了一种类型来使用，但是具体的实现还是是Dog完成的</span></span><br><span class="line"><span class="comment">//stu.age = 10 //这里报错，因为协议中的age是只读的</span></span><br></pre></td></tr></table></figure><p><strong>注意：实现协议中的 mutating 方法时，若是类类型，则不用写 mutating 关键字。而对于结构体和枚举，则必须写 mutating 关键字。</strong></p><h4 id="三、协议与构造器"><a href="#三、协议与构造器" class="headerlink" title="三、协议与构造器"></a>三、协议与构造器</h4><p>这里主要总结协议在定义构造器时候的一些要求，主要有如下几个方面：</p><ol><li>协议中可设置指定或者便利构造器,实现时都需要添加<code>required</code>修饰符,因为这样可以确保所有子类也必须提供此构造器，从而符合协议，但是如果为<code>final</code>类，就不需要；</li><li>如果一个子类重写了父类的指定构造器，并且该构造器满足了某个协议的要求，那么该构造器的实现需要同时标注 <code>required</code> 和 <code>override</code> 修饰符；</li><li>协议中可定义可失败构造器(<code>init?</code>)、非可失败构造器(<code>init</code>)、隐式解包可失败构造器(<code>init!</code>)；</li></ol><p>下面是协议与构造器使用的相关示例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">Protocol</span> &#123;</span><br><span class="line">    <span class="keyword">init</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SomeSuperClass</span> &#123;</span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="comment">// 这里是构造器的实现部分</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SomeSubClass</span>: <span class="title class_">SomeSuperClass</span>, <span class="title class_">SomeProtocol</span> &#123;</span><br><span class="line">    <span class="comment">// 因为遵循协议，需要加上 required</span></span><br><span class="line">    <span class="comment">// 因为继承自父类，需要加上 override</span></span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">override</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="comment">// 这里是构造器的实现部分</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="四、协议作为类型"><a href="#四、协议作为类型" class="headerlink" title="四、协议作为类型"></a>四、协议作为类型</h4><p>协议虽本身并未实现任何功能，但是仍然可以像其他普通类型一样使用,如<code>Int</code>、<code>Double</code>等。协议作为类型使用的场景如下：</p><ol><li>作为函数、方法或构造器中的参数类型或返回值类型</li><li>作为常量、变量或属性的类型</li><li>作为数组、字典或其他容器中的元素类型</li></ol><p>下面演示协议类型的使用：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//协议：定义了生成随机数方法</span></span><br><span class="line"><span class="keyword">protocol</span> <span class="title class_">RandomNumberGenerator</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">random</span>() -&gt; <span class="type">Double</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现了RandomNumberGenerator协议的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinearCongruentialGenerator</span>: <span class="title class_">RandomNumberGenerator</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> lastRandom <span class="operator">=</span> <span class="number">42.0</span></span><br><span class="line">    <span class="keyword">let</span> m <span class="operator">=</span> <span class="number">139968.0</span></span><br><span class="line">    <span class="keyword">let</span> a <span class="operator">=</span> <span class="number">3877.0</span></span><br><span class="line">    <span class="keyword">let</span> c <span class="operator">=</span> <span class="number">29573.0</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">random</span>() -&gt; <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="comment">//使用truncatingRemainder方法进行浮点数取余</span></span><br><span class="line">        lastRandom <span class="operator">=</span> (lastRandom <span class="operator">*</span> a <span class="operator">+</span> c).truncatingRemainder(dividingBy: m)</span><br><span class="line">        <span class="keyword">return</span> lastRandom <span class="operator">/</span> m</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Dice的generator属性，其类型是RandomNumberGenerator协议类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dice</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> sides: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">let</span> generator: <span class="type">RandomNumberGenerator</span>    <span class="comment">//协议作为属性</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//协议作为参数类型</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">sides</span>: <span class="type">Int</span>, <span class="params">generator</span>: <span class="type">RandomNumberGenerator</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.sides <span class="operator">=</span> sides</span><br><span class="line">        <span class="keyword">self</span>.generator <span class="operator">=</span> generator</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">roll</span>() -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Int</span>(generator.random() <span class="operator">*</span> <span class="type">Double</span>(sides)) <span class="operator">+</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> d6 <span class="operator">=</span> <span class="type">Dice</span>(sides: <span class="number">6</span>, generator: <span class="type">LinearCongruentialGenerator</span>())</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">_</span> <span class="keyword">in</span> <span class="number">1</span><span class="operator">...</span><span class="number">5</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Random dice roll is <span class="subst">\(d6.roll())</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Random dice roll is 3</span></span><br><span class="line"><span class="comment">//Random dice roll is 5</span></span><br><span class="line"><span class="comment">//Random dice roll is 4</span></span><br><span class="line"><span class="comment">//Random dice roll is 5</span></span><br><span class="line"><span class="comment">//Random dice roll is 4</span></span><br></pre></td></tr></table></figure><h4 id="五、协议实现委托代理模式"><a href="#五、协议实现委托代理模式" class="headerlink" title="五、协议实现委托代理模式"></a>五、协议实现委托代理模式</h4><p>委托是一种设计模式，它允许类或结构体将一些需要它们负责的功能委托给其他类型的实例。</p><p>委托模式：</p><ul><li>作用：用来响应特定的动作，或者接收外部数据源提供的数据，而无需关心外部数据源的类型；</li><li>原理：定义协议来封装那些需要被委托的功能，这样就能确保遵循协议的类型能提供这些功能；</li></ul><p>下面例子演示了通过协议实现代理模式：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//播放音乐的协议</span></span><br><span class="line"><span class="keyword">protocol</span> <span class="title class_">PlayMusicTools</span>&#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">playMusic</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现协议的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">QQMusisApp</span>:<span class="title class_">PlayMusicTools</span>&#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">playMusic</span>() &#123;</span><br><span class="line">        <span class="built_in">print</span>(“播放一首美妙的音乐<span class="string">&quot;)</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">class Person&#123;</span></span><br><span class="line"><span class="string">    var delegate:PlayMusicTools?</span></span><br><span class="line"><span class="string">    func listenMusic()&#123;</span></span><br><span class="line"><span class="string">        self.delegate?.playMusic()</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//人想听音乐但是又不能自己播放，就调用了代理的方法</span></span><br><span class="line"><span class="string">let person:Person = Person()</span></span><br><span class="line"><span class="string">person.delegate = QQMusisApp()</span></span><br><span class="line"><span class="string">person.listenMusic()</span></span><br></pre></td></tr></table></figure><h4 id="六、通过扩展遵循协议"><a href="#六、通过扩展遵循协议" class="headerlink" title="六、通过扩展遵循协议"></a>六、通过扩展遵循协议</h4><p>我们知道，扩展可以为已有类型添加属性、方法、下标以及构造器。同样道理，我们也可以通过扩展为已有类型实现需要遵循的协议，通过这种方法与在原始定义中遵循并实现协议效果完全相同。</p><h5 id="6-1-通过扩展实现协议"><a href="#6-1-通过扩展实现协议" class="headerlink" title="6.1.通过扩展实现协议"></a>6.1.通过扩展实现协议</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//协议：定义一个可以打印UIView属性fame的方法</span></span><br><span class="line"><span class="keyword">protocol</span> <span class="title class_">ViewProperty</span>&#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">printFrame</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过扩展为UIView实现了ViewProperty协议</span></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">UIView</span>:<span class="title class_">ViewProperty</span>&#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">printFrame</span>() &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="keyword">self</span>.frame)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> view <span class="operator">=</span> <span class="type">UIView</span>(frame: <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="number">100</span>, height: <span class="number">100</span>))</span><br><span class="line">view.printFrame()</span><br></pre></td></tr></table></figure><h5 id="6-2-已经符合协议的类"><a href="#6-2-已经符合协议的类" class="headerlink" title="6.2.已经符合协议的类"></a>6.2.已经符合协议的类</h5><p>如果一个类型已经符合了某个协议的所有要求，却还没有声明遵循这个协议，那么可以通过空扩展来遵循协议。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CustomObject</span>&#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">printFrame</span>() &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;this is not a view，cant print frame&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//空扩展表示遵循协议</span></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">CustomObject</span>:<span class="title class_">ViewProperty</span>&#123;&#125;</span><br><span class="line"><span class="comment">//遵循了协议之后，就可以使用协议作为类型</span></span><br><span class="line"><span class="keyword">let</span> customOject:<span class="type">ViewProperty</span> <span class="operator">=</span> <span class="type">CustomObject</span>()</span><br><span class="line">customOject.printFrame()</span><br></pre></td></tr></table></figure><h4 id="七、协议类型的集合"><a href="#七、协议类型的集合" class="headerlink" title="七、协议类型的集合"></a>七、协议类型的集合</h4><p>协议类型可以在数组或者字典这样的集合中使用；如下，等号左边的数组表示遵循了<code>ViewProperty</code>协议的对象构成的数组。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> things:[<span class="type">ViewProperty</span>] <span class="operator">=</span> [view,customOject]</span><br><span class="line"><span class="keyword">for</span> thing <span class="keyword">in</span> things&#123;</span><br><span class="line">    thing.printFrame()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印结果：</span></span><br><span class="line"><span class="comment">//(0.0, 0.0, 100.0, 100.0)</span></span><br><span class="line"><span class="comment">//this is not a view，cant print frame</span></span><br></pre></td></tr></table></figure><h4 id="八、协议继承协议"><a href="#八、协议继承协议" class="headerlink" title="八、协议继承协议"></a>八、协议继承协议</h4><p>协议继承协议具有以下特点：</p><ol><li>协议能够继承一个或多个其他协议，可以在继承的协议的基础上增加新的要求。</li><li>协议的继承语法与类的继承相似，多个被继承的协议间用逗号分隔：</li><li>所有遵循新协议的类型，也同时满足新协议所继承的父协议</li></ol><p>协议继承协议的格式如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">InheritingProtocol</span>: <span class="title class_">SomeProtocol</span>, <span class="title class_">AnotherProtocol</span> &#123;</span><br><span class="line">    <span class="comment">// 这里是协议的定义部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="九、类类型专属协议"><a href="#九、类类型专属协议" class="headerlink" title="九、类类型专属协议"></a>九、类类型专属协议</h4><p>协议的继承列表中，通过添加 <code>class</code> 关键字来限制协议只能被类类型遵循，而结构体或枚举不能遵循该协议。<code>class</code> 关键字必须第一个出现在协议的继承列表中，在其他继承的协议之前。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">SomeClassOnlyProtocol</span>: <span class="title class_">class</span>, <span class="title class_">SomeInheritedProtocol</span> &#123;</span><br><span class="line">    <span class="comment">// 这里是类类型专属协议的定义部分</span></span><br><span class="line">    <span class="comment">//class 关键字必须第一个出现在协议的继承列表中，在其他继承的协议之前</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="十、协议合成"><a href="#十、协议合成" class="headerlink" title="十、协议合成"></a>十、协议合成</h4><p>有时候需要同时遵循多个协议，你可以将多个协议采用<code>SomeProtocol &amp; AnotherProtocol</code>这样的格式进行组合，称为协议合成(<code>protocol composition</code>)；你可以罗列任意多个你想要遵循的协议，以与符号(<code>&amp;</code>)分隔。</p><p>下面的例子中，将 <code>Named</code> 和 <code>Aged</code> 两个协议按照上述语法组合成一个协议，作为函数参数的类型：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">Named</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protocol</span> <span class="title class_">Aged</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> age: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Person遵循两个协议</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span>: <span class="title class_">Named</span>, <span class="title class_">Aged</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> age: <span class="type">Int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数参数celebrator的类型为 Name &amp; Aged；</span></span><br><span class="line"><span class="comment">//这意味着它不关心参数的具体类型，只要参数符合这两个协议即可；</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">wishHappyBirthday</span>(<span class="params">to</span> <span class="params">celebrator</span>: <span class="type">Named</span> &amp; <span class="type">Aged</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Happy birthday, <span class="subst">\(celebrator.name)</span>, you&#x27;re <span class="subst">\(celebrator.age)</span>!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> birthdayPerson <span class="operator">=</span> <span class="type">Person</span>(name: <span class="string">&quot;Malcolm&quot;</span>, age: <span class="number">21</span>)</span><br><span class="line">wishHappyBirthday(to: birthdayPerson)      <span class="comment">//打印 “Happy birthday Malcolm - you&#x27;re 21!”</span></span><br></pre></td></tr></table></figure><p><strong>注意：协议合成并不会生成新的、永久的协议类型，而是将多个协议中的要求合成到一个只在局部作用域有效的临时协议中</strong></p><h4 id="十一、检查协议的一致性"><a href="#十一、检查协议的一致性" class="headerlink" title="十一、检查协议的一致性"></a>十一、检查协议的一致性</h4><p>类型转换中描述的is和as操作符同样可以用来检查协议一致性，即是否符合某协议，并且可以转换到指定的协议类型。检查和转换到某个协议类型在语法上和类型的检查和转换完全相同：</p><ul><li><strong>is</strong>：用来检查实例是否符合某个协议，若符合则返回 true，否则返回 false。</li><li>**as?**： 返回一个可选值，当实例符合某个协议时，返回类型为协议类型的可选值，否则返回 nil。</li><li>**as!**：将实例强制向下转换到某个协议类型，如果强转失败，会引发运行时错误。</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义协议：定义一个Double类型的可读属性area</span></span><br><span class="line"><span class="keyword">protocol</span> <span class="title class_">HasArea</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> area: <span class="type">Double</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Circle类和Country类遵循协议HasArea</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span>: <span class="title class_">HasArea</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> pi <span class="operator">=</span> <span class="number">3.1415927</span></span><br><span class="line">    <span class="keyword">var</span> radius: <span class="type">Double</span></span><br><span class="line">    <span class="keyword">var</span> area: <span class="type">Double</span> &#123; <span class="keyword">return</span> pi <span class="operator">*</span> radius <span class="operator">*</span> radius &#125; <span class="comment">//计算型</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">radius</span>: <span class="type">Double</span>) &#123; <span class="keyword">self</span>.radius <span class="operator">=</span> radius &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Country</span>: <span class="title class_">HasArea</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> area: <span class="type">Double</span> <span class="comment">//存储型</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">area</span>: <span class="type">Double</span>) &#123; <span class="keyword">self</span>.area <span class="operator">=</span> area &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Animal未遵循协议</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> legs: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">legs</span>: <span class="type">Int</span>) &#123; <span class="keyword">self</span>.legs <span class="operator">=</span> legs &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> objects: [<span class="type">AnyObject</span>] <span class="operator">=</span> [</span><br><span class="line">    <span class="type">Circle</span>(radius: <span class="number">2.0</span>),</span><br><span class="line">    <span class="type">Country</span>(area: <span class="number">243_610</span>),</span><br><span class="line">    <span class="type">Animal</span>(legs: <span class="number">4</span>)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">//迭代测试，并检测协议</span></span><br><span class="line"><span class="keyword">for</span> object <span class="keyword">in</span> objects &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> objectWithArea <span class="operator">=</span> object <span class="keyword">as?</span> <span class="type">HasArea</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Area is <span class="subst">\(objectWithArea.area)</span>&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Something that doesn&#x27;t have an area&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Area is 12.5663708</span></span><br><span class="line"><span class="comment">// Area is 243610.0</span></span><br><span class="line"><span class="comment">// Something that doesn&#x27;t have an area”</span></span><br></pre></td></tr></table></figure><h4 id="十二、协议的可选性"><a href="#十二、协议的可选性" class="headerlink" title="十二、协议的可选性"></a>十二、协议的可选性</h4><p><strong>协议可以定义可选要求，即遵循协议的类型可以选择是否实现这些要求。</strong></p><ol><li>在协议中使用<code>optional</code>关键字作为前缀来定义可选要求。</li><li>可选要求用在你需要和<code>Objective-C</code>打交道的代码中。协议和可选要求都必须带上<code>@objc</code>属性。</li><li>标记<code>@objc</code>特性的协议只能被继承自<code>Objective-C</code>类的类或者<code>@objc</code>类遵循，其他类以及结构体和枚举均不能遵循这种协议；</li><li>协议中的可选要求可通过可选链式调用来使用，因为遵循协议的类型可能没有实现这些可选要求；</li></ol><p>下面的例子定义了一个名为<code>Counter</code>的用于整数计数的类，它使用外部的数据源来提供每次的增量。数据源由<code>CounterDataSource</code>协议定义，包含两个可选要求：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.协议CounterDataSource包含两个可选要求</span></span><br><span class="line"><span class="keyword">@objc</span> <span class="keyword">protocol</span> <span class="title class_">CounterDataSource</span> &#123;</span><br><span class="line">    <span class="keyword">@objc</span> <span class="keyword">optional</span> <span class="keyword">func</span> <span class="title function_">incrementForCount</span>(<span class="params">count</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span></span><br><span class="line">    <span class="keyword">@objc</span> <span class="keyword">optional</span> <span class="keyword">var</span> fixedIncrement: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.Counter类含有CounterDataSource?类型的可选属性dataSource</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> count <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> dataSource: <span class="type">CounterDataSource</span>?</span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">increment</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> amount <span class="operator">=</span> dataSource<span class="operator">?</span>.incrementForCount<span class="operator">?</span>(count: count) &#123;</span><br><span class="line">            count <span class="operator">+=</span> amount</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">let</span> amount <span class="operator">=</span> dataSource<span class="operator">?</span>.fixedIncrement &#123;</span><br><span class="line">             <span class="comment">//通过可选链调用，每次使用的是fixedIncrement的3</span></span><br><span class="line">            count <span class="operator">+=</span> amount</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.ThreeSource类遵循了CounterDataSource协议</span></span><br><span class="line"><span class="comment">//它实现了可选属性fixedIncrement，而并未实现incrementForCount方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreeSource</span>: <span class="title class_">NSObject</span>, <span class="title class_">CounterDataSource</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> fixedIncrement <span class="operator">=</span> <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.使用ThreeSource实例作为Counter实例的数据源对象</span></span><br><span class="line"><span class="keyword">var</span> counter <span class="operator">=</span> <span class="type">Counter</span>()</span><br><span class="line">counter.dataSource <span class="operator">=</span> <span class="type">ThreeSource</span>()</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">_</span> <span class="keyword">in</span> <span class="number">1</span><span class="operator">...</span><span class="number">4</span> &#123;</span><br><span class="line">    counter.increment()</span><br><span class="line">    <span class="built_in">print</span>(counter.count)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试结果：</span></span><br><span class="line"><span class="comment">//3</span></span><br><span class="line"><span class="comment">//6</span></span><br><span class="line"><span class="comment">//9</span></span><br><span class="line"><span class="comment">//12</span></span><br></pre></td></tr></table></figure><p>注意：严格来讲，<code>CounterDataSource</code>协议中的方法和属性都是可选的，因此遵循协议的类可以不实现这些要求，尽管技术上允许这样做，不过最好不要这样写；</p><h4 id="十三、协议扩展"><a href="#十三、协议扩展" class="headerlink" title="十三、协议扩展"></a>十三、协议扩展</h4><p>协议可以通过扩展来为遵循协议的类型提供属性、方法以及下标的实现。通过这种方式，你可以基于协议本身来实现这些功能，而无需在每个遵循协议的类型中都重复同样的实现，也无需使用全局函数。</p><p>下面的代码演示了协议扩展的用法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//协议：定义random函数生成随机数方法</span></span><br><span class="line"><span class="keyword">protocol</span> <span class="title class_">RandomNumProtocol</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">random</span>() -&gt; <span class="type">Double</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//扩展RandomNumProtocol协议，增加了randomBool方法</span></span><br><span class="line"><span class="comment">//注意：通过协议扩展，所有遵循协议的类型都能自动获得这个扩展所增加的方法实现，无需任何额外修改</span></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">RandomNumProtocol</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">randomBool</span>() -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> random() <span class="operator">&gt;</span> <span class="number">0.5</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//遵循协议的类：一个实现了RandomNumProtocol协议的类</span></span><br><span class="line"><span class="comment">//RandomNum类只实现了协议方法random()，但是同样可以使用协议扩展里的方法randomBool()</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RandomNum</span>: <span class="title class_">RandomNumProtocol</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> lastRandom <span class="operator">=</span> <span class="number">42.0</span></span><br><span class="line">    <span class="keyword">let</span> m <span class="operator">=</span> <span class="number">139968.0</span></span><br><span class="line">    <span class="keyword">let</span> a <span class="operator">=</span> <span class="number">3877.0</span></span><br><span class="line">    <span class="keyword">let</span> c <span class="operator">=</span> <span class="number">29573.0</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">random</span>() -&gt; <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="comment">//使用truncatingRemainder方法进行浮点数取余</span></span><br><span class="line">        lastRandom <span class="operator">=</span> (lastRandom <span class="operator">*</span> a <span class="operator">+</span> c).truncatingRemainder(dividingBy: m)</span><br><span class="line">        <span class="keyword">return</span> lastRandom <span class="operator">/</span> m</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试代码：</span></span><br><span class="line"><span class="keyword">let</span> generator <span class="operator">=</span> <span class="type">RandomNum</span>()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Here&#x27;s a random number: <span class="subst">\(generator.random())</span>&quot;</span>)</span><br><span class="line"><span class="comment">//打印：Here&#x27;s a random number: 0.37464991998171</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;And here&#x27;s a random Boolean: <span class="subst">\(generator.randomBool())</span>&quot;</span>)</span><br><span class="line"><span class="comment">//打印：And here&#x27;s a random Boolean: true</span></span><br></pre></td></tr></table></figure><h5 id="13-1-提供默认实现"><a href="#13-1-提供默认实现" class="headerlink" title="13.1.提供默认实现"></a>13.1.提供默认实现</h5><p>可以通过协议扩展来为协议要求的属性、方法以及下标提供默认的实现。但是，如果遵循协议的类型也为这些要求提供了自己的实现，那么这些自定义实现将会替代扩展中的默认实现被使用。</p><p>注意：通过协议扩展为协议要求提供的默认实现，这和可选的协议要求不同；虽然在这两种情况下，遵循协议的类型都无需自己实现这些要求，但是通过扩展提供的默认实现可以直接调用，而无需使用可选链式调用。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//协议：一个宠物协议，定义发出声音的方法makeSound</span></span><br><span class="line"><span class="keyword">protocol</span> <span class="title class_">PetProtocol</span>&#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">makeSound</span>()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//扩展协议：提供默认方法实现</span></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">PetProtocol</span>&#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">makeSound</span>()&#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;aaaaaa。。。。&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>:<span class="title class_">PetProtocol</span>&#123;</span><br><span class="line">     <span class="comment">//因为有协议扩展，已经提供了默认的方法实现；所以这里只遵循了协议</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>:<span class="title class_">PetProtocol</span>&#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">makeSound</span>() &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;汪汪汪。。。。&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试代码：</span></span><br><span class="line"><span class="keyword">let</span> cat <span class="operator">=</span> <span class="type">Cat</span>();</span><br><span class="line">cat.makeSound();  <span class="comment">//打印：aaaaaa。。。。</span></span><br><span class="line"><span class="keyword">let</span> dog <span class="operator">=</span> <span class="type">Dog</span>();</span><br><span class="line">dog.makeSound()   <span class="comment">//打印：汪汪汪。。。。</span></span><br></pre></td></tr></table></figure><h5 id="13-2-为协议扩展添加限制条件"><a href="#13-2-为协议扩展添加限制条件" class="headerlink" title="13.2.为协议扩展添加限制条件"></a>13.2.为协议扩展添加限制条件</h5><p>在扩展协议的时候，可以指定一些限制条件，只有遵循协议的类型满足这些限制条件时，才能获得协议扩展提供的默认实现。这些限制条件写在协议名之后，使用 <code>where</code>子句来描述 例如:你可以扩展<code>Collection</code>协议，通过限制集合元素遵循<code>Equatable</code> 协议， 作为标准库的一部分，你可以使用&#x3D;&#x3D;和!&#x3D;操作符来检查两个元素的等价性和非等价性；</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Collection</span> <span class="title class_">where</span> <span class="title class_">Element</span>: <span class="title class_">Equatable</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">allEqual</span>() -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> element <span class="keyword">in</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> element <span class="operator">!=</span> <span class="keyword">self</span>.first &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果集合中的所有元素都一致，allEqual()方法才返回 true</span></span><br><span class="line"><span class="keyword">let</span> equalNumbers <span class="operator">=</span> [<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>]</span><br><span class="line"><span class="built_in">print</span>(equalNumbers.allEqual())      <span class="comment">//打印 &quot;true&quot;</span></span><br><span class="line"><span class="keyword">let</span> differentNumbers <span class="operator">=</span> [<span class="number">100</span>, <span class="number">100</span>, <span class="number">200</span>, <span class="number">100</span>, <span class="number">200</span>]</span><br><span class="line"><span class="built_in">print</span>(differentNumbers.allEqual())  <span class="comment">//打印 &quot;false&quot;</span></span><br></pre></td></tr></table></figure><p>注意：<strong>如果多个协议扩展都为同一个协议要求提供了默认实现，而遵循协议的类型又同时满足这些协议扩展的限制条件，那么将会使用限制条件最多的那个协议扩展提供的默认实现。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;协议&lt;/strong&gt;：是定义一些规范(属性、功能方法)，然后由类、结构体或者枚举遵循并实现这些规范，这一过程被称为遵循了协议；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主要内容：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;协议的基本语法&lt;/li&gt;
&lt;li&gt;定义协议</summary>
      
    
    
    
    <category term="Swift" scheme="https://wuyubeichen.github.io/categories/Swift/"/>
    
    
    <category term="Swift" scheme="https://wuyubeichen.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift学习09-扩展</title>
    <link href="https://wuyubeichen.github.io/2018/08/09/Swift%E5%AD%A6%E4%B9%A009-%E6%89%A9%E5%B1%95/"/>
    <id>https://wuyubeichen.github.io/2018/08/09/Swift%E5%AD%A6%E4%B9%A009-%E6%89%A9%E5%B1%95/</id>
    <published>2018-08-09T10:11:32.000Z</published>
    <updated>2022-08-19T08:10:38.394Z</updated>
    
    <content type="html"><![CDATA[<p><strong>扩展</strong>：就是为一个已有的类、结构体、枚举类型或者协议类型添加新功能。这包括在没有权限获取原始源代码的情况下扩展类型的能力(即逆向建模 )</p><p><strong>主要内容：</strong></p><ol><li>理解扩展</li><li>扩展的基本使用</li><li>嵌套类型</li><li>扩展系统类库</li></ol><h4 id="一、理解扩展"><a href="#一、理解扩展" class="headerlink" title="一、理解扩展"></a>一、理解扩展</h4><h5 id="1-1-扩展特点："><a href="#1-1-扩展特点：" class="headerlink" title="1.1.扩展特点："></a>1.1.扩展特点：</h5><ol><li>扩展和 <code>Objective-C</code> 中的分类类似，但与之不同的是，<code>Swift</code> 的扩展没有名字；</li><li>扩展可以为一个类型添加新的功能，但是不能重写已有的功能；</li></ol><h5 id="1-2-扩展功能："><a href="#1-2-扩展功能：" class="headerlink" title="1.2.扩展功能："></a>1.2.扩展功能：</h5><ol><li>添加计算型实例属性和计算型类型属性。</li><li>定义实例方法和类型方法</li><li>提供新便利构造器和便利析构器</li><li>定义下标</li><li>定义和使用新的嵌套类型</li><li>使一个已有类型符合某个协议”</li></ol><h5 id="1-3-使用注意："><a href="#1-3-使用注意：" class="headerlink" title="1.3.使用注意："></a>1.3.使用注意：</h5><ol><li>不可以添加存储属性，也不可以为已有属性添加属性观察器</li><li>扩展中不能为类添加新的指定构造器，因为指定构造器和析构器必须由原始的类来实现</li><li>扩展可以为一个类型添加新的功能，但是不能重写已有的功能。</li><li>通过扩展为一个已有类型添加新功能，那么新功能对该类型的所有已有实例都是可用的，即使它们是在这个扩展定义之前创建的。</li></ol><h4 id="二、扩展的基本使用"><a href="#二、扩展的基本使用" class="headerlink" title="二、扩展的基本使用"></a>二、扩展的基本使用</h4><p>定义如下的<code>Point</code> 、<code>Size</code>、<code>Rectangle</code>，并对其进行扩展。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span>  <span class="title class_">Point</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">var</span> y <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Size</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> width <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">var</span> height <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> origin:<span class="type">Point</span> <span class="operator">=</span> <span class="type">Point</span>()</span><br><span class="line">    <span class="keyword">var</span> size <span class="operator">=</span> <span class="type">Size</span>()</span><br><span class="line">    <span class="keyword">init</span> (<span class="params">origin</span>:<span class="type">Point</span>, <span class="params">size</span>: <span class="type">Size</span>)&#123;</span><br><span class="line">        <span class="keyword">self</span>.origin <span class="operator">=</span> origin</span><br><span class="line">        <span class="keyword">self</span>.size <span class="operator">=</span> size</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-1-扩展属性"><a href="#2-1-扩展属性" class="headerlink" title="2.1.扩展属性"></a>2.1.扩展属性</h5><p>扩展可以添加新的计算型属性，但是不可以添加存储型属性，也不可以为已有属性添加属性观察器</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Rectangle</span>&#123;</span><br><span class="line">    <span class="comment">//注意：扩展不能扩展存储型属性</span></span><br><span class="line">    <span class="comment">//var center:Point = Point() //报错</span></span><br><span class="line">    <span class="comment">//只能扩展计算型属性</span></span><br><span class="line">    <span class="keyword">var</span> center: <span class="type">Point</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> center_x <span class="operator">=</span> origin.x <span class="operator">+</span> size.width<span class="operator">/</span><span class="number">2</span></span><br><span class="line">            <span class="keyword">let</span> center_y <span class="operator">=</span> origin.y <span class="operator">+</span> size.height<span class="operator">/</span><span class="number">2</span></span><br><span class="line">            <span class="keyword">return</span> <span class="type">Point</span>(x: center_x, y: center_y)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span>&#123;</span><br><span class="line">            origin.x <span class="operator">=</span> newValue.x <span class="operator">-</span> size.width<span class="operator">/</span><span class="number">2</span></span><br><span class="line">            origin.y <span class="operator">=</span> newValue.y <span class="operator">-</span> size.height<span class="operator">/</span><span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> rect1 <span class="operator">=</span> <span class="type">Rectangle</span>(origin: <span class="type">Point</span>(x:<span class="number">0</span>,y:<span class="number">0</span>), size: <span class="type">Size</span>(width: <span class="number">100</span>, height: <span class="number">100</span>))</span><br><span class="line"><span class="built_in">print</span>(rect1.center)              <span class="comment">//Point(x: 50.0, y: 50.0)</span></span><br><span class="line">rect1.center <span class="operator">=</span> <span class="type">Point</span>(x: <span class="number">0</span>, y: <span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(rect1.center)              <span class="comment">//Point(x: 0.0, y: 0.0)</span></span><br></pre></td></tr></table></figure><h5 id="2-2-扩展方法"><a href="#2-2-扩展方法" class="headerlink" title="2.2.扩展方法"></a>2.2.扩展方法</h5><p>扩展可以为已有类型添加新的实例方法和类型方法。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Rectangle</span>&#123;</span><br><span class="line">    <span class="comment">//注意：这里直接修改了属性，如果是结构体Struct，不能直接这样修改</span></span><br><span class="line">    <span class="comment">//func之前需要使用 mutating</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">translate</span>(<span class="params">x</span>:<span class="type">Double</span> , <span class="params">y</span>:<span class="type">Double</span>)&#123;</span><br><span class="line">        <span class="keyword">self</span>.origin.x <span class="operator">+=</span> x</span><br><span class="line">        <span class="keyword">self</span>.origin.y <span class="operator">+=</span> y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> rect2  <span class="operator">=</span> <span class="type">Rectangle</span>(origin: <span class="type">Point</span>(x:<span class="number">0</span>,y:<span class="number">0</span>), size: <span class="type">Size</span>(width: <span class="number">100</span>, height: <span class="number">100</span>))</span><br><span class="line">rect2.translate(x: <span class="number">100</span>, y: <span class="number">100</span>)</span><br><span class="line"><span class="built_in">print</span>(rect2.center)     <span class="comment">//Point(x: 150.0, y: 150.0)</span></span><br></pre></td></tr></table></figure><h5 id="2-3-扩展构造器"><a href="#2-3-扩展构造器" class="headerlink" title="2.3.扩展构造器"></a>2.3.扩展构造器</h5><p>扩展能为类添加新的便利构造器，但是它们不能为类添加新的指定构造器或析构器。指定构造器和析构器必须总是由原始的类实现提供.</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Rectangle</span>&#123;</span><br><span class="line">    <span class="comment">//注意：在扩展中添加了构造函数，必须是便利构造函数，其中调用指定构造函数</span></span><br><span class="line">    <span class="keyword">convenience</span> <span class="keyword">init</span>(<span class="params">center</span>:<span class="type">Point</span>, <span class="params">size</span>:<span class="type">Size</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> origin_x <span class="operator">=</span> center.x <span class="operator">-</span> size.width<span class="operator">/</span><span class="number">2</span></span><br><span class="line">        <span class="keyword">let</span> origin_y <span class="operator">=</span> center.y <span class="operator">-</span> size.height<span class="operator">/</span><span class="number">2</span></span><br><span class="line">        <span class="comment">//便利构造函数必须调用指定构造函数</span></span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(origin:<span class="type">Point</span>(x: origin_x, y: origin_y),size:size)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> rect3 <span class="operator">=</span> <span class="type">Rectangle</span>(center: <span class="type">Point</span>(x:<span class="number">200</span>, y:<span class="number">200</span>), size: <span class="type">Size</span>(width: <span class="number">100</span>, height: <span class="number">100</span>))</span><br></pre></td></tr></table></figure><p><strong>注意1：</strong>如果你使用扩展提供了一个新的构造器，你依旧有责任确保构造过程能够让实例完全初始化。</p><p><strong>注意2：</strong>如果你使用扩展为一个值类型添加构造器，同时该值类型的原始实现中未定义任何定制的构造器且所有存储属性提供了默认值，那么我们就可以在扩展中的构造器里调用默认构造器和逐一成员构造器。</p><h5 id="2-4-扩展下标"><a href="#2-4-扩展下标" class="headerlink" title="2.4.扩展下标"></a>2.4.扩展下标</h5><p>扩展可以为已有类型添加新下标。下面的例子为Swift内建类型Int添加了一个整型下标。该下标 [n] 返回十进制数字从右向左数的第n个数字：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Int</span> &#123;</span><br><span class="line">    <span class="keyword">subscript</span>(<span class="params">digitIndex</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> decimalBase <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> <span class="keyword">_</span> <span class="keyword">in</span> <span class="number">0</span><span class="operator">..&lt;</span>digitIndex &#123;</span><br><span class="line">            decimalBase <span class="operator">*=</span> <span class="number">10</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">self</span> <span class="operator">/</span> decimalBase) <span class="operator">%</span> <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//测试代码：</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">746381295</span>[<span class="number">3</span>]) <span class="comment">//1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">746381295</span>[<span class="number">6</span>]) <span class="comment">//6</span></span><br></pre></td></tr></table></figure><h4 id="三、嵌套类型"><a href="#三、嵌套类型" class="headerlink" title="三、嵌套类型"></a>三、嵌套类型</h4><p>扩展可以为已有的类、结构体和枚举添加新的嵌套类型。在下面的示例中，<code>Rectangle</code>中就嵌套一个枚举类型，用以获取矩形的各个定点坐标。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Rectangle</span>&#123;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Vertex</span>:<span class="title class_">Int</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">TopLeft</span></span><br><span class="line">        <span class="keyword">case</span> <span class="type">TopRight</span></span><br><span class="line">        <span class="keyword">case</span> <span class="type">BottomLeft</span></span><br><span class="line">        <span class="keyword">case</span> <span class="type">BottomRight</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//扩展出一个方法来获取各个顶点坐标</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">pointAtVertex</span>(<span class="params">v</span>:<span class="type">Vertex</span>) -&gt; <span class="type">Point</span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> v &#123;</span><br><span class="line">        <span class="keyword">case</span> .<span class="type">TopLeft</span>:</span><br><span class="line">            <span class="keyword">return</span> origin</span><br><span class="line">        <span class="keyword">case</span> .<span class="type">TopRight</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="type">Point</span>(x: origin.x <span class="operator">+</span> size.width, y: origin.y)</span><br><span class="line">        <span class="keyword">case</span> .<span class="type">BottomLeft</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="type">Point</span>(x: origin.x, y: origin.y <span class="operator">+</span> size.height)</span><br><span class="line">        <span class="keyword">case</span> .<span class="type">BottomRight</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="type">Point</span>(x: origin.x <span class="operator">+</span> size.width, y: origin.y <span class="operator">+</span> size.height)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//扩展下标</span></span><br><span class="line">    <span class="keyword">subscript</span> (<span class="params">index</span>:<span class="type">Int</span>) -&gt;<span class="type">Point</span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>(index <span class="operator">&gt;=</span> <span class="number">0</span> <span class="operator">&amp;&amp;</span> index<span class="operator">&lt;</span><span class="number">4</span>,<span class="string">&quot;out of range&quot;</span>)</span><br><span class="line">        <span class="comment">//修改枚举的原始值是Int类型，而这里🈶使用rowValue方法构建了枚举型</span></span><br><span class="line">        <span class="keyword">return</span> pointAtVertex(v: <span class="type">Vertex</span>(rawValue: index)<span class="operator">!</span>)  <span class="comment">//已经使用了断言，这里使用强制解包</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试代码：</span></span><br><span class="line"><span class="keyword">let</span> rect4  <span class="operator">=</span> <span class="type">Rectangle</span>(origin: <span class="type">Point</span>(x:<span class="number">0</span>,y:<span class="number">0</span>), size: <span class="type">Size</span>(width: <span class="number">100</span>, height: <span class="number">100</span>))</span><br><span class="line"><span class="keyword">let</span> point1 <span class="operator">=</span> rect4.pointAtVertex(v: .<span class="type">TopRight</span>)</span><br><span class="line"><span class="built_in">print</span>(point1)    <span class="comment">//Point(x: 100.0, y: 0.0)</span></span><br><span class="line"><span class="keyword">let</span> point2 <span class="operator">=</span> rect4.pointAtVertex(v: <span class="type">Rectangle</span>.<span class="type">Vertex</span>.<span class="type">BottomRight</span>)</span><br><span class="line"><span class="built_in">print</span>(point2)    <span class="comment">//Point(x: 100.0, y: 0.0)</span></span><br><span class="line"><span class="keyword">let</span> point3 <span class="operator">=</span> rect4[<span class="number">2</span>]</span><br><span class="line"><span class="built_in">print</span>(point3)    <span class="comment">//Po</span></span><br></pre></td></tr></table></figure><h4 id="四、扩展系统类库"><a href="#四、扩展系统类库" class="headerlink" title="四、扩展系统类库"></a>四、扩展系统类库</h4><h5 id="4-1-扩展Double"><a href="#4-1-扩展Double" class="headerlink" title="4.1.扩展Double"></a>4.1.扩展Double</h5><p>扩展<code>Double</code>，为其添加计算型属性，提供与距离单位协作的基本支持。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Double</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> km: <span class="type">Double</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span> <span class="operator">*</span> <span class="number">1_000.0</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> m : <span class="type">Double</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> cm: <span class="type">Double</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span> <span class="operator">/</span> <span class="number">100.0</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> mm: <span class="type">Double</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span> <span class="operator">/</span> <span class="number">1_000.0</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> ft: <span class="type">Double</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span> <span class="operator">/</span> <span class="number">3.28084</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//测试代码：</span></span><br><span class="line"><span class="keyword">let</span> distance1 <span class="operator">=</span> <span class="number">25.4</span>.mm</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;distance1 is <span class="subst">\(distance1)</span> meters&quot;</span>)    <span class="comment">//distance1 is 0.0254 meters</span></span><br><span class="line"><span class="keyword">let</span> distance2 <span class="operator">=</span> <span class="number">42</span>.mm <span class="operator">+</span> <span class="number">1</span>.km</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;disatance2 is <span class="subst">\( distance2)</span> meters&quot;</span>)  <span class="comment">//disatance2 is 1000.042 meters</span></span><br></pre></td></tr></table></figure><h5 id="4-2-扩展Int类"><a href="#4-2-扩展Int类" class="headerlink" title="4.2.扩展Int类"></a>4.2.扩展Int类</h5><p>扩展Int，为其添加平方、立方、范围判断等方法。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Int</span>&#123;</span><br><span class="line">    <span class="comment">//平方运算</span></span><br><span class="line">    <span class="keyword">var</span> square:<span class="type">Int</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span> <span class="operator">*</span> <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//立方运算</span></span><br><span class="line">    <span class="keyword">var</span> cube:<span class="type">Int</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span> <span class="operator">*</span> <span class="keyword">self</span> <span class="operator">*</span> <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断整型是否在某个范围内</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">inRange</span>(<span class="params">closedLeft</span>:<span class="type">Int</span>, <span class="params">opendRight</span>:<span class="type">Int</span>) -&gt; <span class="type">Bool</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span> <span class="operator">&gt;=</span> closedLeft <span class="operator">&amp;&amp;</span> <span class="keyword">self</span> <span class="operator">&lt;</span> opendRight</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过传入一个闭包参数，简单的实现循环操作</span></span><br><span class="line">   <span class="keyword">func</span>  <span class="title function_">repetitions</span>(<span class="params">task</span>: () -&gt; <span class="type">Void</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="keyword">_</span> <span class="keyword">in</span> <span class="number">0</span><span class="operator">...</span><span class="number">10</span>&#123;</span><br><span class="line">        <span class="comment">//执行闭包</span></span><br><span class="line">            task()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//测试代码：</span></span><br><span class="line"><span class="keyword">var</span> tempNum <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">tempNum.square()        <span class="comment">//100</span></span><br><span class="line">tempNum.inRange(closedLeft: <span class="number">10</span>, opendRight: <span class="number">100</span>)   <span class="comment">//false</span></span><br><span class="line">tempNum.repetitions &#123;</span><br><span class="line">    <span class="built_in">print</span>(tempNum)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;扩展&lt;/strong&gt;：就是为一个已有的类、结构体、枚举类型或者协议类型添加新功能。这包括在没有权限获取原始源代码的情况下扩展类型的能力(即逆向建模 )&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主要内容：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;理解扩展&lt;/li&gt;</summary>
      
    
    
    
    <category term="Swift" scheme="https://wuyubeichen.github.io/categories/Swift/"/>
    
    
    <category term="Swift" scheme="https://wuyubeichen.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift学习08-泛型</title>
    <link href="https://wuyubeichen.github.io/2018/08/08/Swift%E5%AD%A6%E4%B9%A008-%E6%B3%9B%E5%9E%8B/"/>
    <id>https://wuyubeichen.github.io/2018/08/08/Swift%E5%AD%A6%E4%B9%A008-%E6%B3%9B%E5%9E%8B/</id>
    <published>2018-08-08T10:01:32.000Z</published>
    <updated>2022-08-19T08:10:31.771Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Swift泛型</strong>：允许根据自定义的需求，编写出适用于任意类型、灵活可重用的函数及类型。它能让你避免代码的重复，用一种清晰和抽象的方式来表达代码的意图；</p><p><strong>主要内容：</strong></p><ol><li>泛型解决的问题</li><li>泛型函数</li><li>泛型类型</li><li>扩展一个泛型类型</li><li>泛型的类型约束</li><li>关联类型</li></ol><h4 id="一、泛型解决的问题"><a href="#一、泛型解决的问题" class="headerlink" title="一、泛型解决的问题"></a>一、泛型解决的问题</h4><p><code>Swift</code>泛型代码让你能够根据自定义的需求，编写出适用于任意类型、灵活可重用的函数及类型。它能让你避免代码的重复，用一种清晰和抽象的方式来表达代码的意图。这种说法很模糊，下面我们结合一个示例来说明泛型的作用。</p><p>需求描述：使用函数来交换两个变量的值</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//互换两个整型</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">swapTwoInt</span>(<span class="params">a</span>:<span class="keyword">inout</span> <span class="type">Int</span> , <span class="params">b</span>:<span class="keyword">inout</span> <span class="type">Int</span>)&#123;</span><br><span class="line">    (a, b) <span class="operator">=</span> (b, a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//互换两个Double</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">swapTwoDouble</span>(<span class="params">a</span>:<span class="keyword">inout</span> <span class="type">Double</span>, <span class="params">b</span>:<span class="keyword">inout</span> <span class="type">Double</span>)&#123;</span><br><span class="line">    (a,b) <span class="operator">=</span> (b,a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码分析： <code>swapTwoInt</code>与<code>swapTwoDouble</code>两个函数功能相同，唯一的区别就是传入的变量类型不同。这样的代码看起来重复又累赘。在实际应用中，通常需要一个更实用更灵活的函数来交换两个任意类型的值，幸运的是，泛型代码帮你解决了这种问题。</p><h4 id="二、泛型函数"><a href="#二、泛型函数" class="headerlink" title="二、泛型函数"></a>二、泛型函数</h4><p>泛型函数可以适用于任何类型，下面的<code>swapTwoValues(_:_:)</code>函数是上面两个函数的泛型版本,可以交换任意类型的两个变量。</p><p>尖括号里声明一种通用类型T，参数列表里可以使用这种类型名表示通用类型</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">SwapTwoThing</span>&lt;<span class="type">T</span>&gt;(<span class="params">a</span>:<span class="keyword">inout</span> <span class="type">T</span>, <span class="params">b</span>:<span class="keyword">inout</span> <span class="type">T</span>)&#123;</span><br><span class="line">    (a, b) <span class="operator">=</span> (b, a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a <span class="operator">=</span> <span class="number">100</span></span><br><span class="line"><span class="keyword">var</span> b <span class="operator">=</span> <span class="number">200</span></span><br><span class="line">swapTwoInt(a: <span class="operator">&amp;</span>a , b: <span class="operator">&amp;</span>b)</span><br><span class="line">a  <span class="comment">//200</span></span><br><span class="line">b  <span class="comment">//100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> string1 <span class="operator">=</span> <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="keyword">var</span> string2 <span class="operator">=</span> <span class="string">&quot;world&quot;</span></span><br><span class="line"><span class="type">SwapTwoThing</span>(a: <span class="operator">&amp;</span>string1, b: <span class="operator">&amp;</span>string2)</span><br><span class="line">string1  <span class="comment">//world</span></span><br><span class="line">string2  <span class="comment">//hello</span></span><br></pre></td></tr></table></figure><p>总结泛型函数的使用：</p><ol><li>使用了占位类型名(<code>T</code>)，来替换实际类型名<code>(Int，Double)</code>；</li><li>占位类型符并不指定<code>T</code>必须是什么类型，但是却限制了参数<code>a</code>和<code>b</code>必须是同一种类型T；</li><li>只有<code>SwapTwoValues&lt;T&gt;(_:_)</code>函数在调用时，才能根据所传入的实际类型决定<code>T</code>所代表的类型；</li><li><code>T</code>只是一个符号，可以使用大写字母开头的驼峰命名法（例如<code>T</code>和<code>MyTypeParameter</code>)来为类型参数命名，以表明它们是占位类型，而不是一个值。</li></ol><h4 id="三、泛型类型"><a href="#三、泛型类型" class="headerlink" title="三、泛型类型"></a>三、泛型类型</h4><h5 id="3-1-系统类型使用到的泛型"><a href="#3-1-系统类型使用到的泛型" class="headerlink" title="3.1.系统类型使用到的泛型"></a>3.1.系统类型使用到的泛型</h5><p>事实上，泛型类型的使用贯穿了<code>Swift</code>语言。例如，<code>Swift</code>的<code>Array</code>和<code>Dictionary</code>都是泛型集合。你可以创建一个<code>Int</code>数组，也可创建一个<code>String</code>数组。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr <span class="operator">=</span> <span class="type">Array</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line"><span class="keyword">let</span> dict <span class="operator">=</span> <span class="type">Dictionary</span>&lt;<span class="type">String</span>,<span class="type">Int</span>&gt;()</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">set</span>  <span class="operator">=</span> <span class="type">Set</span>&lt;<span class="type">Float</span>&gt;()</span><br></pre></td></tr></table></figure><h5 id="3-2-自定义泛型类型：实现一个栈结构体"><a href="#3-2-自定义泛型类型：实现一个栈结构体" class="headerlink" title="3.2.自定义泛型类型：实现一个栈结构体"></a>3.2.自定义泛型类型：实现一个栈结构体</h5><p>除了泛型函数，Swift还允许你定义泛型类型；这些自定义类、结构体和枚举可以适用于任何类型，类似于Array和 Dictionary。下面的示例就是创建一个具有栈功能的结构体，适用于各种类型。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Stack</span>&lt;<span class="title class_">Element</span>&gt;&#123;</span><br><span class="line">    <span class="comment">//存放栈中变量的数组</span></span><br><span class="line">    <span class="keyword">var</span> items <span class="operator">=</span> <span class="type">Array</span>&lt;<span class="type">Element</span>&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//入栈：向栈中添加一个新元素</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">push</span>(<span class="params">item</span>:<span class="type">Element</span>)&#123;</span><br><span class="line">        items.append(item)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//出栈：删除栈顶元素,并返回此元素</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">pop</span>() -&gt;<span class="type">Element</span>?&#123;</span><br><span class="line">        <span class="keyword">return</span> items.removeLast()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> stack <span class="operator">=</span> <span class="type">Stack</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line">stack.push(item: <span class="number">11</span>)</span><br><span class="line">stack.push(item: <span class="number">22</span>)</span><br><span class="line">stack.pop()   <span class="comment">//22</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> stack1 <span class="operator">=</span> <span class="type">Stack</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line">stack1.push(item:<span class="string">&quot;aaa&quot;</span>)</span><br><span class="line">stack1.push(item:<span class="string">&quot;bbb&quot;</span>)</span><br><span class="line">stack1.pop()  <span class="comment">//“bbb&quot;</span></span><br></pre></td></tr></table></figure><h5 id="3-3-自定义泛型类型：多个占位符"><a href="#3-3-自定义泛型类型：多个占位符" class="headerlink" title="3.3.自定义泛型类型：多个占位符"></a>3.3.自定义泛型类型：多个占位符</h5><p>自定义泛型类型可以设置多个类型占位符，下面就是自定义了一个泛型类型Pair，它具有两个占位类型符。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Pair</span>&lt;<span class="title class_">T1</span>, <span class="title class_">T2</span>&gt;&#123;</span><br><span class="line">    <span class="keyword">var</span> t1:<span class="type">T1</span></span><br><span class="line">    <span class="keyword">var</span> t2:<span class="type">T2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> pair1 <span class="operator">=</span> <span class="type">Pair</span>(t1: <span class="string">&quot;hello&quot;</span>, t2: <span class="string">&quot;hi&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(pair1)   <span class="comment">//Pair&lt;String, String&gt;(t1: &quot;hello&quot;, t2: &quot;hi&quot;)</span></span><br><span class="line"><span class="keyword">var</span> pair2:<span class="type">Pair</span>&lt;<span class="type">String</span>, <span class="type">Int</span>&gt; <span class="operator">=</span> <span class="type">Pair</span>(t1:<span class="string">&quot;hello&quot;</span>,t2: <span class="number">123</span>)</span><br><span class="line"><span class="built_in">print</span>(pair2)   <span class="comment">//Pair&lt;String, Int&gt;(t1: &quot;hello&quot;, t2: 123)</span></span><br></pre></td></tr></table></figure><h4 id="四、扩展一个泛型类型"><a href="#四、扩展一个泛型类型" class="headerlink" title="四、扩展一个泛型类型"></a>四、扩展一个泛型类型</h4><p>扩展一个泛型类型，可以直接使用原始类型定义中声明的类型参数列表，并且这些来自原始类型中的参数名称会被用作原始定义中类型参数的引用。 比如，我们现在扩展泛型类型Stack，为其添加计算型属性topItem，用于获取栈顶元素，代码示例如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Stack</span> &#123;</span><br><span class="line">    <span class="comment">//返回当前栈顶元素而不会将其从栈中移除</span></span><br><span class="line">    <span class="keyword">var</span> topItem: <span class="type">Element</span>? &#123;</span><br><span class="line">        <span class="keyword">return</span> items.isEmpty <span class="operator">?</span> <span class="literal">nil</span> : items[items.count <span class="operator">-</span> <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> stack3 <span class="operator">=</span> <span class="type">Stack</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line">stack3.push(item:<span class="number">1</span>)</span><br><span class="line">stack3.push(item:<span class="number">2</span>)</span><br><span class="line">stack3.push(item: <span class="number">3</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> topItem <span class="operator">=</span> stack3.topItem&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;栈顶元素:<span class="subst">\(topItem)</span>&quot;</span>)   <span class="comment">//栈顶元素:3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：扩展中的占位类型符需要与原始类保持一致，所以这里用的还是Element。</p><h4 id="五、泛型的类型约束"><a href="#五、泛型的类型约束" class="headerlink" title="五、泛型的类型约束"></a>五、泛型的类型约束</h4><p><code>swapTwoValues(_:_:)</code>函数和<code>Stack</code>类型可以作用于任何类型。但如果可以为泛型函数和泛型类型的类型添加一个特定的类型约束，将会是非常有用的。 通常情况下，我们设置泛型类型约束的时候，会指定一个类型参数必须继承自指定类，或者符合一个特定的协议或协议组合。</p><h5 id="5-1-类型约束语法"><a href="#5-1-类型约束语法" class="headerlink" title="5.1.类型约束语法"></a>5.1.类型约束语法</h5><p>对泛型函数添加类型约束的基本语法如下所示(作用于泛型类型时的语法与之相同)。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在一个类型参数名后面放置一个类名或者协议名，并用冒号进行分隔，来定义类型约束</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">someFunction</span>&lt;<span class="type">T</span>: <span class="type">SomeClass</span>, <span class="type">U</span>: <span class="type">SomeProtocol</span>&gt;(<span class="params">someT</span>: <span class="type">T</span>, <span class="params">someU</span>: <span class="type">U</span>) &#123;</span><br><span class="line">    <span class="comment">// 这里是泛型函数的函数体部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-2-泛型类型约束实践"><a href="#5-2-泛型类型约束实践" class="headerlink" title="5.2.泛型类型约束实践"></a>5.2.泛型类型约束实践</h5><p>下面的泛型函数用于查找数组中某个元素的索引位置；但由于for循环里用到了对象比较”&#x3D;&#x3D;”，要确保所有的类型都适用，所以在泛型函数的中添加了类型约束，使用此泛型函数的参数必须遵循<code>Equatable</code>协议。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">findIndex</span>&lt;<span class="type">T</span>: <span class="type">Equatable</span>&gt;(<span class="params">of</span> <span class="params">valueToFind</span>: <span class="type">T</span>, <span class="params">in</span> <span class="params">array</span>:[<span class="type">T</span>]) -&gt; <span class="type">Int</span>? &#123;</span><br><span class="line">    <span class="keyword">for</span> (index, value) <span class="keyword">in</span> array.enumerated() &#123;</span><br><span class="line">        <span class="keyword">if</span> value <span class="operator">==</span> valueToFind &#123;</span><br><span class="line">            <span class="keyword">return</span> index</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> doubleIndex <span class="operator">=</span> findIndex(of: <span class="number">9.3</span>, in: [<span class="number">3.14159</span>, <span class="number">0.1</span>, <span class="number">0.25</span>])  <span class="comment">//nil</span></span><br><span class="line"><span class="keyword">let</span> stringIndex <span class="operator">=</span> findIndex(of: <span class="string">&quot;Andrea&quot;</span>, in: [<span class="string">&quot;Mike&quot;</span>, <span class="string">&quot;Malcolm&quot;</span>, <span class="string">&quot;Andrea&quot;</span>]) <span class="comment">//2</span></span><br></pre></td></tr></table></figure><p>注意：Swift标准库定义了Equatable协议，该协议要求任何遵循该协议的类型必须实现等式符（&#x3D;&#x3D;）及不等符(!&#x3D;)。从而能对该类型的任意两个值进行比较。所有的Swift标准类型自动支持 Equatable 协议</p><h4 id="六、关联类型"><a href="#六、关联类型" class="headerlink" title="六、关联类型"></a>六、关联类型</h4><p>关联类型是在为协议中的某个类型提供一个占位名，其所代表的实际类型会在协议被采纳时才会被指定。这里涉及到两个关键字，其作用就是给一个类型起一个别名，首先来说明一下：</p><ul><li><strong>associatedtype</strong>：协议声明中使用</li><li><strong>typealias</strong>：协议实现中使用</li></ul><p>下面通过一个示例来理解关联类型的作用：定义一个可称重的协议，其中使用了泛型关联类型。这种方式可以更大程度的使用协议，具体实现协议的时候再决定类型。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">WeightCaclulable</span>&#123;</span><br><span class="line">    <span class="comment">//associatedtype设置别名，即关联类型</span></span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">WeightType</span></span><br><span class="line">    <span class="keyword">var</span> weight:<span class="type">WeightType</span>&#123;<span class="keyword">get</span>&#125; <span class="comment">//返回重量属性，其类型是WeightType</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//iphone7:手机较轻，表示重量时会有小数点，所以使用Double描述</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Iphone7</span>:<span class="title class_">WeightCaclulable</span>&#123;</span><br><span class="line">    <span class="comment">//实现的时候用的是typealias</span></span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">WeightType</span>  <span class="operator">=</span> <span class="type">Double</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> weight: <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.114</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Ship:轮船较重,表示重量可以忽略小数，所以使用Int描述</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ship</span>:<span class="title class_">WeightCaclulable</span>&#123;</span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">WeightType</span> <span class="operator">=</span> <span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> weight: <span class="type">WeightType</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">weight</span>:<span class="type">WeightType</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.weight <span class="operator">=</span> weight</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> iphone7 <span class="operator">=</span> <span class="type">Iphone7</span>()</span><br><span class="line"><span class="built_in">print</span>(iphone7.weight)  <span class="comment">//0.114</span></span><br><span class="line"><span class="keyword">let</span> ship <span class="operator">=</span> <span class="type">Ship</span>(weight: <span class="number">100000</span>)</span><br><span class="line"><span class="built_in">print</span>(ship.weight)     <span class="comment">//100000</span></span><br></pre></td></tr></table></figure><h5 id="6-1-关联类型添加约束"><a href="#6-1-关联类型添加约束" class="headerlink" title="6.1.关联类型添加约束"></a>6.1.关联类型添加约束</h5><p>协议中存在关联类型，我们也可以为其添加约束，下面是一个<code>Container</code>协议，我们设置其关联类型<code>Item</code>遵循了协议<code>Equatable</code>，具体代码如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">Container</span> &#123;</span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Item</span>: <span class="type">Equatable</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">append</span>(<span class="keyword">_</span> <span class="params">item</span>: <span class="type">Item</span>)</span><br><span class="line">    <span class="keyword">var</span> count: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">subscript</span>(<span class="params">i</span>: <span class="type">Int</span>) -&gt; <span class="type">Item</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;Swift泛型&lt;/strong&gt;：允许根据自定义的需求，编写出适用于任意类型、灵活可重用的函数及类型。它能让你避免代码的重复，用一种清晰和抽象的方式来表达代码的意图；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主要内容：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;泛型</summary>
      
    
    
    
    <category term="Swift" scheme="https://wuyubeichen.github.io/categories/Swift/"/>
    
    
    <category term="Swift" scheme="https://wuyubeichen.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift学习07-可选型</title>
    <link href="https://wuyubeichen.github.io/2018/08/07/Swift%E5%AD%A6%E4%B9%A007-%E5%8F%AF%E9%80%89%E5%9E%8B/"/>
    <id>https://wuyubeichen.github.io/2018/08/07/Swift%E5%AD%A6%E4%B9%A007-%E5%8F%AF%E9%80%89%E5%9E%8B/</id>
    <published>2018-08-07T10:14:55.000Z</published>
    <updated>2022-08-19T08:10:26.292Z</updated>
    
    <content type="html"><![CDATA[<p><strong>顾名思义，可选类型表示一个变量可能有值，也可能没有值（nil），但是它的用法却与OC中的nil完全不同</strong></p><p>主要内容：</p><ol><li>可选型使用要点</li><li>可选型解包</li><li>可选链 <code>Option chaining</code></li><li>空合并运算符<code>nil coalesce</code></li><li>隐式可选型</li><li>可选型使用的其他示例</li><li>最后小结</li></ol><h4 id="一、可选型使用要点"><a href="#一、可选型使用要点" class="headerlink" title="一、可选型使用要点"></a>一、可选型使用要点</h4><ol><li>可选类型类似于<code>OC</code>指针的<code>nil</code>值，但是<code>OC</code>中的<code>nil</code>只对类有用，而可选择型中<code>nil</code>对所有类型都可用，更安全</li><li>可选型的声明的方式是<code>“数据类型+问号”</code>。如：<code>var errorCode :Int? = 404</code></li><li>当要使用一个可选类型的变量时，要在后面加感叹号<code>“!”</code>或者<code>“?”</code>。</li><li>不能把一个可选型便量赋值给非可选型的变量, 如：<code>let tempValue = nil</code>，这样会报错；</li><li>可选型数据一般都是可变的，所以可选型的数据也通常是变量；</li><li>声明一个可选型的时候，必须是添加？,swift不能隐式的自动推断可选型；</li></ol><p><code>swift</code>不能用同类中的一个特殊值代表无或者没有，在<code>Swift</code>中，<code>nil</code>代表着没有，但是它却不能直接使用，示例如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> errorCode :<span class="type">Int</span> <span class="operator">=</span> <span class="number">404</span></span><br><span class="line">errorCode <span class="operator">=</span> <span class="literal">nil</span> <span class="comment">//报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//改：使用Int?  声明一个整型可选型</span></span><br><span class="line"><span class="keyword">var</span> errorCode :<span class="type">Int</span>? <span class="operator">=</span> <span class="number">404</span></span><br><span class="line">errorCode <span class="operator">=</span> <span class="literal">nil</span> <span class="comment">//将其声明为为可选型变量才能赋值为nil</span></span><br></pre></td></tr></table></figure><h4 id="二、可选型解包"><a href="#二、可选型解包" class="headerlink" title="二、可选型解包"></a>二、可选型解包</h4><p>一个可选型数据，就意味着其值是可以为<code>nil</code>的，这样的数据不可以直接使用，所以将可选型解包后再使用是十分重要的操作。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接使用</span></span><br><span class="line"><span class="keyword">var</span> errorCode: <span class="type">String</span>? <span class="operator">=</span> <span class="string">&quot;404&quot;</span></span><br><span class="line"><span class="built_in">print</span>(errorCode)</span><br><span class="line"></span><br><span class="line"><span class="comment">//&quot;The errorCode is&quot; +errorCode //直接使用显式可选型会编译不通过，报错</span></span><br></pre></td></tr></table></figure><h5 id="1-解包方法1：普通的if判断，但不方便"><a href="#1-解包方法1：普通的if判断，但不方便" class="headerlink" title="1.解包方法1：普通的if判断，但不方便"></a>1.解包方法1：普通的if判断，但不方便</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(errorCode <span class="operator">!=</span> <span class="literal">nil</span>)&#123;</span><br><span class="line">    <span class="string">&quot;The errorCode is &quot;</span> <span class="operator">+</span> errorCode<span class="operator">!</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="string">&quot;No error&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-解包方法2：强制解包，使用感叹号“-”，存在错误风险"><a href="#2-解包方法2：强制解包，使用感叹号“-”，存在错误风险" class="headerlink" title="2.解包方法2：强制解包，使用感叹号“!”，存在错误风险"></a>2.解包方法2：强制解包，使用感叹号“!”，存在错误风险</h5><p>一般情况下，我们在确定使用的可选型变量不会是nil，才通过!强制解包并使用</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> errorCode: <span class="type">String</span>? <span class="operator">=</span> <span class="string">&quot;404&quot;</span></span><br><span class="line"><span class="string">&quot;The errorCode is &quot;</span> <span class="operator">+</span> errorCode<span class="operator">!</span></span><br></pre></td></tr></table></figure><h5 id="3-解包方法3：尝试解包，使用问号“？”，较为安全"><a href="#3-解包方法3：尝试解包，使用问号“？”，较为安全" class="headerlink" title="3.解包方法3：尝试解包，使用问号“？”，较为安全"></a>3.解包方法3：尝试解包，使用问号“？”，较为安全</h5><p>当不确定使用的可选型变量是否是nil,通过?执行调用方法等操作，意味着不为nil时才可以执行成功</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> errorCode: <span class="type">String</span>? <span class="operator">=</span> <span class="string">&quot;404&quot;</span></span><br><span class="line"><span class="string">&quot;The errorCode is &quot;</span> <span class="operator">+</span> errorCode？</span><br></pre></td></tr></table></figure><h5 id="4-解包方法4：if-let解包-当我们希望在可选型为nil时候，执行别的代码，此时更适合使用if-let方式解包"><a href="#4-解包方法4：if-let解包-当我们希望在可选型为nil时候，执行别的代码，此时更适合使用if-let方式解包" class="headerlink" title="4.解包方法4：if-let解包, 当我们希望在可选型为nil时候，执行别的代码，此时更适合使用if-let方式解包"></a>4.解包方法4：if-let解包, 当我们希望在可选型为nil时候，执行别的代码，此时更适合使用if-let方式解包</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> unwrappedErrorCode <span class="operator">=</span> errorCode&#123;</span><br><span class="line">    <span class="comment">//unwrappedErrorCode 是经过解包的数据，得到非nil值</span></span><br><span class="line">    <span class="string">&quot;The errorCode is&quot;</span> <span class="operator">+</span> unwrappedErrorCode</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">------------</span>优美的分割线<span class="operator">-----------------</span></span><br><span class="line"> <span class="comment">//if-let解包方法的改进：可以使用原来的变量名</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> errorCode <span class="operator">=</span> errorCode&#123;</span><br><span class="line">    <span class="comment">//errorCode 是经过解包的数据，得到非nil值</span></span><br><span class="line">    <span class="comment">//括号内的errorCode 只在此括号内使用</span></span><br><span class="line">    <span class="string">&quot;The errorCode is&quot;</span> <span class="operator">+</span> errorCode</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//处理nil情况</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-解包时注意事项："><a href="#5-解包时注意事项：" class="headerlink" title="5.解包时注意事项："></a>5.解包时注意事项：</h5><p>隐式声明的可选型不需要解包，但是这样可能因为nil报错（详情请看第五部分）</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> blog:<span class="type">String</span>! <span class="operator">=</span> <span class="string">&quot;helloWord&quot;</span></span><br><span class="line"><span class="comment">//blog = nil </span></span><br><span class="line"><span class="string">&quot;My blog is&quot;</span> <span class="operator">+</span> blog</span><br></pre></td></tr></table></figure><p>if-let可以同时解包多个变量，而且因为使用了if，也可以增加判断逻辑</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> errorCode <span class="operator">=</span> errorCode, errorMessage <span class="operator">=</span> </span><br><span class="line">                  errorMessage <span class="keyword">where</span> errorCode <span class="operator">==</span> <span class="string">&quot;404&quot;</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Page not found&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;No error&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="三、可选链-Option-chaining"><a href="#三、可选链-Option-chaining" class="headerlink" title="三、可选链 Option chaining"></a>三、可选链 Option chaining</h4><p>可选链的使用简化了可选型的使用。在某些情况下可以避免<code>if-let</code> 解包的使用，而是通过尝试解包（使用问号<code>？</code>）或者强制解包（感叹号<code>!</code>）来使用操作对象 示例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> errorCodeStr: <span class="type">String</span>? <span class="operator">=</span> <span class="string">&quot;Hello, playground&quot;</span></span><br><span class="line"><span class="comment">//errorCodeStr.uppercaseString ; errorCodeStr是可选型不能直接使用，需要解包如下：</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> errorCodeStr <span class="operator">=</span> errorCodeStr&#123;</span><br><span class="line">    errorCodeStr.uppercaseString</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码使用可选链简化，如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//推荐写法:使用？尝试解包，如果成功就会将字符串大写</span></span><br><span class="line">errorCodeStr<span class="operator">?</span>.uppercaseString</span><br><span class="line"><span class="comment">//不安全写法，当errorCode为nil时报错，除非我们确保errorCodeStr不为nil才能这样写</span></span><br><span class="line">errorCodeStr<span class="operator">!</span>.uppercaseString</span><br></pre></td></tr></table></figure><p>基于这样的使用，可能会出现类似 <code>Person?.address?.addressName</code> 的使用，这就构成了可选链,调用链中任何一个节点为<code>nil</code>,整个调用都会失败，返回<code>nil</code>，使用<code>？</code>是安全的;</p><h4 id="四、空合并运算符nil-coalesce"><a href="#四、空合并运算符nil-coalesce" class="headerlink" title="四、空合并运算符nil coalesce"></a>四、空合并运算符nil coalesce</h4><p>使用空合并运算符，可以解决解包之后的存值问题</p><h5 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> uppperCaseErrorStr <span class="operator">=</span> errorCodeStr<span class="operator">?</span>.uppercaseString</span><br><span class="line"><span class="comment">//uppperCaseErrorStr此时是一个可选型变量，不需要显示声明，因为后面的表达式是可选型</span></span><br><span class="line"><span class="comment">//实现解包同时实现了大写</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> errorCodeStr  <span class="operator">=</span> errorCodeStr<span class="operator">?</span>.uppercaseString&#123;</span><br><span class="line">    errorCodeStr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> errorMessage: <span class="type">String</span>? <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line"><span class="keyword">let</span> message: <span class="type">String</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> errorMessage <span class="operator">=</span> errorMessage&#123;</span><br><span class="line">    message <span class="operator">=</span> errorMessage</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    message <span class="operator">=</span> <span class="string">&quot;no error&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="改进示例2：使用三目运算符"><a href="#改进示例2：使用三目运算符" class="headerlink" title="改进示例2：使用三目运算符"></a>改进示例2：使用三目运算符</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message2 <span class="operator">=</span> errorMessage <span class="operator">==</span> <span class="literal">nil</span> <span class="operator">?</span> <span class="string">&quot;no errror&quot;</span> :errorMessage;</span><br></pre></td></tr></table></figure><p>改进示例2:使用空合并运算符??，如果errorMessage有值，使用errorMessage!赋值</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//？？是空和并运算符</span></span><br><span class="line"><span class="keyword">let</span> message3 <span class="operator">=</span> errorMessage <span class="operator">??</span> <span class="string">&quot;no error&quot;</span></span><br></pre></td></tr></table></figure><h4 id="五、隐式可选型"><a href="#五、隐式可选型" class="headerlink" title="五、隐式可选型"></a>五、隐式可选型</h4><ol><li>区别于显式可选型的创建：类型+<code>？</code>，创建隐式可选型使用：类型+<code>！</code></li><li>隐式可选型变量使用时，相当于其后面自带了一个感叹号，可以直接赋值给一个非可选型变量，但是隐式可选型依然保持可选型的特性，可以被赋值为<code>nil</code>，这就体现出来隐式可选类型的优点,即可用被赋值为<code>nil</code>，也可以不用每次显式的解包</li><li>隐式解析可选类型还可以在类中做属性，解决循环引用问题</li></ol><p>示例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> errorMessage: <span class="type">String</span>! <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line">errorMessage <span class="operator">=</span> <span class="string">&quot;not found&quot;</span></span><br><span class="line"><span class="comment">//这里errorMessage是隐式可选型，使用时候不需要显式的解包，但是如果errorMessage为nil就会报错</span></span><br><span class="line"><span class="string">&quot;The error is &quot;</span> <span class="operator">+</span> errorMessage</span><br></pre></td></tr></table></figure><h4 id="六、可选型使用的其他示例"><a href="#六、可选型使用的其他示例" class="headerlink" title="六、可选型使用的其他示例"></a>六、可选型使用的其他示例</h4><h5 id="示例1"><a href="#示例1" class="headerlink" title="示例1."></a>示例1.</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> error1:(errorCode: <span class="type">Int</span>, errorMessage: <span class="type">String</span>?) <span class="operator">=</span> (<span class="number">404</span> , <span class="string">&quot;page not found&quot;</span>)</span><br><span class="line">error1.errorMessage <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line"><span class="comment">//error1 = nil 整个元组并非可选型，不能使用nil赋值</span></span><br></pre></td></tr></table></figure><h5 id="示例2"><a href="#示例2" class="headerlink" title="示例2."></a>示例2.</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ageInt: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;xyz&quot;</span></span><br><span class="line"><span class="comment">//使用强制转换之后，age是可选型，需要按照可选型的规则去使用</span></span><br><span class="line"><span class="keyword">var</span> age <span class="operator">=</span> <span class="type">Int</span>(ageInt)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> age <span class="operator">=</span> age <span class="keyword">where</span> age <span class="operator">&lt;</span> <span class="number">20</span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;you are a tennager!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="示例3"><a href="#示例3" class="headerlink" title="示例3."></a>示例3.</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> greeting <span class="operator">=</span> <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="comment">//rangeString 返回一个可选型，需要按照可选型的规则去使用</span></span><br><span class="line">greeting.rangeOfString(<span class="string">&quot;ll&quot;</span>) <span class="comment">//2..&lt;4</span></span><br><span class="line">greeting.rangeOf3String(<span class="string">&quot;oo&quot;</span>)<span class="comment">//nil</span></span><br></pre></td></tr></table></figure><hr><h4 id="七、最后小结"><a href="#七、最后小结" class="headerlink" title="七、最后小结"></a>七、最后小结</h4><ol><li>有了可选型，你在声明隐式可选变量或特性的时候就不用指定初始值，因为它有缺省值nil。尤其是在一个创建一个类的属性的时候。</li><li>由于隐式解析可选的值会在使用时自动解析，所以没必要使用操作符!来解析它。但是有可能运行时报错。</li><li>使用可选链会选择性的执行隐式解析可选表达式上的某一个操作。如果值为nil，就不会执行任何操作，因此也不会产生运行错误。</li><li>非可选型的变量或者常量不可能赋值为nil，所以不能使用：notOptioalValue !&#x3D; nil,判断是否nil。这是可选型和非可选型数据的一个明显区别</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;顾名思义，可选类型表示一个变量可能有值，也可能没有值（nil），但是它的用法却与OC中的nil完全不同&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;主要内容：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;可选型使用要点&lt;/li&gt;
&lt;li&gt;可选型解包&lt;/li&gt;
&lt;li&gt;可选链 &lt;code&gt;</summary>
      
    
    
    
    <category term="Swift" scheme="https://wuyubeichen.github.io/categories/Swift/"/>
    
    
    <category term="Swift" scheme="https://wuyubeichen.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift学习06-构造器(下)</title>
    <link href="https://wuyubeichen.github.io/2018/08/06/Swift%E5%AD%A6%E4%B9%A006-%E6%9E%84%E9%80%A0%E5%99%A8(%E4%B8%8B)/"/>
    <id>https://wuyubeichen.github.io/2018/08/06/Swift%E5%AD%A6%E4%B9%A006-%E6%9E%84%E9%80%A0%E5%99%A8(%E4%B8%8B)/</id>
    <published>2018-08-06T10:15:09.000Z</published>
    <updated>2022-08-19T08:10:19.140Z</updated>
    
    <content type="html"><![CDATA[<p><strong>主要内容：</strong></p><ol><li>可失败的构造器</li><li>枚举类型可失败的构造器</li><li>构造失败的传递</li><li>重写一个可失败的构造器</li><li>可失败构造器<code>init!</code></li><li>必要构造器</li><li>通过闭包或函数设置属性的默认值</li></ol><h4 id="一、可失败的构造器"><a href="#一、可失败的构造器" class="headerlink" title="一、可失败的构造器"></a>一、可失败的构造器</h4><p>顾名思义，这是用于我们构造过程可能失败情况的构造器。失败的原因可能是给构造器传入无效的参数值，或缺少某种所需的外部资源，又或是不满足某种必要的条件等。一个可失败构造器示例如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可失败构造器语法是init关键字后面添加问号即(init?) </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> name :<span class="type">String</span></span><br><span class="line">    <span class="keyword">init?</span>(<span class="params">name</span>:<span class="type">String</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> name.isEmpty &#123;</span><br><span class="line">            <span class="comment">//其实Swift构造器并不支持返回值，因为构造器本来就是要确保对象能被正确构造。</span></span><br><span class="line">            <span class="comment">//所以这里使用return nil只是为了表明可失败构造器构造失败。          </span></span><br><span class="line">             <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//参数不为空，继续构造器得到可用的实例</span></span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>： </p><ol><li>可失败构造器的参数名和参数类型，不能与其它非可失败构造器的参数名，及其参数类型相同;</li><li>可失败构造器其实是在构造失败时创建一个类型为自身类型的可选类型的对象;</li></ol><h4 id="二、枚举类型可失败的构造器"><a href="#二、枚举类型可失败的构造器" class="headerlink" title="二、枚举类型可失败的构造器"></a>二、枚举类型可失败的构造器</h4><p>通过枚举类型可失败构造器获取枚举类型中特定的枚举成员，完成构造任务。如果提供的参数无法匹配任何枚举成员则构造失败。使用示例如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">TestNum</span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">First</span>, <span class="type">Second</span>, <span class="type">Third</span></span><br><span class="line">    <span class="keyword">init?</span>(<span class="params">number</span> : <span class="type">Character</span>)&#123;</span><br><span class="line">        <span class="keyword">switch</span> number&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;1&quot;</span>:</span><br><span class="line">            <span class="keyword">self</span> <span class="operator">=</span> .<span class="type">First</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;2&quot;</span>:</span><br><span class="line">            <span class="keyword">self</span> <span class="operator">=</span> .<span class="type">Second</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;3&quot;</span>:</span><br><span class="line">            <span class="keyword">self</span> <span class="operator">=</span> .<span class="type">Third</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不同于以上的写法，swift中还可以使用带原始值的枚举类型可失败构造器。带原始值的枚举类型会自带一个可失败构造器init?(rawValue:)，这里名为rawValue的参数，其类型和枚举类型的原始值类型一致， 如果该参数的值能够和某个枚举成员的原始值匹配，则该构造器会构造相应的枚举成员，否则构造失败。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">TestNum2</span>:<span class="title class_">Character</span>&#123;</span><br><span class="line">    <span class="comment">//枚举值自带原始值</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">First</span> <span class="operator">=</span> <span class="string">&quot;1&quot;</span>, <span class="type">Second</span> <span class="operator">=</span> <span class="string">&quot;2&quot;</span>, <span class="type">Third</span> <span class="operator">=</span> <span class="string">&quot;3&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> number <span class="operator">=</span> <span class="type">TestNum2</span>(rawValue: <span class="string">&quot;6&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> number <span class="operator">==</span> <span class="literal">nil</span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;枚举类型构造失败&quot;</span>)<span class="comment">//此句被打印</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="三、构造失败的传递"><a href="#三、构造失败的传递" class="headerlink" title="三、构造失败的传递"></a>三、构造失败的传递</h4><p>与普通的构造器相似，可失败构造器也是可以代理的。这里包括类、结构体、枚举中的横向代理，也包括子类和父类之间的向上代理。</p><ol><li>无论是向上代理还是横向代理，如果你代理到的其他可失败构造器触发构造失败，整个构造过程将立即终止，接下来的任何构造代码不会再被执行。</li><li>可失败构造器也可以代理到其它的非可失败构造器。通过这种方式，你可以增加一个可能的失败状态到现有的构造过程中；</li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span>!</span><br><span class="line">    <span class="keyword">init?</span>(<span class="params">name</span>: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> name.isEmpty &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CartItem</span>: <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> quantity: <span class="type">Int</span>!</span><br><span class="line">    <span class="keyword">init?</span>(<span class="params">name</span>: <span class="type">String</span>, <span class="params">quantity</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (quantity <span class="operator">&lt;</span> <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//验证quantity不符合要求，就立刻终止构造器，返回nil对象，剩余代码也不再执行</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(name: name)</span><br><span class="line">        <span class="keyword">self</span>.quantity <span class="operator">=</span> quantity</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="四、重写一个可失败的构造器"><a href="#四、重写一个可失败的构造器" class="headerlink" title="四、重写一个可失败的构造器"></a>四、重写一个可失败的构造器</h4><p>既然是重写，这里主要是应用于类中。这里包括两种情况:</p><ol><li>用子类的可失败构造器重写父类的可失败构造器（这种情况针对于可能子类增加了更多的可失败处理）</li><li>用子类的非可失败构造器重写一个父类的可失败构造器。</li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重写一个可失败的构造器一个示例如下：</span></span><br><span class="line"><span class="comment">//父类Person:要求其name属性必须是非空字符串或者nil</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name:<span class="type">String</span>?</span><br><span class="line">    <span class="comment">//该构造器可创建name属性是nil的Person实例</span></span><br><span class="line">    <span class="keyword">init</span>()&#123;&#125;</span><br><span class="line">    <span class="comment">//父类的可失败构造器，当传入参数为空的时候，不能创建有效实例</span></span><br><span class="line">    <span class="keyword">init?</span>(<span class="params">name</span> :<span class="type">String</span>)&#123;</span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">        <span class="keyword">if</span> name.isEmpty&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类Student:</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:<span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>()&#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> <span class="string">&quot;匿名&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//子类的非可失败构造器init(name:)重写了父类的可失败构造器init?(name:)。</span></span><br><span class="line">    <span class="comment">//因为这里很好的处理了空字符串的情况，无论传入参数是否是空字符串，都将创建有效实例</span></span><br><span class="line">    <span class="comment">//注意：可以用非可失败构造器重写可失败构造器，但反过来却不行。</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line">        <span class="keyword">if</span> name.isEmpty&#123;</span><br><span class="line">            <span class="keyword">self</span>.name <span class="operator">=</span> <span class="string">&quot;匿名&quot;</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子类：Teacher:</span></span><br><span class="line"><span class="comment">//我们也可以在子类的非可失败构造器中使用强制解包来调用父类的可失败构造器，具体使用如下:</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span>:<span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(name: <span class="string">&quot;匿名&quot;</span>)<span class="operator">!</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里子类的非可失败构造器重写父类的可失败构造器</span></span><br><span class="line">    <span class="comment">//向上代理到父类的可失败构造器，并对父类的可失败构造器的返回值进行强制解包</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> name.isEmpty&#123;</span><br><span class="line">            <span class="keyword">super</span>.<span class="keyword">init</span>(name: <span class="string">&quot;匿名&quot;</span>)<span class="operator">!</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.<span class="keyword">init</span>(name: name)<span class="operator">!</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="五、可失败构造器init"><a href="#五、可失败构造器init" class="headerlink" title="五、可失败构造器init!"></a>五、可失败构造器init!</h4><p>区别于init?方式的可失败构造器，init!形式的可失败构造器器将创建一个对应类型的隐式解包可选型对象 init?和init!可以相互代理，也可以相互重写。我们也可以用init代理到init!,但是一旦init!构造失败，将触发断言</p><h4 id="六、必要构造器"><a href="#六、必要构造器" class="headerlink" title="六、必要构造器"></a>六、必要构造器</h4><p>在类的构造器前添加required修饰符表明所有该类的子类都必须实现该构造器。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SuperClass</span> &#123;</span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="comment">// 构造器的实现代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubClass</span>: <span class="title class_">SuperClass</span> &#123;</span><br><span class="line">    <span class="comment">//1.子类重写父类的必要构造器，构造器前也必须添加required修饰符，表明该构造器要求也应用于继承链后面的子类。</span></span><br><span class="line">    <span class="comment">//2.但是这里虽然重写父类中必要的指定构造器时，却不需要添加override修饰符：</span></span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="comment">//构造器的实现代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="七、通过闭包或函数设置属性的默认值"><a href="#七、通过闭包或函数设置属性的默认值" class="headerlink" title="七、通过闭包或函数设置属性的默认值"></a>七、通过闭包或函数设置属性的默认值</h4><p>在构造过程中，我们可以使用闭包或全局函数为某个存储型属性提供定制的默认值。 在新实例被创建时，对应的闭包或函数会被调用，其返回值会当做默认值赋值给这个属性, 具体的时候用如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Weather</span> &#123;</span><br><span class="line">    <span class="comment">//常见的一些天气</span></span><br><span class="line">    <span class="keyword">let</span> commonWeather: [<span class="type">String</span>] <span class="operator">=</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> weather <span class="operator">=</span> [<span class="string">&quot;sunny&quot;</span>, <span class="string">&quot;cloud&quot;</span>,<span class="string">&quot;rain&quot;</span>,<span class="string">&quot;snow&quot;</span>];</span><br><span class="line">        <span class="keyword">return</span> weather</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="comment">//打印</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">printCommonWeather</span>()&#123;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span> <span class="operator">..&lt;</span> commonWeather.count &#123;</span><br><span class="line">            <span class="built_in">print</span>(commonWeather[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> weather <span class="operator">=</span> <span class="type">Weather</span>()<span class="comment">//同时初始化了默认属性</span></span><br><span class="line">weather.printCommonWeather()</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;主要内容：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;可失败的构造器&lt;/li&gt;
&lt;li&gt;枚举类型可失败的构造器&lt;/li&gt;
&lt;li&gt;构造失败的传递&lt;/li&gt;
&lt;li&gt;重写一个可失败的构造器&lt;/li&gt;
&lt;li&gt;可失败构造器&lt;code&gt;init!&lt;/code&gt;&lt;</summary>
      
    
    
    
    <category term="Swift" scheme="https://wuyubeichen.github.io/categories/Swift/"/>
    
    
    <category term="Swift" scheme="https://wuyubeichen.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift学习05-构造器(中)</title>
    <link href="https://wuyubeichen.github.io/2018/08/05/Swift%E5%AD%A6%E4%B9%A005-%E6%9E%84%E9%80%A0%E5%99%A8(%E4%B8%AD)/"/>
    <id>https://wuyubeichen.github.io/2018/08/05/Swift%E5%AD%A6%E4%B9%A005-%E6%9E%84%E9%80%A0%E5%99%A8(%E4%B8%AD)/</id>
    <published>2018-08-05T10:15:21.000Z</published>
    <updated>2022-08-19T08:10:05.241Z</updated>
    
    <content type="html"><![CDATA[<p><strong>主要内容：</strong></p><ol><li>构造器简介</li><li>指定构造器和便利构造器</li><li>类的构造器的使用</li></ol><h4 id="一、构造器简介"><a href="#一、构造器简介" class="headerlink" title="一、构造器简介"></a>一、构造器简介</h4><p>本篇继续对<code>Swift</code>中的构造器进行介绍，这里主要说到类的继承和构造。 作为引用类型的类具有的继承特性，这使得类的构造过程较为复杂一些，因为涉及到很多细节性的问题。在使用之前，我们需要了解一些基本的问题：</p><ol><li>类中所有存储属性，包括继承父类的属性，都要在构造过程中设置初值</li><li><code>Swift</code>类的构造器分为指定构造器和便利构造器，确保完成构造过程</li></ol><h4 id="二、指定构造器和便利构造器"><a href="#二、指定构造器和便利构造器" class="headerlink" title="二、指定构造器和便利构造器"></a>二、指定构造器和便利构造器</h4><h5 id="指定构造器："><a href="#指定构造器：" class="headerlink" title="指定构造器："></a>指定构造器：</h5><ul><li>类的主要构造器，负责初始化类中所有属性，在继承关系中可调用父类链中的父类构造器;</li><li>每个类至少一个指定构造器。但是某些情况下，许多类是通过继承父类的指定构造器来满足这个条件;</li></ul><h5 id="便利构造器："><a href="#便利构造器：" class="headerlink" title="便利构造器："></a>便利构造器：</h5><ul><li>辅助类型的构造器，调用同一个类中的指定构造器完成类的初始化操作;</li><li>便利构造器需要在<code>init</code>关键字之前添加<code>convenience</code>关键字，使用空格分开;</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FatherClass</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> valueOne: <span class="type">Int</span></span><br><span class="line">    <span class="comment">//指定构造器</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">valueOne</span>: <span class="type">Int</span>)&#123;</span><br><span class="line">        <span class="keyword">self</span>.valueOne <span class="operator">=</span> valueOne</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChildClass</span>: <span class="title class_">FatherClass</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> valueTwo:<span class="type">Int</span> <span class="comment">//子类的新引入属性</span></span><br><span class="line">    <span class="comment">//指定构造器</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">valueOne</span>: <span class="type">Int</span> , <span class="params">valueTwo</span>:<span class="type">Int</span>)&#123;</span><br><span class="line">        <span class="keyword">self</span>.valueTwo <span class="operator">=</span> valueTwo</span><br><span class="line">        <span class="comment">//先初始化新引入属性，再初始化超类</span></span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(valueOne: valueOne)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//便利构造器</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">convenience</span> <span class="keyword">init</span>(<span class="params">valueOne</span>: <span class="type">Int</span>)&#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(valueOne: valueOne);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="三、类的构造器的使用"><a href="#三、类的构造器的使用" class="headerlink" title="三、类的构造器的使用"></a>三、类的构造器的使用</h4><p>关于类的构造器的使用在使用的时候，细节方面需要要注意很多，通过查找一些资料，现总结如下：</p><h5 id="1-指定构造器和便利构造器的基本使用原则："><a href="#1-指定构造器和便利构造器的基本使用原则：" class="headerlink" title="1. 指定构造器和便利构造器的基本使用原则："></a>1. 指定构造器和便利构造器的基本使用原则：</h5><ul><li>  当前类存在父类时，指定构造器器必须调用其直接父类的指定构造器，为保证继承的属性得以初始化;</li><li>  便利构造器必须调用同一类中定义的其他构造器。而且最终会导致一个指定构造器被调用;</li></ul><h5 id="2-Swift两段式构造过程"><a href="#2-Swift两段式构造过程" class="headerlink" title="2. Swift两段式构造过程"></a>2. Swift两段式构造过程</h5><p><code>Swift</code> 中类的构造过程包含两个阶段，被称为是二段式构造:</p><ol><li>第一阶段：每个存储型的值指定一个初值;</li><li>第二阶段：给当前类一个机会，在新实例准备使用之前进一步修改定制存储型的属性;</li></ol><p><strong>与OC的区别</strong>：<code>Swift</code>与<code>OC</code>的构造过程相似，区别在于阶段一，<code>OC</code>给每个属性赋值为<code>0</code>或者空值，但是<code>Swift</code>更为灵活，允许开发者指定自己所需的初始值(默认值);</p><h5 id="3-两段式构造需要注意的事项"><a href="#3-两段式构造需要注意的事项" class="headerlink" title="3. 两段式构造需要注意的事项"></a>3. 两段式构造需要注意的事项</h5><ul><li>指定构造器必须保证当前类新引入所有属性初始化完成之后，才能将其构造器任务继续向上代理给父类的构造器。</li><li>指定构造器必须先向上代理调用父类构造器，然后再为其继承的属性设置新值，否则，指定构造器赋予的新值将被父类中的构造器所覆盖。</li><li>便利构造器必须先代理调用同一类中的其它构造器，然后再为任意属性赋新值。否则，便利构造器赋予的新值将被同一类中其它指定构造器所覆盖。</li><li>构造器在第一阶段构造完成之前，不能调用任何实例方法，不能读取任何实例属性的值，不能引用self 作为一个值，因为此时还没构造有效实例。</li></ul><h5 id="4-总结两段式构造的详细流程"><a href="#4-总结两段式构造的详细流程" class="headerlink" title="4. 总结两段式构造的详细流程"></a>4. 总结两段式构造的详细流程</h5><p>第一阶段：</p><ul><li>某个指定构造器或便利构造器被调用。</li><li>完成新实例内存的分配，但此时内存还没有被初始化。</li><li>指定构造器确保其所在类引入的所有存储型属性都已赋初值。存储型属性所属的内存完成初始化。</li><li>指定构造器将调用父类的构造器，完成父类属性的初始化。这个调用父类构造器的过程沿着构造器链一直往上执行，直到到达构造器链的最顶部。</li><li>当到达了构造器链最顶部，且已确保所有实例包含的存储型属性都已经赋值，这个实例的内存被认为已经完全初始化。此时阶段 1 完成。</li></ul><p>第二阶段：</p><ol><li>从顶部构造器链一直往下，每个构造器链中类的指定构造器都有机会进一步定制实例。构造器此时可以访问self、修改它的属性并调用实例方法等等;</li><li>最终，任意构造器链中的便利构造器可以有机会定制实例和使用self;</li></ol><h4 id="四、构造器的继承与重写"><a href="#四、构造器的继承与重写" class="headerlink" title="四、构造器的继承与重写"></a>四、构造器的继承与重写</h4><p>与<code>OC</code>不同，<code>Swift</code>中的子类默认情况不会自动继承父类的构造器，这是因为子类可能有更多新增属性，直接调用父类的构造器，可能会有一些属性无法初始化为出现错误;         如果我们希望子类拥有一个或多个与父类相同的构造器，那么这相当于子类重写了父类的构造器，需要在重写方法前添加override修饰符。（override的作用是提示编译器去检查父类中是否有相匹配的指定构造器，并验证构造器参数是否正确）</p><p>注意：</p><ol><li>重写系统自带的默认构造器（虽然不是显式的），也要带上override修饰符;</li><li>重写父类指定构造器必须带上override，即使你的子类将父类的指定构造器重写成了便利构造器;</li><li>子类编写和父类便利构造器相匹配的子类构造器时，由于子类不能直接调用父类的便利构造器，并不能看做是对父类构造器的重写。所以子类中“重写”父类便利构造器时，不需要加override修饰符;</li></ol><h4 id="五、构造器的自动继承"><a href="#五、构造器的自动继承" class="headerlink" title="五、构造器的自动继承"></a>五、构造器的自动继承</h4><p>子类在默认情况下不会继承父类的构造器。但是如果满足特定条件，父类构造器还是是可以被自动继承的;</p><p>构造器的自动继承需要满足前提条件是：子类中引入的所有新属性都提供了默认值。</p><p>然后可分为两种情况：</p><h5 id="情况1-子类没有定义任何指定构造器，它将自动继承所有父类的指定构造器。"><a href="#情况1-子类没有定义任何指定构造器，它将自动继承所有父类的指定构造器。" class="headerlink" title="情况1:子类没有定义任何指定构造器，它将自动继承所有父类的指定构造器。"></a>情况1:子类没有定义任何指定构造器，它将自动继承所有父类的指定构造器。</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SuperClass</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> valueOne: <span class="type">Int</span></span><br><span class="line">    <span class="comment">//指定构造器</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">valueOne</span>: <span class="type">Int</span>)&#123;</span><br><span class="line">        <span class="keyword">self</span>.valueOne <span class="operator">=</span> valueOne</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubClass</span>: <span class="title class_">SuperClass</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> valueTwo:<span class="type">Int</span>  <span class="operator">=</span> <span class="number">100</span> <span class="comment">//子类的新引入属性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自动继承了父类的构造器,这里被使用创建子类，子类新属性使用默认值</span></span><br><span class="line"><span class="keyword">let</span> subClass <span class="operator">=</span> <span class="type">SubClass</span>(valueOne: <span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;subClass：(<span class="subst">\(subClass.valueOne)</span>) valueTwo(<span class="subst">\(subClass.valueTwo)</span>)&quot;</span>)</span><br></pre></td></tr></table></figure><h5 id="情况2：子类提供了所有父类指定构造器的实现-通过情况1继承过来的或者子类自定义实现-，此时子类将自动继承所有父类的便利构造器。"><a href="#情况2：子类提供了所有父类指定构造器的实现-通过情况1继承过来的或者子类自定义实现-，此时子类将自动继承所有父类的便利构造器。" class="headerlink" title="情况2：子类提供了所有父类指定构造器的实现(通过情况1继承过来的或者子类自定义实现)，此时子类将自动继承所有父类的便利构造器。"></a>情况2：子类提供了所有父类指定构造器的实现(通过情况1继承过来的或者子类自定义实现)，此时子类将自动继承所有父类的便利构造器。</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name:<span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> age: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">name</span>:<span class="type">String</span>, <span class="params">age</span>:<span class="type">Int</span>)&#123;</span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">        <span class="keyword">self</span>.age <span class="operator">=</span> age</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//父类的便利构造器</span></span><br><span class="line">    <span class="keyword">convenience</span> <span class="keyword">init</span>(<span class="params">name</span>:<span class="type">String</span>)&#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(name:name, age:<span class="number">10</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>: <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> nickName:<span class="type">String</span>!</span><br><span class="line">    <span class="comment">//实现了父类中的指定构造器</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>(<span class="params">name</span>:<span class="type">String</span>, <span class="params">age</span>:<span class="type">Int</span>)&#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(name:name, age:age)</span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">        <span class="keyword">self</span>.age <span class="operator">=</span> age <span class="operator">+</span> <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> ps <span class="operator">=</span> <span class="type">Person</span>(name: <span class="string">&quot;zs&quot;</span>, age: <span class="number">18</span>)</span><br></pre></td></tr></table></figure><p>自动继承注意：</p><ol><li>即使你在子类中添加了更多的便利构造器，这两条规则仍然适用。</li><li>对于情况 2，子类可以将父类的指定构造器实现为便利构造器。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;主要内容：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;构造器简介&lt;/li&gt;
&lt;li&gt;指定构造器和便利构造器&lt;/li&gt;
&lt;li&gt;类的构造器的使用&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;一、构造器简介&quot;&gt;&lt;a href=&quot;#一、构造器简介&quot; class=&quot;he</summary>
      
    
    
    
    <category term="Swift" scheme="https://wuyubeichen.github.io/categories/Swift/"/>
    
    
    <category term="Swift" scheme="https://wuyubeichen.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift学习04-构造器(上)</title>
    <link href="https://wuyubeichen.github.io/2018/08/04/Swift%E5%AD%A6%E4%B9%A004-%E6%9E%84%E9%80%A0%E5%99%A8(%E4%B8%8A)/"/>
    <id>https://wuyubeichen.github.io/2018/08/04/Swift%E5%AD%A6%E4%B9%A004-%E6%9E%84%E9%80%A0%E5%99%A8(%E4%B8%8A)/</id>
    <published>2018-08-04T10:15:31.000Z</published>
    <updated>2022-08-19T08:09:16.430Z</updated>
    
    <content type="html"><![CDATA[<p><strong>主要内容：</strong></p><ol><li>构造器简介</li><li>默认构造器 - 最简单的构造器</li><li>逐一成员构造器：类中不存在，适用于结构体</li><li>可选型属性在构造器中的使用</li><li>构造器代理</li></ol><h4 id="一、构造器简介"><a href="#一、构造器简介" class="headerlink" title="一、构造器简介"></a>一、构造器简介</h4><p>Swift赋予自定义类型更加丰富的功能，一个显著地方就是构造过程。Swift可以为自定义类型设置构造器来初始化一个实例。有关Swift构造器的使用特点可以总结如下：</p><ol><li>构造器适用于类、结构体、枚举。是新的实例可用之前必须执行的一个过程</li><li>构造器具体的操作包括：必须保证所有存储型属性有合适初始值，执行其他必须的设置</li><li>构造器无需返回值，区别于OC</li><li>类的实例可以定义析构器，在实例释放之前执行特定的清除工作</li><li>存储型属性设置默认值和构造器中为其设置初始值，这种不会触发任何属性观察器</li></ol><h4 id="二、默认构造器-最简单的构造器"><a href="#二、默认构造器-最简单的构造器" class="headerlink" title="二、默认构造器 - 最简单的构造器"></a>二、默认构造器 - 最简单的构造器</h4><p>默认构造器原理：返回一个所有属性都使用其原有默认值的一个实例</p><p>存在默认构造器的条件:</p><ol><li>定义变量的时候，就可以保证所有属性都有可用的值。</li><li>没有自定义的构造器</li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span>  <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span>?</span><br><span class="line">    <span class="keyword">var</span> age <span class="operator">=</span> <span class="number">18</span></span><br><span class="line">    <span class="keyword">var</span> gender <span class="operator">=</span> <span class="string">&quot;男&quot;</span></span><br><span class="line">    <span class="comment">//如果存在schoolName，那就必须添加一个构造器来确保没有默认值的schoolName也能赋值</span></span><br><span class="line">    <span class="comment">//let schoolName:String</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> ps <span class="operator">=</span> <span class="type">Person</span>() <span class="comment">//使用了默认构造器</span></span><br></pre></td></tr></table></figure><h4 id="二、逐一成员构造器：类中不存在，适用于结构体"><a href="#二、逐一成员构造器：类中不存在，适用于结构体" class="headerlink" title="二、逐一成员构造器：类中不存在，适用于结构体"></a>二、逐一成员构造器：类中不存在，适用于结构体</h4><p>结构体不会像类一样，对构造器给予限制，必须保证每个属性都可用，因为除了默认构造器，结构体还有逐一成员构造器，可以对每个属性进行设置;</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Size</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> width <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">var</span> height:<span class="type">Int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//let size = Size() //此时不满足默认构造器条件1，不能使用</span></span><br><span class="line"><span class="keyword">let</span> size1 <span class="operator">=</span> <span class="type">Size</span>(width: <span class="number">10</span>, height: <span class="number">10</span>) <span class="comment">//使用逐一成员构造器</span></span><br></pre></td></tr></table></figure><h4 id="三、自定义构造器：输入参数的形式构造实例，满足多种情况的需要"><a href="#三、自定义构造器：输入参数的形式构造实例，满足多种情况的需要" class="headerlink" title="三、自定义构造器：输入参数的形式构造实例，满足多种情况的需要"></a>三、自定义构造器：输入参数的形式构造实例，满足多种情况的需要</h4><ol><li>常量只能被赋值一次，所有如果定义常量时有默认值，即使是构造函数也不能修改此值</li><li>对于类的实例，它的常量属性只能在定义它的类的构造函数中修改，不能在子类中修改</li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> type <span class="operator">=</span> <span class="string">&quot;学生&quot;</span></span><br><span class="line">    <span class="keyword">let</span> name :<span class="type">String</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">name</span> :<span class="type">String</span>)&#123;</span><br><span class="line">        <span class="comment">//self.type = &quot;教师&quot;  //不能修改已经有默认值的常量属性</span></span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> name  <span class="comment">//构造函数必须保证所有值可用，此处赋值操作必须有</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="四、可选型属性在构造器中的使用"><a href="#四、可选型属性在构造器中的使用" class="headerlink" title="四、可选型属性在构造器中的使用"></a>四、可选型属性在构造器中的使用</h4><p>使用可选型是因为在业务逻辑上允许此属性为<code>nil</code>，包括两种情况如下：</p><ol><li>初始化的时候无法为其赋值,只能默认<code>nil</code>；</li><li>在后续使用中需要将其赋值为<code>nil</code>；</li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name:<span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> age:<span class="type">Int</span>?</span><br><span class="line">    <span class="keyword">init</span>(<span class="params">name</span>:<span class="type">String</span>)&#123;</span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">        <span class="comment">//以为age是可选型，存在默认值nil,所以构造函数不为其设置值也不报错</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="五、构造器代理"><a href="#五、构造器代理" class="headerlink" title="五、构造器代理"></a>五、构造器代理</h4><p>构造器通过调用其他构造器来完成实例的部分构造，被称为构造器代理,实现减少代码重复，构造器代理分为两种：</p><ul><li>值类型构造器代理：适用于值类型（结构体&#x2F;枚举），没有继承等复杂过程，较为简单</li><li>类构造器代理：因为有涉及到继承，需要保证所有继承属性也能正确的初始化（也即是便利构造器，见下篇）</li></ul><p>注意：</p><ol><li>对于值类型，可以在自定义构造器中使用self.init来调用其他构造器</li><li>如果值类型定义了自定义构造器将不能使用默认构造器和逐一成员构造器。解决办法：将自定义构造器写在扩展里，而不是值类型的原始定义中</li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">NewSize</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> width <span class="operator">=</span> <span class="number">0.0</span> , height <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="operator">=</span> <span class="number">0.0</span>, y <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rect</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> origin <span class="operator">=</span> <span class="type">Point</span>()</span><br><span class="line">    <span class="keyword">var</span> size <span class="operator">=</span> <span class="type">NewSize</span>()</span><br><span class="line">    <span class="comment">//构造器1：与默认构造函数一样，全部使用默认值</span></span><br><span class="line">    <span class="keyword">init</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器2: 与逐一成员构造器一样</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">origin</span>:<span class="type">Point</span>, <span class="params">size</span>:<span class="type">NewSize</span>)&#123;</span><br><span class="line">        <span class="keyword">self</span>.origin <span class="operator">=</span> origin</span><br><span class="line">        <span class="keyword">self</span>.size  <span class="operator">=</span> size</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器3：调用了构造器2方法</span></span><br><span class="line">    <span class="comment">//如果我们不去实现构造器2，将不能调用与其功能相似的逐一成员构造器</span></span><br><span class="line">    <span class="comment">//所以我们可以参考扩展，将自定义方法写在扩展中，就不必这样麻烦了</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">center</span>: <span class="type">Point</span>, <span class="params">size</span>: <span class="type">NewSize</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> originX <span class="operator">=</span> center.x <span class="operator">-</span> (size.width <span class="operator">/</span> <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">let</span> originY <span class="operator">=</span> center.y <span class="operator">-</span> (size.height <span class="operator">/</span> <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(origin: <span class="type">Point</span>(x: originX, y: originY), size: size)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;主要内容：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;构造器简介&lt;/li&gt;
&lt;li&gt;默认构造器 - 最简单的构造器&lt;/li&gt;
&lt;li&gt;逐一成员构造器：类中不存在，适用于结构体&lt;/li&gt;
&lt;li&gt;可选型属性在构造器中的使用&lt;/li&gt;
&lt;li&gt;构造器代理&lt;/l</summary>
      
    
    
    
    <category term="Swift" scheme="https://wuyubeichen.github.io/categories/Swift/"/>
    
    
    <category term="Swift" scheme="https://wuyubeichen.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift学习03-闭包</title>
    <link href="https://wuyubeichen.github.io/2018/08/03/Swift%E5%AD%A6%E4%B9%A003-%E9%97%AD%E5%8C%85/"/>
    <id>https://wuyubeichen.github.io/2018/08/03/Swift%E5%AD%A6%E4%B9%A003-%E9%97%AD%E5%8C%85/</id>
    <published>2018-08-03T10:12:53.000Z</published>
    <updated>2022-08-19T08:09:09.577Z</updated>
    
    <content type="html"><![CDATA[<p><strong>闭包</strong>：是自包含的函数代码块，可以在代码中被传递和使用。<code>Swift</code>中的闭包与<code>C</code>和 <code>Objective-C</code>中的代码块(<code>blocks</code>)以及其他一些编程语言中的匿名函数比较相似；</p><p><strong>主要内容：</strong></p><ol><li>闭包表达式</li><li>闭包的使用与优化</li><li>值捕获</li><li>逃逸闭包</li><li>自动闭包</li></ol><h4 id="一、闭包表达式"><a href="#一、闭包表达式" class="headerlink" title="一、闭包表达式"></a>一、闭包表达式</h4><p><code>Swift</code>闭包的三种存在形式：</p><ol><li>全局函数是一个有名字但不会捕获任何值的闭包</li><li>嵌套函数是一个有名字并可以捕获其封闭函数域内值的闭包</li><li>闭包表达式是一个利用轻量级语法所写的可以捕获其上下文中变量或常量值的匿名闭包 闭包表达式的语法一般有如下的一般形式:</li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; (parameters) -&gt; returnType <span class="keyword">in</span></span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><ol><li>闭包的外层是一个大括号，先写的参数和返回值，然后操作部分之前使用<code>in</code>；</li><li>闭包就相当于<code>OC</code>中的<code>block</code>, 也可以看做是匿名函数；</li><li>闭包表达式参数可以是<code>in-out</code>参数，但不能设定默认值；</li><li>闭包的函数体部分由关键字<code>in</code>引入，该关键字表示闭包参数和返回值类型已经完成，闭包函数体开始；</li></ol><h4 id="二、闭包的使用与优化"><a href="#二、闭包的使用与优化" class="headerlink" title="二、闭包的使用与优化"></a>二、闭包的使用与优化</h4><p>下面，我们使用<code>Swift</code>标准库中的<code>sorted(by:)</code>方法来测试闭包的使用。</p><p><code>sorted(by:)</code>方法允许外部传入一个用于排序的闭包函数，将已知类型数组中的值进行排序，完成排序之后，该方法会返回一个与原数组大小相同，包含同类型元素已正确排序的新数组:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个整型数组</span></span><br><span class="line"><span class="keyword">var</span> someInts: [<span class="type">Int</span>] <span class="operator">=</span> [<span class="number">5</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line"><span class="comment">//定义一个排序函数</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">biggerNumFirst</span>(<span class="params">num1</span>:<span class="type">Int</span>, <span class="params">num2</span>:<span class="type">Int</span>) -&gt; <span class="type">Bool</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 <span class="operator">&gt;</span> num2</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//普通用法：将biggerNumFirst函数传入sorted函数，实现排序</span></span><br><span class="line"><span class="keyword">var</span> sortInts <span class="operator">=</span> someInts.sorted(by: biggerNumFirst)</span><br><span class="line"><span class="built_in">print</span>(sortInts)     <span class="comment">//[9, 7, 5, 3, 1, 0]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//闭包用法：为sorted函数参数传入一个闭包，实现排序</span></span><br><span class="line">sortInts <span class="operator">=</span> someInts.sorted(by:&#123; (a:<span class="type">Int</span>, b:<span class="type">Int</span>) -&gt; <span class="type">Bool</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> a <span class="operator">&gt;</span> b</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">print</span>(sortInts)     <span class="comment">//[9, 7, 5, 3, 1, 0]</span></span><br></pre></td></tr></table></figure><p><strong>注意：因为闭包不会在其他地方调用，所以不使用外部参数名</strong></p><p>闭包使用起来十分灵活，我们可以在某些特定情况下对齐进行优化，下面是对上述闭包的优化：</p><h5 id="2-1-根据上下文推断类型，省略参数类型与括号"><a href="#2-1-根据上下文推断类型，省略参数类型与括号" class="headerlink" title="2.1.根据上下文推断类型，省略参数类型与括号"></a>2.1.根据上下文推断类型，省略参数类型与括号</h5><p>由于排序闭包函数是作为<code>sorted(by:)</code>方法的参数传入的，<code>Swift</code>可以推断其类型和返回值类型。所以<code>sorted(by:)</code>方法被一个<code>Int</code>类型的数组调用，其参数必定是<code>(Int,Int)-&gt;Bool</code>类型的函数。</p><p>最后，根据上下文推断类型，我们可以省略参数类型和参数周围的括号：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sortInts <span class="operator">=</span> someInts.sorted(by: &#123;a,b <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> a <span class="operator">&gt;</span> b</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">print</span>(sortInts)</span><br></pre></td></tr></table></figure><h5 id="2-2-对于不会发生歧义的闭包，可将其写成一行"><a href="#2-2-对于不会发生歧义的闭包，可将其写成一行" class="headerlink" title="2.2.对于不会发生歧义的闭包，可将其写成一行"></a>2.2.对于不会发生歧义的闭包，可将其写成一行</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sortInts <span class="operator">=</span> someInts.sorted(by:&#123;a,b <span class="keyword">in</span> <span class="keyword">return</span> a <span class="operator">&gt;</span> b&#125;)</span><br><span class="line"><span class="built_in">print</span>(sortInts)</span><br></pre></td></tr></table></figure><h5 id="2-3-单行闭包表达式，省略return关键字"><a href="#2-3-单行闭包表达式，省略return关键字" class="headerlink" title="2.3.单行闭包表达式，省略return关键字"></a>2.3.单行闭包表达式，省略return关键字</h5><p>省略<code>return</code>关键字的条件：</p><ol><li><code>sorted(by:)</code>方法的参数类型明确了闭包必须返回一个<code>Bool</code>类型值；</li><li>单行闭包表达式中，其返回值类型没有歧义；</li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sortInts <span class="operator">=</span> someInts.sorted(by: &#123;a,b <span class="keyword">in</span> a <span class="operator">&gt;</span> b&#125;)</span><br><span class="line"><span class="built_in">print</span>(sortInts)</span><br></pre></td></tr></table></figure><h5 id="2-4-使用参数名缩写-不推荐使用"><a href="#2-4-使用参数名缩写-不推荐使用" class="headerlink" title="2.4.使用参数名缩写(不推荐使用)"></a>2.4.使用参数名缩写(不推荐使用)</h5><p><code>Swift</code>自动为内联闭包提供了参数名称缩写功能，你可以直接通过<code>$0</code>，<code>$1</code>，<code>$2</code> 来顺序调用闭包的参数，以此类推；</p><p>如果我们在闭包表达式中使用参数名称缩写， 我们就可以在闭包定义中省略参数列表，并且对应参数名称缩写的类型会通过函数类型进行推断。<code>in</code>关键字也同样可以被省略，因为此时闭包表达式完全由闭包函数体构成：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sortInts <span class="operator">=</span> someInts.sorted(by: &#123;<span class="variable">$0</span><span class="operator">&gt;</span><span class="variable">$1</span>&#125;)</span><br><span class="line"><span class="built_in">print</span>(sortInts)</span><br></pre></td></tr></table></figure><h5 id="2-5-使用运算符简化闭包-不推荐使用"><a href="#2-5-使用运算符简化闭包-不推荐使用" class="headerlink" title="2.5.使用运算符简化闭包(不推荐使用)"></a>2.5.使用运算符简化闭包(不推荐使用)</h5><p><code>Swift</code>的<code>Int</code>类型定义了关于大于号（<code>&gt;</code>）的字符串实现，其作为一个函数接受两个<code>Int</code>类型的参数并返回<code>Bool</code>类型的值。而这正好与<code>sorted(by:)</code>方法的参数需要的函数类型相符合。可以使用大于号来代替闭包</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sortInts <span class="operator">=</span> someInts.sorted(by: <span class="operator">&gt;</span>)</span><br><span class="line"><span class="built_in">print</span>(sortInts)</span><br></pre></td></tr></table></figure><h5 id="2-6-尾随闭包，解决长闭包的书写问题"><a href="#2-6-尾随闭包，解决长闭包的书写问题" class="headerlink" title="2.6.尾随闭包，解决长闭包的书写问题"></a>2.6.尾随闭包，解决长闭包的书写问题</h5><p>定义：将一个很长的闭包表达式作为最后一个参数传递给函数，可以使用尾随闭包来增强函数的可读性；</p><p>写法：将闭包书写在函数括号之后，函数会支持将其作为最后一个参数调用，使用尾随闭包，不需要写出它的参数标签；</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">someFunctionThatTakesAClosure</span>(<span class="params">closure</span>: () -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    <span class="comment">//函数体部分</span></span><br><span class="line">    closure(); <span class="comment">//调用闭包</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不使用尾随闭包进行函数调用</span></span><br><span class="line">someFunctionThatTakesAClosure(closure: &#123;</span><br><span class="line">    <span class="comment">//闭包主体部分</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用尾随闭包进行函数调用</span></span><br><span class="line">someFunctionThatTakesAClosure() &#123;</span><br><span class="line">    <span class="comment">//闭包主体部分</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意：如果闭包表达式是函数或方法的唯一参数，则当你使用尾随闭包时，你甚至可以把 () 省略掉：</span></span><br><span class="line">someFunctionThatTakesAClosure &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello World!&quot;</span>)    <span class="comment">//打印：Hello World!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结<code>Swift</code>闭包主要的四种优化方法：</p><ol><li>利用上下文推断参数和返回值类型，省略参数类型与括号；</li><li>隐式返回单表达式闭包，即单表达式闭包可以省略<code>return</code>关键字；</li><li>参数名称缩写；</li><li>尾随闭包语法；</li></ol><h4 id="三、值捕获"><a href="#三、值捕获" class="headerlink" title="三、值捕获"></a>三、值捕获</h4><p>闭包可以在其被定义的上下文中捕获常量或变量。即使定义这些常量和变量的原作用域已经不存在，闭包仍然可以在闭包函数体内引用和修改这些值。<code>Swift</code>会为你管理在捕获过程中涉及到的所有内存操作；</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">makeIncrementer</span>(<span class="params">forIncrement</span> <span class="params">amount</span>: <span class="type">Int</span>) -&gt; () -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> runningTotal <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">incrementer</span>() -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        runningTotal <span class="operator">+=</span> amount</span><br><span class="line">        <span class="keyword">return</span> runningTotal</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> incrementer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码分析：</p><ol><li><code>makeIncrementer</code>函数以<code>amount</code>为参数，以<code>()-&gt;Int</code>作为返回值类型，其函数体中还嵌套了另一个函数<code>incrementer</code>；</li><li>如果我们把<code>incrementer</code>单独拿出来，会发现其中<code>runingTotal</code>和<code>amount</code>变量都无法使用，因为这两个变量的引用是<code>incrementer</code>从外部捕获的；</li><li><code>Swift</code>会负责被捕获变量的所有内存管理工作，包括对捕获的一份值拷贝，也包括释放不再需要的变量；</li></ol><p>现在再来测试<code>makeIncrementer</code>函数的使用:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> incrementByTen <span class="operator">=</span> makeIncrementer(forIncrement: <span class="number">10</span>)</span><br><span class="line">incrementByTen();    <span class="comment">//10</span></span><br><span class="line">incrementByTen();    <span class="comment">//20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> incrementBySeven <span class="operator">=</span> makeIncrementer(forIncrement: <span class="number">7</span>)</span><br><span class="line">incrementBySeven()   <span class="comment">//7</span></span><br><span class="line">incrementBySeven();  <span class="comment">//14</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> alsoIncrementByTen <span class="operator">=</span> incrementByTen</span><br><span class="line">alsoIncrementByTen() <span class="comment">//30</span></span><br></pre></td></tr></table></figure><p>代码分析:</p><ol><li><code>incrementByTen</code>与<code>incrementBySeven</code>，是通过<code>makeIncrementer</code>函数传入不同的增量参数<code>amount</code>而创建的；</li><li>两个函数都有属于各自的引用，其中的<code>runningTotal</code>变量都是从<code>makeIncrementer</code>中捕获的，但是已经各自没有关系；</li><li>函数和闭包都是引用类型，将其赋值给变量或者常量，都只是操作的它们的引用，而不会改变闭包或者函数本身；</li></ol><h4 id="四、逃逸闭包"><a href="#四、逃逸闭包" class="headerlink" title="四、逃逸闭包"></a>四、逃逸闭包</h4><p>当一个闭包作为参数传到一个函数中，但是这个闭包在<strong>函数返回之后才被执行</strong>，我们称该闭包从函数中逃逸。</p><p>逃逸闭包：在定义接受闭包作为参数的函数时，我们需要在参数名之前标注<code>@escaping</code>，以此表明这个闭包是允许”逃逸”出这个函数的。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> completionHandlers: [() -&gt; <span class="type">Void</span>] <span class="operator">=</span> []</span><br><span class="line"><span class="keyword">func</span> <span class="title function_">someFunctionWithEscapingClosure</span>(<span class="params">completionHandler</span>: <span class="keyword">@escaping</span> () -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    <span class="comment">//代码1：执行闭包，不需要添加@escaping</span></span><br><span class="line">    <span class="comment">//completionHandler();</span></span><br><span class="line">    <span class="comment">//代码2：函数外部对闭包进行了操作</span></span><br><span class="line">    completionHandlers.append(completionHandler)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>代码分析： <code>someFunctionWithEscapingClosure(_:)</code> 函数接受一个闭包作为参数，该闭包被添加到一个函数外定义的数组中。如果不将这个参数标记为<code>@escaping</code>，就会得到一个编译错误。</p><h5 id="4-1-逃逸闭包的使用"><a href="#4-1-逃逸闭包的使用" class="headerlink" title="4.1.逃逸闭包的使用"></a>4.1.逃逸闭包的使用</h5><p>逃逸闭包和非逃逸闭包在使用上有所不同。将一个闭包标记为<code>@escaping</code>(即逃逸闭包)后，在调用这个闭包时就必须在闭包中显式地引用 <code>self</code>。一个示例如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个带有非逃逸闭包参数的函数</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">someFunctionWithNonescapingClosure</span>(<span class="params">closure</span>: () -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    closure()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个可以使用闭包的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SomeClass</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="operator">=</span> <span class="number">10</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">doSomething</span>() &#123;</span><br><span class="line">        <span class="comment">//调用逃逸闭包：必须在闭包中显式引用self</span></span><br><span class="line">        someFunctionWithEscapingClosure &#123; <span class="keyword">self</span>.x <span class="operator">=</span> <span class="number">100</span> &#125;</span><br><span class="line">        <span class="comment">//调用非逃逸闭包：可以隐式引用self</span></span><br><span class="line">        someFunctionWithNonescapingClosure &#123; x <span class="operator">=</span> <span class="number">200</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance <span class="operator">=</span> <span class="type">SomeClass</span>()</span><br><span class="line">instance.doSomething()</span><br><span class="line"><span class="built_in">print</span>(instance.x)         <span class="comment">//打印出 &quot;200”</span></span><br></pre></td></tr></table></figure><h4 id="五、自动闭包"><a href="#五、自动闭包" class="headerlink" title="五、自动闭包"></a>五、自动闭包</h4><p><strong>自动闭包：</strong>一种自动创建的闭包，用与包装传递给函数作为参数的表达式；</p><ol><li>自动闭包不接受任何参数；</li><li>自动闭包被调用的时候，会返回被包装在其中的表达式的值；</li><li>自动闭包是用一个普通的表达式来代替显式的闭包，能够省略闭包的花括号；</li></ol><p>其实，我们经常调用采用自动闭包的函数，但是却少去实现这样的函数，<code>assert</code>函数就是其中之一：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">assert</span>(condition:, message:)</span><br></pre></td></tr></table></figure><p><code>assert</code>函数中：</p><ol><li><code>condition</code>参数可以接受自动闭包作为值，<code>condition</code>参数仅会在<code>debug</code>模式下被求值；</li><li>在<code>condidtion</code>被调用返回值为<code>false</code>时，<code>message</code>参数将被使用。</li></ol><h5 id="5-1-自动闭包的基本使用"><a href="#5-1-自动闭包的基本使用" class="headerlink" title="5.1.自动闭包的基本使用"></a>5.1.自动闭包的基本使用</h5><p>自动闭包能够实现延迟求值，直到调用这个闭包时，代码才会被执行。这对于有副作用或者高计算成本的代码来说是有益处的;下面的代码展示了自动闭包实现延时求值的具体做法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> customersInLine <span class="operator">=</span> [<span class="string">&quot;Chris&quot;</span>, <span class="string">&quot;Alex&quot;</span>, <span class="string">&quot;Ewa&quot;</span>, <span class="string">&quot;Barry&quot;</span>, <span class="string">&quot;Daniella&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(customersInLine.count)    <span class="comment">//打印出 “5&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//自动闭包不接受参数，只是一个表达式</span></span><br><span class="line"><span class="keyword">let</span> customerProvider <span class="operator">=</span> &#123; customersInLine.remove(at: <span class="number">0</span>) &#125;</span><br><span class="line"><span class="built_in">print</span>(customersInLine.count)    <span class="comment">//打印出 “5&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//调用自动闭包</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Now serving <span class="subst">\(customerProvider())</span>!&quot;</span>)   <span class="comment">// Prints &quot;Now serving Chris!&quot;</span></span><br><span class="line"><span class="built_in">print</span>(customersInLine.count)               <span class="comment">//打印出 &quot;4”</span></span><br></pre></td></tr></table></figure><p>代码分析：闭包实现了移除第一元素的功能，但是在闭包被调用之前，这个元素是不会被移除的。这就实现了延迟的作用</p><h5 id="5-2-自动闭包在函数中的使用"><a href="#5-2-自动闭包在函数中的使用" class="headerlink" title="5.2.自动闭包在函数中的使用"></a>5.2.自动闭包在函数中的使用</h5><p>现在将闭包作为参数传递给一个函数，同样可以实现延时求值行为。下面的<code>serve</code>函数接受了一个闭包参数(具有删除第一个元素且返回这个元素的功能)；</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//customersInLine is [&quot;Alex&quot;, &quot;Ewa&quot;, &quot;Barry&quot;, &quot;Daniella&quot;]</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">serve</span>(<span class="params">customer</span> <span class="params">customerProvider</span>: () -&gt; <span class="type">String</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Now serving <span class="subst">\(customerProvider())</span>!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以闭包的形式传入参数</span></span><br><span class="line">serve(customer: &#123; customersInLine.remove(at: <span class="number">0</span>) &#125; )  <span class="comment">//打印出&quot;Now serving Alex!”</span></span><br></pre></td></tr></table></figure><p>现在使用自动闭包来实现上述函数功能，使用<code>@autoclosure</code>关键字，标明参数使用的是自动闭包，具体示例如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// customersInLine is [&quot;Ewa&quot;, &quot;Barry&quot;, &quot;Daniella&quot;]</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">serve</span>(<span class="params">customer</span> <span class="params">customerProvider</span>: <span class="keyword">@autoclosure</span> () -&gt; <span class="type">String</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Now serving <span class="subst">\(customerProvider())</span>!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//由于标明了自动闭包，这里直接省略了闭包的花括号</span></span><br><span class="line">serve(customer: customersInLine.remove(at: <span class="number">0</span>))  <span class="comment">//打印出&quot;Now serving Ewa!\n&quot;</span></span><br></pre></td></tr></table></figure><p>注意：<strong>过度使用 autoclosures 会让你的代码变得难以理解。上下文和函数名应该能够清晰地表明求值是被延迟执行的。</strong></p><h5 id="5-3-可”逃逸”的自动闭包"><a href="#5-3-可”逃逸”的自动闭包" class="headerlink" title="5.3.可”逃逸”的自动闭包"></a>5.3.可”逃逸”的自动闭包</h5><p>一个自动闭包可以“逃逸”，这时候应该同时使用<code>@autoclosure</code> 和 <code>@escaping</code> 属性，下面举例说明：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// customersInLine is [&quot;Barry&quot;, &quot;Daniella&quot;]</span></span><br><span class="line"><span class="keyword">var</span> customerProviders: [() -&gt; <span class="type">String</span>] <span class="operator">=</span> []</span><br><span class="line"><span class="keyword">func</span> <span class="title function_">collectCustomerProviders</span>(<span class="keyword">_</span> <span class="params">customerProvider</span>: <span class="keyword">@autoclosure</span> <span class="keyword">@escaping</span> () -&gt; <span class="type">String</span>) &#123;</span><br><span class="line">    customerProviders.append(customerProvider)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用collectCustomerProviders，向数组中追加闭包</span></span><br><span class="line">collectCustomerProviders(customersInLine.remove(at: <span class="number">0</span>))</span><br><span class="line">collectCustomerProviders(customersInLine.remove(at: <span class="number">0</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Collected <span class="subst">\(customerProviders.count)</span> closures.&quot;</span>)   <span class="comment">//打印 &quot;Collected 2 closures.&quot;</span></span><br><span class="line"><span class="comment">//循环数组中闭包，并且执行</span></span><br><span class="line"><span class="keyword">for</span> customerProvider <span class="keyword">in</span> customerProviders &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Now serving <span class="subst">\(customerProvider())</span>!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 &quot;Now serving Barry!&quot;</span></span><br><span class="line"><span class="comment">// 打印 &quot;Now serving Daniella!”</span></span><br></pre></td></tr></table></figure><p>代码分析：</p><ol><li>作为逃逸闭包：<code>collectCustomerProviders</code>函数中，闭包<code>customerProvider</code>被追加到<code>customerProviders</code>中，而这个数据是定义在函数作用域范围之外的，这意味数组内的闭包能够在函数返回之后被调用，所以<code>customerProvider</code>必须允许”逃逸”出函数作用域；</li><li>作为自动闭包：调用<code>collectCustomerProviders</code>函数时，传入的闭包是表达式的形式，自动闭包省略了闭包花括号；</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;闭包&lt;/strong&gt;：是自包含的函数代码块，可以在代码中被传递和使用。&lt;code&gt;Swift&lt;/code&gt;中的闭包与&lt;code&gt;C&lt;/code&gt;和 &lt;code&gt;Objective-C&lt;/code&gt;中的代码块(&lt;code&gt;blocks&lt;/code&gt;)以及其他</summary>
      
    
    
    
    <category term="Swift" scheme="https://wuyubeichen.github.io/categories/Swift/"/>
    
    
    <category term="Swift" scheme="https://wuyubeichen.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift学习02-函数</title>
    <link href="https://wuyubeichen.github.io/2018/08/02/Swift%E5%AD%A6%E4%B9%A002-%E5%87%BD%E6%95%B0/"/>
    <id>https://wuyubeichen.github.io/2018/08/02/Swift%E5%AD%A6%E4%B9%A002-%E5%87%BD%E6%95%B0/</id>
    <published>2018-08-02T10:14:31.000Z</published>
    <updated>2022-08-19T08:09:03.791Z</updated>
    
    <content type="html"><![CDATA[<p><strong>函数</strong>：是一段完成特定任务的独立代码片段。你可以通过给函数命名来标识某个函数的功能，这个名字可以被用来在需要的时候”调用”这个函数来完成它的任务；</p><p><strong>主要内容：</strong></p><ol><li>函数的定义与调用</li><li>函数参数与返回值</li><li>函数外部参数名和参数名称</li><li>默认参数</li><li>可变参数</li><li>输入输出参数</li><li>函数类型</li><li>函数类型</li></ol><h1 id="一、函数的定义与调用"><a href="#一、函数的定义与调用" class="headerlink" title="一、函数的定义与调用"></a>一、函数的定义与调用</h1><p>下面演示了在Swift中，定义函数和调用函数的基本操作：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义函数</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">greet</span>(<span class="params">person</span>: <span class="type">String</span>) -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> greeting <span class="operator">=</span> <span class="string">&quot;Hello, &quot;</span> <span class="operator">+</span> person <span class="operator">+</span> <span class="string">&quot;!&quot;</span></span><br><span class="line">    <span class="keyword">return</span> greeting</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用函数</span></span><br><span class="line"><span class="built_in">print</span>(greet(person: <span class="string">&quot;Anna&quot;</span>))         <span class="comment">// 打印 &quot;Hello, Anna!”</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">greetAgain</span>(<span class="params">person</span>: <span class="type">String</span>) -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello again, &quot;</span> <span class="operator">+</span> person <span class="operator">+</span> <span class="string">&quot;!&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(greetAgain(person: <span class="string">&quot;Anna&quot;</span>))    <span class="comment">// 打印 &quot;Hello again, Anna!”</span></span><br></pre></td></tr></table></figure><h1 id="二、函数参数与返回值"><a href="#二、函数参数与返回值" class="headerlink" title="二、函数参数与返回值"></a>二、函数参数与返回值</h1><h4 id="2-1-无参，有返回值函数"><a href="#2-1-无参，有返回值函数" class="headerlink" title="2.1.无参，有返回值函数"></a>2.1.无参，有返回值函数</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">sayHi</span>() -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hi！&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(sayHi())</span><br></pre></td></tr></table></figure><h4 id="2-2-多参，有返回值函数"><a href="#2-2-多参，有返回值函数" class="headerlink" title="2.2.多参，有返回值函数"></a>2.2.多参，有返回值函数</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">sayHi</span>(<span class="params">person</span>: <span class="type">String</span>, <span class="params">greet</span>: <span class="type">String</span>) -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> greetString <span class="operator">=</span> greet  <span class="operator">+</span> person</span><br><span class="line">    <span class="keyword">return</span> greetString</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(sayHi(person: <span class="string">&quot;zhoushuai&quot;</span>, greet: <span class="string">&quot;Hi！&quot;</span>))</span><br></pre></td></tr></table></figure><h4 id="2-3-无返回值函数"><a href="#2-3-无返回值函数" class="headerlink" title="2.3.无返回值函数"></a>2.3.无返回值函数</h4><p>严格意义上，虽然没有返回值，但是sayHello函数依然返回了值。没有定义返回类型的函数会返回一个特殊的Void值。它其实是一个空的元组(tuple)，没有任何元素，可以写成()</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">sayHi</span>(<span class="params">person</span>: <span class="type">String</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hi-Hi, <span class="subst">\(person)</span>!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">sayHi(person: <span class="string">&quot;Tom”)  //打印 &quot;</span><span class="type">Hi</span><span class="operator">-</span><span class="type">Hi</span>, <span class="type">Tom</span>!”</span><br><span class="line"></span><br><span class="line"><span class="comment">//sayHello函数与下面的两个函数，会被Swift识别为同一种函数，进而报错重复定义。</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">func sayHi(person: String) -&gt;()&#123;</span></span><br><span class="line"><span class="comment">    print(&quot;Hello, \(person)!&quot;)</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">func sayHi(person: String) -&gt;Void &#123;</span></span><br><span class="line"><span class="comment">    print(&quot;Hello, \(person)!&quot;)</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="2-4-多重返回值函数"><a href="#2-4-多重返回值函数" class="headerlink" title="2.4.多重返回值函数"></a>2.4.多重返回值函数</h4><p>可以用元组（tuple）类型让多个值作为一个复合值从函数中返回,即返回多个参数</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">findMaxMin</span>(<span class="params">array</span>:[<span class="type">Int</span>]) -&gt;(max:<span class="type">Int</span>,min:<span class="type">Int</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> max <span class="operator">=</span> array.max()</span><br><span class="line">    <span class="keyword">let</span> min <span class="operator">=</span> array.min()</span><br><span class="line">    <span class="keyword">return</span> (max<span class="operator">!</span>,min<span class="operator">!</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> bounds <span class="operator">=</span> findMaxMin(array: [<span class="number">8</span>, <span class="operator">-</span><span class="number">6</span>, <span class="number">2</span>, <span class="number">109</span>, <span class="number">3</span>, <span class="number">71</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;min is <span class="subst">\(bounds.min)</span> and max is <span class="subst">\(bounds.max)</span>&quot;</span>)</span><br><span class="line"><span class="comment">//打印 &quot;min is -6 and max is 109</span></span><br></pre></td></tr></table></figure><h4 id="2-5-可选返回值类型"><a href="#2-5-可选返回值类型" class="headerlink" title="2.5.可选返回值类型"></a>2.5.可选返回值类型</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">findMaxMin2</span>(<span class="params">array</span>:[<span class="type">Int</span>]) -&gt;(max:<span class="type">Int</span>,min:<span class="type">Int</span>)<span class="operator">?</span>&#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="operator">!</span>array.isEmpty <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> maxVlaue <span class="operator">=</span> array[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">var</span> minValue <span class="operator">=</span> array[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> number <span class="keyword">in</span> array&#123;</span><br><span class="line">        maxVlaue <span class="operator">=</span> maxVlaue <span class="operator">&gt;</span> number <span class="operator">?</span> maxVlaue : number</span><br><span class="line">        minValue <span class="operator">=</span> minValue <span class="operator">&lt;</span> number <span class="operator">?</span> minValue : number</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回的类型是可选型，因为结果有可能是nil</span></span><br><span class="line">    <span class="keyword">return</span> (maxVlaue, minValue)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> bounds2 <span class="operator">=</span> findMaxMin2(array: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;min is <span class="subst">\(bounds2.min)</span> and max is <span class="subst">\(bounds2.max)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：可选元组类型如 (Int, Int)? 与元组包含可选类型如 (Int?, Int?) 是不同的.可选的元组类型，整个元组是可选的，而不只是元组中的每个元素值。</p><h4 id="2-6-无参，无返回值函数"><a href="#2-6-无参，无返回值函数" class="headerlink" title="2.6.无参，无返回值函数"></a>2.6.无参，无返回值函数</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">sayHiHi</span>()&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;sayHiHi:无参五返回值的函数！&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">sayHiHi()</span><br></pre></td></tr></table></figure><h1 id="三、函数外部参数名和参数名称"><a href="#三、函数外部参数名和参数名称" class="headerlink" title="三、函数外部参数名和参数名称"></a>三、函数外部参数名和参数名称</h1><p>每个函数参数都有一个外部参数名(参数标签)以及参数名称，只不过默认情况下，函数参数直接使用参数名来作为它们的外部参数名。下面来总结函数外部参数名的各种用法。</p><h4 id="3-1-指定外部参数名，让函数表意更明确"><a href="#3-1-指定外部参数名，让函数表意更明确" class="headerlink" title="3.1.指定外部参数名，让函数表意更明确"></a>3.1.指定外部参数名，让函数表意更明确</h4><p>函数外部参数名的使用能够让一个函数在调用时更有表达力，更类似自然语言，并且仍保持了函数内部的可读性以及清晰的意图。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正常写法：</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">sayHelloTo</span>(<span class="params">name</span>: <span class="type">String</span> , <span class="params">greeting</span>: <span class="type">String</span>) -&gt; <span class="type">String</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;<span class="subst">\(greeting)</span>, <span class="subst">\(name)</span>!&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(sayHelloTo(name: <span class="string">&quot;风恣&quot;</span>, greeting: <span class="string">&quot;Hello”)) </span></span><br><span class="line"><span class="string">//打印：&quot;</span><span class="type">Hello，风恣！</span><span class="string">&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//改进上面的函数，为第二个参数指定外部参数名，让表意更加明确</span></span><br><span class="line"><span class="string">func sayHelloTo(name: String, withGreetingWord greeting:String) -&gt; String&#123;</span></span><br><span class="line"><span class="string">    return &quot;</span>\(greeting),\(name)<span class="string">&quot;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">print(sayHelloTo(name: &quot;</span><span class="type">FengZi</span><span class="string">&quot;, withGreetingWord: &quot;</span><span class="type">Hello</span><span class="string">&quot;))</span></span><br><span class="line"><span class="string">//打印：&quot;</span><span class="type">Hello，FengZi</span><span class="string">&quot;</span></span><br></pre></td></tr></table></figure><p><strong>特别说明</strong>： <strong>一般情况下，第一个参数不设置外部参数名，因为第一个参数的外部参数名是隐藏在函数名中的。</strong></p><h4 id="3-2-忽略参数标签"><a href="#3-2-忽略参数标签" class="headerlink" title="3.2.忽略参数标签"></a>3.2.忽略参数标签</h4><p>有时候，使用外部参数名反而会使函数更加繁琐，这又需要隐藏外部参数名：这时候使用下划线**”_“**来代替一个明确的参数标签。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正常写法：</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">mutipleOf</span>(<span class="params">num1</span>: <span class="type">Int</span>, <span class="params">and</span> <span class="params">num2</span>:<span class="type">Int</span>)-&gt; <span class="type">Int</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 <span class="operator">*</span> num2</span><br><span class="line">&#125;</span><br><span class="line">mutipleOf(num1: <span class="number">1</span>, and: <span class="number">6</span>)    <span class="comment">//6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//改进1：忽略参数标签</span></span><br><span class="line"><span class="keyword">func</span>  <span class="title function_">mutipleOf</span>(<span class="params">num1</span>:<span class="type">Int</span> , <span class="params">num2</span>:<span class="type">Int</span>) -&gt; <span class="type">Int</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 <span class="operator">*</span> num2;</span><br><span class="line">&#125;</span><br><span class="line">mutipleOf(num1: <span class="number">1</span>, num2: <span class="number">6</span>)   <span class="comment">//6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//改进2:彻底不使用参数名,使用下划线省略</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">mutiply</span>(<span class="keyword">_</span> <span class="params">num1</span>:<span class="type">Int</span>, <span class="keyword">_</span> <span class="params">num2</span>:<span class="type">Int</span>) -&gt; <span class="type">Int</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 <span class="operator">*</span> num2</span><br><span class="line">&#125;</span><br><span class="line">mutiply(<span class="number">1</span>, <span class="number">6</span>)                <span class="comment">//6</span></span><br></pre></td></tr></table></figure><h1 id="四、默认参数"><a href="#四、默认参数" class="headerlink" title="四、默认参数"></a>四、默认参数</h1><p>定义函数的时候，可以给某些参数设置默认值(Deafult Value)，当默认值被定义后，调用这个函数时可以忽略这个参数。 下面的函数包括两个默认参数，而且设置的默认参数都要在非默认参数后面。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">playMusic</span>(<span class="params">name</span>: <span class="type">String</span>, <span class="params">instrument</span>:<span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;drum&quot;</span>, <span class="params">sound</span>:<span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;咚咚咚。。。&quot;</span>) -&gt; <span class="type">String</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> scene <span class="operator">=</span> name <span class="operator">+</span> <span class="string">&quot; play the &quot;</span> <span class="operator">+</span> instrument <span class="operator">+</span> <span class="string">&quot;,&quot;</span> <span class="operator">+</span> sound;</span><br><span class="line">    <span class="built_in">print</span>(scene)</span><br><span class="line">    <span class="keyword">return</span> scene;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用了默认参数的参数, 相关的默认参数可以不用传值</span></span><br><span class="line">playMusic(name: <span class="string">&quot;zhoushuai”)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//对于默认参数，可以有选择的传入值</span></span><br><span class="line"><span class="string">playMusic(name: &quot;</span>zhoushuai<span class="string">&quot;, instrument: &quot;</span>panio<span class="string">&quot;)</span></span><br><span class="line"><span class="string">playMusic(name: &quot;</span>zhoushuai<span class="string">&quot;, instrument: &quot;</span>panio<span class="string">&quot; ,sound: &quot;</span>lingling<span class="operator">~</span><span class="string">&quot;)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//测试打印：</span></span><br><span class="line"><span class="string">//zhoushuai play the drum,咚咚咚。。。</span></span><br><span class="line"><span class="string">//zhoushuai play the panio,咚咚咚。。。</span></span><br><span class="line"><span class="string">//zhoushuai play the panio,lingling~</span></span><br></pre></td></tr></table></figure><h1 id="五、可变参数"><a href="#五、可变参数" class="headerlink" title="五、可变参数"></a>五、可变参数</h1><p>一个可变参数可以接受零个或多个值。函数调用时，你可以用可变参数来指定函数参数传入不确定数量的输入值。通过在变量类型名后面加入（…）的方式来定义可变参数。下面的算术平均函数演示了可变参数的用法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">arithmeticMean</span>(<span class="keyword">_</span> <span class="params">numbers</span>: <span class="type">Double</span>...) -&gt; <span class="type">Double</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> total: <span class="type">Double</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> number <span class="keyword">in</span> numbers &#123;</span><br><span class="line">        total <span class="operator">+=</span> number</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total <span class="operator">/</span> <span class="type">Double</span>(numbers.count)</span><br><span class="line">&#125;</span><br><span class="line">arithmeticMean(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)   <span class="comment">//返回3.0, 是这5个数的平均数。</span></span><br><span class="line"></span><br><span class="line">arithmeticMean(<span class="number">3</span>, <span class="number">8.25</span>, <span class="number">18.75</span>)  <span class="comment">//返回10.0, 是这3个数的平均数。</span></span><br></pre></td></tr></table></figure><p><strong>注意：一个函数只能拥有一个可变参数</strong></p><h1 id="六、输入输出参数"><a href="#六、输入输出参数" class="headerlink" title="六、输入输出参数"></a>六、输入输出参数</h1><p>函数参数默认是常量形参，所以我们在函数中对其修改都不会对参数的原值产生影响。为了解决这个问题，我们可以将这些需要修改的参数定义为输入输出参数。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> somInt <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="comment">//普通函数:报错，因为num是常量，不能被再次修改</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">func modifyNum(num:Int)&#123;</span></span><br><span class="line"><span class="comment">    num = num * 2;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//带有输入输出函数的函数</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">modifyNum2</span>(<span class="params">num</span>:<span class="keyword">inout</span> <span class="type">Int</span>)&#123;</span><br><span class="line">    num <span class="operator">=</span> num <span class="operator">*</span> <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">modifyNum2(num: <span class="operator">&amp;</span>somInt)</span><br><span class="line"><span class="built_in">print</span>(somInt)           <span class="comment">//20，someIn被修改</span></span><br></pre></td></tr></table></figure><p>注意： 1.只能传递变量给输入输出参数，而不能是常量或者字面量，因为这些量是不能被修改的； 2.传入参数作为输入输出参数时，需要在参数名前添加&amp;符号，表示这个值可以被修改；</p><h1 id="七、函数类型"><a href="#七、函数类型" class="headerlink" title="七、函数类型"></a>七、函数类型</h1><p>如同参数有整型，布尔型等参数类型一样，每个函数都有种特定的函数类型。函数的类型由函数的参数类型和返回值类型组成。下面举例说明：</p><h4 id="1-以下两个函数具有相同的函数类型：（Int-Int）-gt-Int"><a href="#1-以下两个函数具有相同的函数类型：（Int-Int）-gt-Int" class="headerlink" title="1.以下两个函数具有相同的函数类型：（Int,Int）-&gt;Int"></a>1.以下两个函数具有相同的函数类型：（Int,Int）-&gt;Int</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">addTwoInts</span>(<span class="keyword">_</span> <span class="params">a</span>: <span class="type">Int</span>, <span class="keyword">_</span> <span class="params">b</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a <span class="operator">+</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">multiplyTwoInts</span>(<span class="keyword">_</span> <span class="params">a</span>: <span class="type">Int</span>, <span class="keyword">_</span> <span class="params">b</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a <span class="operator">*</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-没有参数也没有返回值的函数类型：-gt-Void"><a href="#2-没有参数也没有返回值的函数类型：-gt-Void" class="headerlink" title="2.没有参数也没有返回值的函数类型：()-&gt;Void"></a>2.没有参数也没有返回值的函数类型：()-&gt;Void</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">printHelloWorld</span>() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello, world&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-使用函数类型"><a href="#3-使用函数类型" class="headerlink" title="3.使用函数类型"></a>3.使用函数类型</h4><h5 id="3-1定义一个函数类型的变量或常量，然后可以使用适当函数为其赋值"><a href="#3-1定义一个函数类型的变量或常量，然后可以使用适当函数为其赋值" class="headerlink" title="3.1定义一个函数类型的变量或常量，然后可以使用适当函数为其赋值"></a>3.1定义一个函数类型的变量或常量，然后可以使用适当函数为其赋值</h5><p>下面的mathFunction变量，经过赋值之后，指向了addTwoInts函数，所以它也可以当做addTwoInts函数使用</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mathFunction:(<span class="type">Int</span>,<span class="type">Int</span>)-&gt;<span class="type">Int</span> <span class="operator">=</span> addTwoInts</span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值了加法函数：addTwoInts</span></span><br><span class="line"><span class="built_in">print</span>(mathFunction(<span class="number">3</span>,<span class="number">4</span>))         <span class="comment">//7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值了乘法函数：multiplyTwoInts</span></span><br><span class="line">mathFunction <span class="operator">=</span> multiplyTwoInts;</span><br><span class="line"><span class="built_in">print</span>(mathFunction(<span class="number">3</span>,<span class="number">4</span>))         <span class="comment">//12</span></span><br></pre></td></tr></table></figure><h5 id="3-2函数类型做为参数类型"><a href="#3-2函数类型做为参数类型" class="headerlink" title="3.2函数类型做为参数类型"></a>3.2函数类型做为参数类型</h5><p>函数类型也可以作为另一个函数的参数类型，这样我们就可以将函数的一部分实现留给函数的调用者来提供。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试1：</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">printMathResult</span>(<span class="keyword">_</span> <span class="params">mathFunction</span>: (<span class="type">Int</span>, <span class="type">Int</span>) -&gt; <span class="type">Int</span>, <span class="keyword">_</span> <span class="params">a</span>: <span class="type">Int</span>, <span class="keyword">_</span> <span class="params">b</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Result: <span class="subst">\(mathFunction(a, b))</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">printMathResult(addTwoInts, <span class="number">3</span>, <span class="number">5</span>)          <span class="comment">//打印 &quot;Result: 8”</span></span><br><span class="line">printMathResult(multiplyTwoInts, <span class="number">3</span>, <span class="number">5</span>)   <span class="comment">//打印：&quot;Result: 15&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//测试2：</span></span><br><span class="line"><span class="comment">//生成随机数组成的数组</span></span><br><span class="line"><span class="keyword">var</span> array: [<span class="type">Int</span>] <span class="operator">=</span> []</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">_</span> <span class="keyword">in</span> <span class="number">0</span><span class="operator">..&lt;</span><span class="number">6</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> max<span class="operator">=</span><span class="number">20</span></span><br><span class="line">    <span class="keyword">let</span> randNum0<span class="operator">=</span>arc4random()<span class="operator">%</span><span class="type">UInt32</span>(max)</span><br><span class="line">    <span class="keyword">let</span> randNum1<span class="operator">=</span><span class="type">Int</span>(randNum0)</span><br><span class="line">    <span class="keyword">if</span>(array.contains(randNum1))&#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    array.append(randNum1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(array)       <span class="comment">//[12, 9, 19, 13, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义排序方法1：从大到小排序</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">biggerNumFirst</span>(<span class="params">num1</span>:<span class="type">Int</span>, <span class="params">num2</span>:<span class="type">Int</span>) -&gt; <span class="type">Bool</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 <span class="operator">&gt;</span> num2</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//自定义排序方法2：将数字转化为字符串， 按照字符换的字典排序</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">compareByNumberString</span>(<span class="params">num1</span>: <span class="type">Int</span>, <span class="params">num2</span>: <span class="type">Int</span>) -&gt;<span class="type">Bool</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">String</span>(num1) <span class="operator">&gt;</span> <span class="type">String</span>(num2)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//自定义排序方法3：距离某个数字最近</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">nearTo10</span>(<span class="params">num1</span>: <span class="type">Int</span>, <span class="params">num2</span>: <span class="type">Int</span>) -&gt;<span class="type">Bool</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">abs</span>(num1 <span class="operator">-</span> <span class="number">10</span>) <span class="operator">&lt;</span> <span class="built_in">abs</span>(num2 <span class="operator">-</span> <span class="number">10</span>) <span class="operator">?</span> <span class="literal">true</span> :<span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">array.sort(by: biggerNumFirst(num1:num2:))</span><br><span class="line">array.sort(by: compareByNumberString)</span><br><span class="line">array.sort(by: nearTo10)</span><br><span class="line"><span class="comment">//测试打印:</span></span><br><span class="line"><span class="comment">//[19, 13, 12, 9, 3]</span></span><br><span class="line"><span class="comment">//[9, 3, 19, 13, 12]</span></span><br><span class="line"><span class="comment">//[9, 12, 13, 3, 19]</span></span><br></pre></td></tr></table></figure><h5 id="3-3-函数类型作为返回值类型"><a href="#3-3-函数类型作为返回值类型" class="headerlink" title="3.3.函数类型作为返回值类型"></a>3.3.函数类型作为返回值类型</h5><p>你可以用函数类型作为另一个函数的返回类型。你需要做的是在返回箭头（-&gt;）后写一个完整的函数类型。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">getMathFunction</span>(<span class="params">symbol</span>: <span class="type">String</span>)-&gt;(<span class="type">Int</span>,<span class="type">Int</span>)-&gt;<span class="type">Int</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> symbol <span class="operator">==</span> <span class="string">&quot;*&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> multiplyTwoInts;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> addTwoInts</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//传入不同的字符串参数，会返回不同的函数</span></span><br><span class="line"><span class="keyword">var</span> function <span class="operator">=</span> getMathFunction(symbol: <span class="string">&quot;*&quot;</span>)</span><br><span class="line">function(<span class="number">1</span>,<span class="number">2</span>)    <span class="comment">//2</span></span><br><span class="line">function <span class="operator">=</span> getMathFunction(symbol: <span class="string">&quot;abcdefg&quot;</span>)</span><br><span class="line">function(<span class="number">1</span>,<span class="number">2</span>)    <span class="comment">//3</span></span><br></pre></td></tr></table></figure><h1 id="八、嵌套函数"><a href="#八、嵌套函数" class="headerlink" title="八、嵌套函数"></a>八、嵌套函数</h1><p>通常，我们见到的都是全局函数，即定义在全局域中的函数。我们也可以把函数定义在别的函数体中，称作嵌套函数。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">getMathFunction2</span>(<span class="params">symbol</span>: <span class="type">String</span>)-&gt;(<span class="type">Int</span>,<span class="type">Int</span>)-&gt;<span class="type">Int</span>&#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">mathFunc1</span>(<span class="params">a</span>:<span class="type">Int</span>,<span class="params">b</span>:<span class="type">Int</span>)-&gt;<span class="type">Int</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a <span class="operator">-</span> b</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">mathFunc2</span>(<span class="params">a</span>: <span class="type">Int</span>, <span class="params">b</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a <span class="operator">*</span> b</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> symbol <span class="operator">==</span> <span class="string">&quot;*&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mathFunc2;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mathFunc1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> method <span class="operator">=</span> getMathFunction2(symbol: <span class="string">&quot;*&quot;</span>)</span><br><span class="line">method(<span class="number">5</span>,<span class="number">6</span>)     <span class="comment">//30</span></span><br><span class="line">method <span class="operator">=</span> getMathFunction2(symbol: <span class="string">&quot;123123&quot;</span>)</span><br><span class="line">method(<span class="number">5</span>,<span class="number">6</span>)     <span class="comment">//-1</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;函数&lt;/strong&gt;：是一段完成特定任务的独立代码片段。你可以通过给函数命名来标识某个函数的功能，这个名字可以被用来在需要的时候”调用”这个函数来完成它的任务；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主要内容：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;函数的定</summary>
      
    
    
    
    <category term="Swift" scheme="https://wuyubeichen.github.io/categories/Swift/"/>
    
    
    <category term="Swift" scheme="https://wuyubeichen.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift学习01-属性</title>
    <link href="https://wuyubeichen.github.io/2018/08/01/Swift%E5%AD%A6%E4%B9%A001-%E5%B1%9E%E6%80%A7/"/>
    <id>https://wuyubeichen.github.io/2018/08/01/Swift%E5%AD%A6%E4%B9%A001-%E5%B1%9E%E6%80%A7/</id>
    <published>2018-08-01T10:14:43.000Z</published>
    <updated>2022-08-19T08:08:54.201Z</updated>
    
    <content type="html"><![CDATA[<p><strong>属性</strong>：是与特定的Swift类、结构体、枚举相关联的值；与其他语言相比，属性不再是被类所特有；</p><p><strong>主要内容</strong>：</p><ol><li>存储属性与计算属性</li><li>属性观察器</li><li>类型属性</li><li>全局变量与局部变量</li></ol><h4 id="一、存储属性与计算属性"><a href="#一、存储属性与计算属性" class="headerlink" title="一、存储属性与计算属性"></a>一、存储属性与计算属性</h4><p>从属性被定义的方式上看，<code>Swift</code>属性有存储属性和计算属性两种：</p><ul><li>存储属性：存储在特定类或结构体实例里的一个常量(<code>let</code>)或变量(<code>var</code>)，作为实例的一部分；</li><li>计算属性：计算属性不直接存储值，而是提供一个<code>getter</code>和一个可选的<code>setter</code>，来间接设置其他属性或变量值；</li></ul><p>下面通过一段代码演示这两种属性的区别：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Square</span>&#123;</span><br><span class="line">    <span class="comment">//存储属性</span></span><br><span class="line">    <span class="keyword">var</span> width:<span class="type">Double</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算属性：通过一定计算方法得到的属性</span></span><br><span class="line">    <span class="keyword">var</span> area:<span class="type">Double</span>&#123;</span><br><span class="line">        <span class="keyword">get</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> width <span class="operator">*</span> width</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> square <span class="operator">=</span> <span class="type">Square</span>(width: <span class="number">10.0</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;正方形边长：<span class="subst">\(square.width)</span>&quot;</span>)     <span class="comment">//正方形边长：10.0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;正方形面积：<span class="subst">\(square.area)</span>&quot;</span>)      <span class="comment">//正方形面积：100.0</span></span><br></pre></td></tr></table></figure><p>总结存储属性和计算属性的用法还有如下几种情况：</p><h5 id="1-1-常量结构体的存储属性"><a href="#1-1-常量结构体的存储属性" class="headerlink" title="1.1.常量结构体的存储属性"></a>1.1.常量结构体的存储属性</h5><p>如果创建一个结构体的实例并且将其赋值给一个常量，则无法再修改该实例的任何属性(包括其中的变量属性)。这是因为结构体是值类型，值类型实例被声明为常量，其所有属性都成了常量；在这点上，类与结构体不同，这种情况下，类中的可变属性可以被修改。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> square1 <span class="operator">=</span> <span class="type">Square</span>(width: <span class="number">10.0</span>)</span><br><span class="line"><span class="comment">//square1.width = 11.0      //报错</span></span><br><span class="line"><span class="keyword">var</span> square2 <span class="operator">=</span> <span class="type">Square</span>(width:<span class="number">20.0</span>)</span><br><span class="line">square2.width <span class="operator">=</span> <span class="number">21.0</span>      <span class="comment">//可以修改</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//注：如果Squre是一个类，那么以上两种情况都可以通过</span></span><br></pre></td></tr></table></figure><h5 id="1-2-延迟存储属性"><a href="#1-2-延迟存储属性" class="headerlink" title="1.2.延迟存储属性"></a>1.2.延迟存储属性</h5><ul><li>定义：第一次被调用的时候才会计算其初始值的属性。在属性声明前使用<code>lazy</code>来表示一个延迟存储属性；</li><li>作用：当属性的值依赖于在实例的构造过程结束后才会知道影响值的外部因素时，或者当获得属性的初始值需要复杂或大量计算时，可以只在需要的时候计算它；</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Number</span>&#123;</span><br><span class="line">    <span class="comment">//存储属性</span></span><br><span class="line">    <span class="keyword">var</span> startNum: <span class="type">Int</span>!</span><br><span class="line">    <span class="keyword">var</span> endNum:<span class="type">Int</span>!</span><br><span class="line">    <span class="comment">//计算属性</span></span><br><span class="line">    <span class="keyword">var</span> length :<span class="type">Int</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> endNum <span class="operator">-</span> startNum <span class="operator">+</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//延迟属性：使用闭包计算出了延迟属性的值，此过程只执行一次</span></span><br><span class="line">    <span class="keyword">lazy</span> <span class="keyword">var</span> sum: <span class="type">Int</span> <span class="operator">=</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;计算延迟属性。。。。&quot;</span>)</span><br><span class="line">        <span class="keyword">var</span> tempNum <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="keyword">self</span>.startNum<span class="operator">...</span><span class="keyword">self</span>.endNum&#123;</span><br><span class="line">            tempNum <span class="operator">+=</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tempNum</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//可失败的构造方法</span></span><br><span class="line">    <span class="keyword">init?</span>(<span class="params">startNum</span>: <span class="type">Int</span> , <span class="params">endNum</span>:<span class="type">Int</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(startNum <span class="operator">&gt;</span> endNum)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">self</span>.startNum <span class="operator">=</span> startNum</span><br><span class="line">        <span class="keyword">self</span>.endNum <span class="operator">=</span> endNum</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> number <span class="operator">=</span> <span class="type">Number</span>(startNum: <span class="number">1</span>, endNum: <span class="number">100</span>)</span><br><span class="line">number<span class="operator">?</span>.length  <span class="comment">//100</span></span><br><span class="line">number<span class="operator">?</span>.sum    <span class="comment">//5050</span></span><br><span class="line">number<span class="operator">?</span>.sum    <span class="comment">//5050</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：</p><ol><li>必须将延迟存储属性声明成变量(使用<code>var</code>关键字)，因为属性的初始值可能在实例构造完成之后才会得到。而常量属性在构造过程完成之前必须要有初始值，因此无法声明成延迟属性；</li><li>如果一个被标记为 <code>lazy</code> 的属性在没有初始化时就同时被多个线程访问，则无法保证该属性只会被初始化一次；</li></ol><h5 id="1-3-计算属性的使用"><a href="#1-3-计算属性的使用" class="headerlink" title="1.3.计算属性的使用"></a>1.3.计算属性的使用</h5><p>计算属性不直接存储值，而是提供一个<code>getter</code>和一个可选的<code>setter</code>，来间接设置其他属性或变量值；总结它的使用特点如下：</p><ol><li>只有<code>getter</code>没有<code>setter</code>的计算属性就是只读计算属性。只读属性通过点运算符访问，只能返回值而不可设置新值；</li><li>计算属性与其他属性相关，是变化的，所以必须使用<code>var</code>关键字进行修饰，包括只读计算属性；</li><li>只读计算属性可以去掉<code>get</code>关键字和花括号；</li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">var</span> y <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Size</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> width <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">var</span> height <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span>&#123;</span><br><span class="line">    <span class="comment">//存储型数据</span></span><br><span class="line">    <span class="keyword">var</span> originPoint  <span class="operator">=</span> <span class="type">Point</span>()</span><br><span class="line">    <span class="keyword">var</span> size <span class="operator">=</span> <span class="type">Size</span>()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算型属性</span></span><br><span class="line">    <span class="keyword">var</span> center:<span class="type">Point</span>&#123;</span><br><span class="line">        <span class="comment">//get方法：获取计算属性值</span></span><br><span class="line">        <span class="keyword">get</span>&#123;</span><br><span class="line">            <span class="keyword">let</span> center_x <span class="operator">=</span> originPoint.x <span class="operator">+</span> size.width<span class="operator">/</span><span class="number">2</span></span><br><span class="line">            <span class="keyword">let</span> center_y <span class="operator">=</span> originPoint.y <span class="operator">+</span> size.height<span class="operator">/</span><span class="number">2</span></span><br><span class="line">            <span class="keyword">return</span> <span class="type">Point</span>(x: center_x, y: center_y)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果没有set方法，是只读，</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         set(newCenter)&#123;</span></span><br><span class="line"><span class="comment">            originPoint.x = newCenter.x - size.width/2</span></span><br><span class="line"><span class="comment">            originPoint.y = newCenter.y - size.height/2</span></span><br><span class="line"><span class="comment">         &#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//set方法：设置计算属性新值</span></span><br><span class="line">        <span class="comment">//这里也可以省略括号和newCenter.使用newValue</span></span><br><span class="line">        <span class="keyword">set</span>&#123;</span><br><span class="line">            originPoint.x <span class="operator">=</span> newValue.x <span class="operator">-</span> size.width<span class="operator">/</span><span class="number">2</span></span><br><span class="line">            originPoint.y <span class="operator">=</span> newValue.y <span class="operator">-</span> size.height<span class="operator">/</span><span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算属性：area属性只有get,可以不显式的声明出get；此属性为只读属性</span></span><br><span class="line">    <span class="keyword">var</span> area:<span class="type">Double</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size.width <span class="operator">*</span> size.height</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">origin</span>: <span class="type">Point</span>, <span class="params">size</span>: <span class="type">Size</span>)&#123;</span><br><span class="line">        <span class="keyword">self</span>.originPoint  <span class="operator">=</span> origin</span><br><span class="line">        <span class="keyword">self</span>.size  <span class="operator">=</span> size</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建一个长方形</span></span><br><span class="line"><span class="keyword">var</span> rect <span class="operator">=</span> <span class="type">Rectangle</span>(origin: <span class="type">Point</span>(x: <span class="number">0</span>, y: <span class="number">0</span>), size: <span class="type">Size</span>(width: <span class="number">100</span>, height: <span class="number">100</span>))</span><br><span class="line">rect.center</span><br><span class="line">rect.area  <span class="comment">//10000</span></span><br></pre></td></tr></table></figure><h4 id="二、属性观察器"><a href="#二、属性观察器" class="headerlink" title="二、属性观察器"></a>二、属性观察器</h4><p>属性观察器监控和响应属性值的变化，每次属性被设置值的时候都会调用属性观察器，即使新值和当前值相同的时候也不例外；</p><p>属性观察器可以为延迟属性外的其他存储属性添加属性观察，也可以通过继承的方式重写父类属性，为其添加属性观察期。但是我们没有必要为非重写的计算属性添加属性观察器，因为它本身就可以通过自己的<code>setter</code>直接监控和响应值的变化；</p><p>添加属性观察器方式如下：</p><ul><li><code>willSet</code>方法：在新的值被设置之前调用，拥有一个默认参数<code>newValue</code>(代表新的属性值)；</li><li><code>didSet</code>方法：在新的值被设置之后立刻调用,拥有一个默认参数<code>oldValue</code>(代表就的属性值)；</li></ul><p>下面通过<code>lightBlub</code>演示用法，其中为<code>currentDianYa</code>属性添加了观察器：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">lightBlub</span> &#123;</span><br><span class="line">    <span class="comment">//最大电压和当前电压</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> maxDianYa <span class="operator">=</span> <span class="number">30</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//属性监听</span></span><br><span class="line">    <span class="comment">//注意：willSet和didSet括号中的值可以省略，直接使用系统自带的newVlaue和oldValue</span></span><br><span class="line">    <span class="keyword">var</span> currentDianYa <span class="operator">=</span> <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">//可以使用系统默认的属性newValue和oldValue</span></span><br><span class="line">        <span class="keyword">willSet</span>(newCurrentDianya)&#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;当前电压值将要改变:  <span class="subst">\(currentDianYa)</span> -&gt; <span class="subst">\(newCurrentDianya)</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当调用此方法时，已经设置了值的时候,</span></span><br><span class="line">        <span class="keyword">didSet</span>(oldCurentDianYa)&#123;</span><br><span class="line">            <span class="keyword">if</span>(currentDianYa <span class="operator">==</span> lightBlub.maxDianYa)&#123;</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;请注意 ,当前电压达到了最大电压值&quot;</span>)</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">self</span>.currentDianYa <span class="operator">&gt;</span> lightBlub.maxDianYa)&#123;</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;当前电压过高，不能设置新的电压值&quot;</span>)</span><br><span class="line">                currentDianYa <span class="operator">=</span> oldCurentDianYa</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> light <span class="operator">=</span> lightBlub()</span><br><span class="line">light.currentDianYa <span class="operator">=</span> <span class="number">10</span></span><br><span class="line">light.currentDianYa <span class="operator">=</span> <span class="number">30</span></span><br><span class="line">light.currentDianYa <span class="operator">=</span> <span class="number">40</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 打印结果：</span></span><br><span class="line"><span class="comment"> 当前电压值将要改变:  0 -&gt; 10</span></span><br><span class="line"><span class="comment"> 当前电压值将要改变:  10 -&gt; 30</span></span><br><span class="line"><span class="comment"> 请注意 ,当前电压达到了最大电压值</span></span><br><span class="line"><span class="comment"> 当前电压值将要改变:  30 -&gt; 40</span></span><br><span class="line"><span class="comment"> 当前电压过高，不能设置新的电压值</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>注意：willSet和didSet并不会在初始化时被调用</strong></p><h4 id="三、类型属性"><a href="#三、类型属性" class="headerlink" title="三、类型属性"></a>三、类型属性</h4><p><strong>实例属性</strong>属于一个特定类型的实例，因此实例之间的属性相互独立。但其实，也可以为类型本身定义属性，这样无论创建了多少个该类型实例，这些属性只有唯一的一份，这种属性就是<strong>类型属性</strong>。</p><p><code>Swift</code>的类型属性就相当于<code>OC</code>或者<code>C</code>中的类变量，但他们有着以下的不同： 在<code>OC</code>或者<code>C</code>中，与某个类型相关的静态常量和静态变量，是作为全局静态变量来定义的。但是Swift中，类型属性是作为类型定义的一部分写在类型最外层的花括号内，因此它的作用范围也就在类型支持的范围内；</p><p><code>Swift</code>类型属性使用关键字<code>static</code>,下面是一个具体示例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试Int的类型属性</span></span><br><span class="line"><span class="type">Int</span>.min </span><br><span class="line"><span class="type">Int</span>.max</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="comment">//对象属性：本人的得分</span></span><br><span class="line">    <span class="keyword">var</span> score: <span class="type">Int</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="comment">//类型属性：本游戏的最高得分,使用类名来访问，使用关键字static声明</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> heighestScore:<span class="type">Int</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造方法</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>)&#123;</span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//玩一句游戏得分</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">playGame</span>()&#123;</span><br><span class="line">        <span class="keyword">let</span> tempNum <span class="operator">=</span> <span class="type">Int</span>(arc4random()<span class="operator">%</span><span class="number">100</span>)<span class="operator">+</span><span class="number">1</span></span><br><span class="line">        <span class="keyword">self</span>.score <span class="operator">+=</span> tempNum</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(name)</span> 的游戏得分是：<span class="subst">\(score)</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">self</span>.score <span class="operator">&gt;</span> <span class="type">Player</span>.heighestScore)&#123;</span><br><span class="line">            <span class="type">Player</span>.heighestScore <span class="operator">=</span> <span class="keyword">self</span>.score</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;当前本游戏的最高分是:<span class="subst">\(Player.heighestScore)</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> player1 <span class="operator">=</span> <span class="type">Player</span>(name: <span class="string">&quot;zs&quot;</span>)</span><br><span class="line">player1.playGame()</span><br><span class="line">player1.playGame()</span><br><span class="line"><span class="keyword">let</span> player2 <span class="operator">=</span> <span class="type">Player</span>(name: <span class="string">&quot;cf&quot;</span>)</span><br><span class="line">player2.playGame()</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 打印结果</span></span><br><span class="line"><span class="comment"> zs 的游戏得分是：11</span></span><br><span class="line"><span class="comment"> 当前本游戏的最高分是:11</span></span><br><span class="line"><span class="comment"> zs 的游戏得分是：87</span></span><br><span class="line"><span class="comment"> 当前本游戏的最高分是:87</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> cf 的游戏得分是：88</span></span><br><span class="line"><span class="comment"> 当前本游戏的最高分是:88</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="四、全局变量与局部变量"><a href="#四、全局变量与局部变量" class="headerlink" title="四、全局变量与局部变量"></a>四、全局变量与局部变量</h4><ul><li><p>全局变量：在函数、方法、闭包或者任意类型之外定义的变量；</p></li><li><p>局部变量：在函数、方法或者闭包内部定义的变量；</p><p>全局的常量或变量都是延迟计算的，跟延迟存储属性相似，不同的地方在于：全局的常量或变量不需要标记lazy修饰符。</p></li></ul><p>局部范围的常量或变量从不延迟计算。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;属性&lt;/strong&gt;：是与特定的Swift类、结构体、枚举相关联的值；与其他语言相比，属性不再是被类所特有；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主要内容&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;存储属性与计算属性&lt;/li&gt;
&lt;li&gt;属性观察器&lt;/li&gt;
</summary>
      
    
    
    
    <category term="Swift" scheme="https://wuyubeichen.github.io/categories/Swift/"/>
    
    
    <category term="Swift" scheme="https://wuyubeichen.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>ReactiveCocoa函数响应式编程-应用篇</title>
    <link href="https://wuyubeichen.github.io/2018/04/03/ReactiveCocoa%E5%BA%94%E7%94%A8%E7%AF%87/"/>
    <id>https://wuyubeichen.github.io/2018/04/03/ReactiveCocoa%E5%BA%94%E7%94%A8%E7%AF%87/</id>
    <published>2018-04-03T06:58:39.000Z</published>
    <updated>2022-08-17T03:01:16.092Z</updated>
    
    <content type="html"><![CDATA[<p>使用RAC其实就是一个创建信号订阅信号的过程。上篇<a href="https://www.jianshu.com/p/ba90d649ecb8">ReactiveCocoa函数响应式编程-基础篇</a>，主要简单介绍了RAC的信号机制，本篇则以信号为核心，就信号常用的类、操作信号的方法，替换响应处理等方面总结RAC的使用。</p><span id="more"></span><h1 id="目录："><a href="#目录：" class="headerlink" title="目录："></a>目录：</h1><p>一、RAC中常用的类<br>二、RAC中常用的宏<br>三、RAC中信号的常用操作<br>四、RAC常用的处理事件响应的方法<br>五、本篇总结</p><p><strong>本篇还提供了关于RAC使用的两个测试工程，结合代码学习更加直观</strong>：<br><a href="https://github.com/DreamcoffeeZS/ReactiveCocoaDemo">项目1</a>：<br>1.测试RAC对信号的各类操作。<br>2.使用RAC改进一个普通的登录界面。<br><a href="https://github.com/DreamcoffeeZS/MVVMReactiveCocoa">项目2</a>：<br>MVVM架构结合RAC响应式编程的开发示例。实现登录界面和的分页数据界面。效果图如下：<br><img src="https://upload-images.jianshu.io/upload_images/1244124-34473c827d2898b5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="RAC&amp;&amp;MVVM实现一个登录界面和一个分页数据表视图界面"></p><h1 id="一、RAC中常用的类"><a href="#一、RAC中常用的类" class="headerlink" title="一、RAC中常用的类"></a>一、RAC中常用的类</h1><h2 id="1-RACSubject"><a href="#1-RACSubject" class="headerlink" title="1.RACSubject"></a>1.RACSubject</h2><p>RACSubject是信号RACSignal的一个子类，但它的底部实现与RACSignal有所不同。其订阅信号subscribeNext的方法只是使用nextBlock创建了一个订阅者并保存起来待用，多次调用subscribeNext会保存多个订阅者。<strong>只有发送信号sendNext方法执行时，订阅者才会执行nextBlock里的内容，多个订阅者会执行多次</strong>。<br>使用示例：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建信号</span></span><br><span class="line"><span class="comment">//创建RACSubject不需要block参数</span></span><br><span class="line">RACSubject *subject = [RACSubject subject];</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.订阅信号</span></span><br><span class="line"><span class="comment">//这里信号被订阅两次，那么订阅者也创建了两次，保存在RACSubject的subscribers属性数组中。</span></span><br><span class="line"><span class="comment">//那么每当信号有新值发出的时候，每个订阅者都会执行。    </span></span><br><span class="line">[subject subscribeNext:^(<span class="type">id</span> x) &#123;</span><br><span class="line">    <span class="comment">//block在信号发出新值时调用</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;第一个订阅者:%@&quot;</span>,x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[subject subscribeNext:^(<span class="type">id</span> x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;第二个订阅者:%@&quot;</span>,x);</span><br><span class="line">&#125;];</span><br><span class="line">    </span><br><span class="line"><span class="comment">//3.发送信号</span></span><br><span class="line">[subject sendNext:<span class="string">@&quot;6”];</span></span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">控制台打印：</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-24</span> <span class="number">13</span>:<span class="number">07</span>:<span class="number">51.425569</span>+<span class="number">0800</span> ZSTest[<span class="number">2840</span>:<span class="number">124915</span>] 第一个订阅者:<span class="number">6</span></span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-24</span> <span class="number">13</span>:<span class="number">07</span>:<span class="number">51.426113</span>+<span class="number">0800</span> ZSTest[<span class="number">2840</span>:<span class="number">124915</span>] 第二个订阅者:<span class="number">6</span></span><br></pre></td></tr></table></figure><p>应用示例：<strong>替换代理</strong><br>我们测试这样一个功能：在当前视图控制器A中点击按钮调转到下一视图控制器B，在B的文本框中输入内容，点击编辑完成按钮回到A，显示B中输入的内容到A的UILabel上。通常我们使用代理来解决这样的问题，那么现在我们可以利用RACSubject的特性来代替常用的代理的功能，其实就跟我们使用block回调一样。具体代码如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.下一视图控制中添加RACSubject属性。</span></span><br><span class="line"><span class="comment">//SecondViewController.h文件</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SecondViewController</span> : <span class="title">BaseViewController</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) RACSubject *racSubject;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2.点击编辑完成按钮时，检查代理信号并发送消息，这里传递出一个字典(包含输入的文字)</span></span><br><span class="line"><span class="comment">//SecondViewController.m文件</span></span><br><span class="line">- (<span class="keyword">IBAction</span>)completeBtnClick:(<span class="type">id</span>)sender &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">self</span>.racSubject)&#123;</span><br><span class="line">        [<span class="keyword">self</span>.racSubject sendNext:@&#123;<span class="string">@&quot;text&quot;</span>:<span class="keyword">self</span>.txtField.text&#125;];</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span>.navigationController popViewControllerAnimated:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3.当前视图控制器A的跳转按钮响应方法中，创建secondVC，并为其添加信号属性和订阅信号。</span></span><br><span class="line"><span class="comment">//TestViewCotroller.m文件</span></span><br><span class="line">- (<span class="keyword">IBAction</span>)testBtnClick:(<span class="type">id</span>)sender &#123;</span><br><span class="line">    SecondViewController *secondVC = [[SecondViewController alloc] initWithNibName:<span class="string">@&quot;SecondViewController&quot;</span> bundle:<span class="literal">nil</span>];</span><br><span class="line">   <span class="comment">//为secondVC设置RACSubject属性，并订阅信号</span></span><br><span class="line">    secondVC.racSubject = [RACSubject subject];</span><br><span class="line">    __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line">    <span class="comment">//定阅信号的block会更新文字的显示</span></span><br><span class="line">    [secondVC.racSubject subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">        <span class="built_in">NSDictionary</span> *infoDic =(<span class="built_in">NSDictionary</span> *)x;</span><br><span class="line">        weakSelf.showLabel.text =  infoDic[<span class="string">@&quot;text&quot;</span>];</span><br><span class="line">    &#125;];</span><br><span class="line">    [<span class="keyword">self</span>.navigationController pushViewController:secondVC animated:<span class="literal">YES</span>];</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="2-RACTuple与RACSequence"><a href="#2-RACTuple与RACSequence" class="headerlink" title="2.RACTuple与RACSequence"></a>2.RACTuple与RACSequence</h2><p><strong>RACTuple</strong>：类似OC的数组，是RAC中用来封装值的元组类，可以配合RACTupleUnpack解元组。<br><strong>RACSequeue</strong>：数组和字典经过rac_sequence方法会被转化为RACSequeue类型，并进一步转为我们常用的信号。订阅此类信号的时候，信号就会被激活并遍历其中的所有值。</p><p>使用示例：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历数组</span></span><br><span class="line"><span class="built_in">NSArray</span> *characters = @[<span class="string">@&quot;A&quot;</span>,<span class="string">@&quot;C&quot;</span>,<span class="string">@&quot;B&quot;</span>,<span class="string">@&quot;E&quot;</span>,<span class="string">@&quot;D&quot;</span>];</span><br><span class="line">    [characters.rac_sequence.signal subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;char:%@&quot;</span>,x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">控制台打印：</span><br><span class="line"><span class="type">char</span>:A</span><br><span class="line"><span class="type">char</span>:C</span><br><span class="line"><span class="type">char</span>:B</span><br><span class="line"><span class="type">char</span>:E</span><br><span class="line"><span class="type">char</span>:D</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历字典</span></span><br><span class="line"><span class="built_in">NSDictionary</span> *myInfoDic = @&#123;<span class="string">@&quot;name&quot;</span>:<span class="string">@&quot;zs&quot;</span>,<span class="string">@&quot;nickname&quot;</span>:<span class="string">@&quot;FengZi&quot;</span>,<span class="string">@&quot;age&quot;</span>:<span class="string">@&quot;18&quot;</span>&#125;;\</span><br><span class="line">[myInfoDic.rac_sequence.signal subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="comment">//解元组，注意一一对应</span></span><br><span class="line">    RACTupleUnpack(<span class="built_in">NSString</span> *key,<span class="built_in">NSString</span> *value) = x;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;myInfoDic:%@-%@&quot;</span>,key,value);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">控制台打印：</span><br><span class="line">myInfoDic:name-zs</span><br><span class="line">myInfoDic:nickname-FengZi</span><br><span class="line">myInfoDic:age<span class="number">-18</span></span><br></pre></td></tr></table></figure><h2 id="3-RACMulticastConnection"><a href="#3-RACMulticastConnection" class="headerlink" title="3.RACMulticastConnection"></a>3.RACMulticastConnection</h2><p>RACMulticastConnection用于解决一个信号被多次订阅后，创建信号中的block被重复调用的问题，所以在实际开发中，使用RACMulticastConnection可以解决网络重复请求的问题。<br>测试1:普通的信号</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signalA = [RACSignal createSignal:^RACDisposable *(<span class="type">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@&quot;发送信号A&quot;</span>);</span><br><span class="line">   [subscriber sendNext:<span class="string">@&quot;发送信号A&quot;</span>];</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[signalA subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@&quot;第一次订阅：%@&quot;</span>,x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"> [signalA subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@&quot;第二次订阅：%@&quot;</span>,x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">控制台打印：</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-28</span> <span class="number">10</span>:<span class="number">02</span>:<span class="number">00.702607</span>+<span class="number">0800</span> ZSTest[<span class="number">2446</span>:<span class="number">48444</span>] 发送信号A</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-28</span> <span class="number">10</span>:<span class="number">02</span>:<span class="number">00.702856</span>+<span class="number">0800</span> ZSTest[<span class="number">2446</span>:<span class="number">48444</span>] 第一次订阅：发送信号A</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-28</span> <span class="number">10</span>:<span class="number">02</span>:<span class="number">00.703069</span>+<span class="number">0800</span> ZSTest[<span class="number">2446</span>:<span class="number">48444</span>] 发送信号A</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-28</span> <span class="number">10</span>:<span class="number">02</span>:<span class="number">00.703325</span>+<span class="number">0800</span> ZSTest[<span class="number">2446</span>:<span class="number">48444</span>] 第二次订阅：发送信号A</span><br></pre></td></tr></table></figure><p>测试2：使用RACMulticastConnection</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建信号</span></span><br><span class="line">RACSignal *signalB = [RACSignal createSignal:^RACDisposable *(<span class="type">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;发送信号B&quot;</span>);</span><br><span class="line">    [subscriber sendNext:<span class="string">@&quot;发送信号B&quot;</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line">    </span><br><span class="line"><span class="comment">//2.连接信号：publish或者muticast方法</span></span><br><span class="line"><span class="comment">//连接后的信号使用订阅方法时，并不能激活信号，而是将其订阅者保存到数组中。</span></span><br><span class="line"><span class="comment">//在连接对象执行connect方法时，信号中的订阅者会统一调用sendNext方法。</span></span><br><span class="line">RACMulticastConnection *signalBconnect = [signalB publish];</span><br><span class="line">    </span><br><span class="line"><span class="comment">//3.订阅信号</span></span><br><span class="line"><span class="comment">//使用signalBconnect而不再是signalB</span></span><br><span class="line">[signalBconnect.signal subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;第一次订阅：%@&quot;</span>,x);</span><br><span class="line">&#125;];</span><br><span class="line">[signalBconnect.signal subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;第二次订阅：%@&quot;</span>,x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.连接后激活信号</span></span><br><span class="line">[signalBconnect connect];</span><br><span class="line"></span><br><span class="line">控制台打印：</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-28</span> <span class="number">10</span>:<span class="number">02</span>:<span class="number">00.704209</span>+<span class="number">0800</span> ZSTest[<span class="number">2446</span>:<span class="number">48444</span>] 发送信号B</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-28</span> <span class="number">10</span>:<span class="number">02</span>:<span class="number">00.704368</span>+<span class="number">0800</span> ZSTest[<span class="number">2446</span>:<span class="number">48444</span>] 第一次订阅：发送信号B</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-28</span> <span class="number">10</span>:<span class="number">02</span>:<span class="number">00.704543</span>+<span class="number">0800</span> ZSTest[<span class="number">2446</span>:<span class="number">48444</span>] 第二次订阅：发送信号B</span><br></pre></td></tr></table></figure><h2 id="4-RACCommand：用于处理事件的类"><a href="#4-RACCommand：用于处理事件的类" class="headerlink" title="4.RACCommand：用于处理事件的类"></a>4.RACCommand：用于处理事件的类</h2><p>RACCommand可以把事件如何处理，如何传递都封装到类中，之后就可以方便的调起它的执行方法。在实际开发中，我们可以用它来封装一个网络操作。<br>注意：<br>1.创建方法中block返回一个信号，且不能为nil，但是可以使用[RACSignal empty]表示空信号<br>2.RACCommand必须被强引用，否则容易被释放</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建RACCommand：initWithSignalBlock</span></span><br><span class="line"><span class="keyword">self</span>.command = [[RACCommand alloc] initWithSignalBlock:^RACSignal * _Nonnull(<span class="type">id</span>  _Nullable input) &#123;</span><br><span class="line">    <span class="comment">//我们常在这里创建一个网络请求的信号，也就是封装一个请求数据的操作。</span></span><br><span class="line">    RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="type">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">        [subscriber sendNext:<span class="string">@&quot;网络请求的信号&quot;</span>];</span><br><span class="line">        <span class="comment">//数据传递完成，必须调用sendComplleted.,否则永远处于执行中。</span></span><br><span class="line">        [subscriber sendCompleted];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="keyword">return</span> signal;</span><br><span class="line">&#125;];</span><br><span class="line">    </span><br><span class="line"><span class="comment">//2.订阅RACCommand中的信号，要等到RACCommand执行后，才能收到消息</span></span><br><span class="line">[<span class="keyword">self</span>.command.executionSignals subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="comment">//这里是一个信号中信号</span></span><br><span class="line">    [x subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;收到信号：%@&quot;</span>,x);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">//改进订阅方法：switchToLatest可以直接获取信号中信号</span></span><br><span class="line">[<span class="keyword">self</span>.command.executionSignals.switchToLatest subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;改进-收到信号：%@&quot;</span>,x);</span><br><span class="line">&#125;];</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">//3.监听RACCommand命令是否执行完毕的信号</span></span><br><span class="line"><span class="comment">//默认会监测一次，所以可以使用skip表示跳过第一次信号。</span></span><br><span class="line"><span class="comment">//这里可以用于App网络请求时，控制加载提示视图的隐藏或者显示</span></span><br><span class="line">[[<span class="keyword">self</span>.command.executing skip:<span class="number">1</span>] subscribeNext:^(<span class="built_in">NSNumber</span> * _Nullable x) &#123;</span><br><span class="line">    <span class="keyword">if</span>([x boolValue] == <span class="literal">YES</span>)&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;RACCommand命令正在执行...&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;RACCommand命令不在执行中！！！&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br><span class="line">    </span><br><span class="line"><span class="comment">//4.执行RACComand</span></span><br><span class="line"><span class="comment">//方法：- (RACSignal *)execute:(id)input</span></span><br><span class="line">[<span class="keyword">self</span>.command execute:<span class="string">@&quot;&quot;</span>];</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">控制台打印：</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-24</span> <span class="number">14</span>:<span class="number">43</span>:<span class="number">06.571968</span>+<span class="number">0800</span> ZSTest[<span class="number">3725</span>:<span class="number">171859</span>] RACCommand命令正在执行...</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-24</span> <span class="number">14</span>:<span class="number">43</span>:<span class="number">06.572526</span>+<span class="number">0800</span> ZSTest[<span class="number">3725</span>:<span class="number">171859</span>] 收到信号：网络请求的信号</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-24</span> <span class="number">14</span>:<span class="number">43</span>:<span class="number">06.572662</span>+<span class="number">0800</span> ZSTest[<span class="number">3725</span>:<span class="number">171859</span>] 改进-收到信号：网络请求的信号</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-24</span> <span class="number">14</span>:<span class="number">43</span>:<span class="number">06.573506</span>+<span class="number">0800</span> ZSTest[<span class="number">3725</span>:<span class="number">171859</span>] RACCommand命令不在执行中！！！</span><br></pre></td></tr></table></figure><h1 id="二、RAC常用的宏定义"><a href="#二、RAC常用的宏定义" class="headerlink" title="二、RAC常用的宏定义"></a>二、RAC常用的宏定义</h1><h2 id="1-RAC-对象，对象属性-：绑定属性"><a href="#1-RAC-对象，对象属性-：绑定属性" class="headerlink" title="1.RAC(对象，对象属性)：绑定属性"></a>1.RAC(对象，对象属性)：绑定属性</h2><p>输入框背景色绑定了映射后的validUserNameSignal信号，信号变化时背景色更新</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RAC(<span class="keyword">self</span>.userNameTxtField,backgroundColor) = [validUserNameSignal map:^<span class="type">id</span> _Nullable(<span class="built_in">NSNumber</span> *userNameValid) &#123;</span><br><span class="line">    <span class="keyword">return</span> [userNameValid boolValue] ? [<span class="built_in">UIColor</span> whiteColor] : [<span class="built_in">UIColor</span> yellowColor];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h2 id="2-RACObserve-被观察的对象，被观察对象的属性-：代替KVO监听某个对象的某个属性"><a href="#2-RACObserve-被观察的对象，被观察对象的属性-：代替KVO监听某个对象的某个属性" class="headerlink" title="2.RACObserve(被观察的对象，被观察对象的属性) ：代替KVO监听某个对象的某个属性"></a>2.RACObserve(被观察的对象，被观察对象的属性) ：代替KVO监听某个对象的某个属性</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[RACObserve(<span class="keyword">self</span>.view, backgroundColor) subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;测试：%@&quot;</span>,x);</span><br><span class="line">&#125;];</span><br><span class="line"><span class="comment">//颜色变化时将打印</span></span><br><span class="line"><span class="keyword">self</span>.view.backgroundColor = [<span class="built_in">UIColor</span> whiteColor];</span><br><span class="line"><span class="keyword">self</span>.view.backgroundColor =[<span class="built_in">UIColor</span> redColor];</span><br></pre></td></tr></table></figure><h2 id="3-RACTuplePack与RACTupleUnpack"><a href="#3-RACTuplePack与RACTupleUnpack" class="headerlink" title="3.RACTuplePack与RACTupleUnpack"></a>3.RACTuplePack与RACTupleUnpack</h2><p><strong>RACTuplePack</strong>：将数据封装成元组<br><strong>RACTupleUnpack</strong>：将元组解包为数据</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用RACTuplePack封装元组</span></span><br><span class="line">RACTuple *racTuple = RACTuplePack(<span class="string">@&quot;字符串1&quot;</span>,<span class="string">@&quot;字符串2&quot;</span>);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;测试racTuple:%@&quot;</span>,racTuple);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用RACTupleUnpack解元组</span></span><br><span class="line">RACTupleUnpack(<span class="built_in">NSString</span> *str1,<span class="built_in">NSString</span> *str2) = racTuple;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;测试RACTupleUnpack：%@-%@&quot;</span>,str1,str2);</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">控制台打印：</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-26</span> <span class="number">19</span>:<span class="number">27</span>:<span class="number">27.568399</span>+<span class="number">0800</span> ZSTest[<span class="number">23113</span>:<span class="number">380213</span>] 测试racTuple:&lt;RACTwoTuple: <span class="number">0x60400000ed70</span>&gt; (</span><br><span class="line">    <span class="string">&quot;\U5b57\U7b26\U4e321&quot;</span>,</span><br><span class="line">    <span class="string">&quot;\U5b57\U7b26\U4e322&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-26</span> <span class="number">19</span>:<span class="number">27</span>:<span class="number">27.568623</span>+<span class="number">0800</span> ZSTest[<span class="number">23113</span>:<span class="number">380213</span>] 测试RACTupleUnpack：字符串<span class="number">1</span>-字符串<span class="number">2</span></span><br></pre></td></tr></table></figure><h2 id="4-weakify、-strongify"><a href="#4-weakify、-strongify" class="headerlink" title="4.@weakify、@strongify"></a>4.@weakify、@strongify</h2><p>RAC中使用@weakify、@strongify解决Block循环引用的问题。<strong>在block内部使用@strongify(self)后就可以使用self操作属性了，但是一定注意这两个宏定义一定要配合使用</strong>，<a href="https://www.jianshu.com/p/701da54bd78c">可参考源码分析</a>。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@weakify(<span class="keyword">self</span>);</span><br><span class="line"><span class="comment">//RAC处理手势，点击页面，隐藏键盘</span></span><br><span class="line">[<span class="keyword">self</span>.tapGesture.rac_gestureSignal subscribeNext:^(__kindof <span class="built_in">UIGestureRecognizer</span> * _Nullable x) &#123;</span><br><span class="line">    @strongify(<span class="keyword">self</span>);</span><br><span class="line">    <span class="comment">//经过宏定义处理后就可以使用self了，但此self非彼self。具体可查看源码分析</span></span><br><span class="line">    [<span class="keyword">self</span>.view endEditing:<span class="literal">YES</span>];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h1 id="三、RAC中关于信号的常用操作"><a href="#三、RAC中关于信号的常用操作" class="headerlink" title="三、RAC中关于信号的常用操作"></a>三、RAC中关于信号的常用操作</h1><p>本节整理了以下几种常用信号操作：<br>1.信号映射：map与flattenMap<br>2.信号过滤：filter、ignore、 distinctUntilChanged<br>3.信号合并： combineLatest、reduce、merge、zipWith<br>4.信号连接：concat、then<br>5.信号操作时间：timeout、interval、dely<br>6.信号取值：take、takeLast、takeUntil、<br>7.信号跳过：skip<br>8.信号发送顺序：donext、cocompleted<br>9.获取信号中的信号：switchToLatest<br>10.信号错误重试：retry<br>11.信号节流：throttle<br>12.信号操作多线程：deliverON、subscribeOn</p><h2 id="1-信号映射：map与flattenMap"><a href="#1-信号映射：map与flattenMap" class="headerlink" title="1.信号映射：map与flattenMap"></a>1.信号映射：map与flattenMap</h2><p><strong>map</strong>：将信号内容修改为另一种新值。改变了传递的值<br><strong>flattenMap</strong>：将源信号映射修改为另一种新的信号。修改了信号本身</p><h3 id="1-1、map"><a href="#1-1、map" class="headerlink" title="1.1、map"></a>1.1、map</h3><p>将信号文本值修改为文本长度</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//block中return的是你希望接收到的值</span></span><br><span class="line">[[<span class="keyword">self</span>.txtField.rac_textSignal map:^<span class="type">id</span> _Nullable(<span class="built_in">NSString</span> * _Nullable value) &#123;</span><br><span class="line">    <span class="keyword">return</span> @(value.length);<span class="comment">//必须返回一个对象</span></span><br><span class="line">&#125;] subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">     <span class="comment">//输入abcd，打印了输入字符的长度</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;打印x:%@&quot;</span>,x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">控制台打印：</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">10</span>:<span class="number">52</span>:<span class="number">41.831785</span>+<span class="number">0800</span> ZSTest[<span class="number">1143</span>:<span class="number">44274</span>] 打印x:<span class="number">1</span></span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">10</span>:<span class="number">52</span>:<span class="number">42.575238</span>+<span class="number">0800</span> ZSTest[<span class="number">1143</span>:<span class="number">44274</span>] 打印x:<span class="number">2</span></span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">10</span>:<span class="number">52</span>:<span class="number">43.602008</span>+<span class="number">0800</span> ZSTest[<span class="number">1143</span>:<span class="number">44274</span>] 打印x:<span class="number">3</span></span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">10</span>:<span class="number">52</span>:<span class="number">44.054940</span>+<span class="number">0800</span> ZSTest[<span class="number">1143</span>:<span class="number">44274</span>] 打印x:<span class="number">4</span></span><br></pre></td></tr></table></figure><h3 id="1-2、flattenMap"><a href="#1-2、flattenMap" class="headerlink" title="1.2、flattenMap"></a>1.2、flattenMap</h3><p>flattenMap的block返回的是你想要的信号</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个普通信号</span></span><br><span class="line">RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="type">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:<span class="string">@&quot;发送信号：1&quot;</span>];</span><br><span class="line">    [subscriber sendCompleted];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个发送信号的信号，信号的信号</span></span><br><span class="line">RACSignal *signalOfSignals = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="type">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:signal];</span><br><span class="line">    [subscriber sendCompleted];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line">    </span><br><span class="line"><span class="comment">//订阅信号中的信号</span></span><br><span class="line">[signalOfSignals subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="comment">//不使用flattenMap，会打印出内部信号</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;订阅signalOfSignals：%@&quot;</span>,x);</span><br><span class="line">&#125;];</span><br><span class="line">    </span><br><span class="line">[[signalOfSignals flattenMap:^__kindof RACSignal * _Nullable(<span class="type">id</span>  _Nullable value) &#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">   &#125;] subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="comment">//使用flattenMap，会打印内部信号的值</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;使用flattenMap后订阅signalOfSignals：%@&quot;</span>,x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">控制台打印：</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">11</span>:<span class="number">23</span>:<span class="number">42.920455</span>+<span class="number">0800</span> ZSTest[<span class="number">1363</span>:<span class="number">61658</span>] 订阅signalOfSignals：&lt;RACDynamicSignal: <span class="number">0x60400023a320</span>&gt; name: </span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">11</span>:<span class="number">23</span>:<span class="number">42.920791</span>+<span class="number">0800</span> ZSTest[<span class="number">1363</span>:<span class="number">61658</span>] 使用flattenMap后订阅signalOfSignals：发送信号：<span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>特别说明：信号中信号常出现在我们封装一个网络请求为信号的时候，这时候注意flattenMap的使用。</strong></p><h2 id="2-信号过滤：filter、ignore、-distinctUntilChanged"><a href="#2-信号过滤：filter、ignore、-distinctUntilChanged" class="headerlink" title="2.信号过滤：filter、ignore、 distinctUntilChanged"></a>2.信号过滤：filter、ignore、 distinctUntilChanged</h2><h3 id="2-1、filter"><a href="#2-1、filter" class="headerlink" title="2.1、filter"></a>2.1、filter</h3><p>过滤信号，符合条件的信号才能发出消息。<br>示例：输入1234，当输入到4(文本长度大于3)的时候才开始打印如下的信息</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="keyword">self</span>.txtField.rac_textSignal filter:^<span class="type">BOOL</span>(<span class="built_in">NSString</span> * _Nullable value) &#123;</span><br><span class="line">    <span class="keyword">return</span> value.length &gt; <span class="number">3</span>;</span><br><span class="line">    &#125;] subscribeNext:^(<span class="built_in">NSString</span> * _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;打印x：%@&quot;</span>,x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">控制台打印：</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">11</span>:<span class="number">39</span>:<span class="number">23.371432</span>+<span class="number">0800</span> ZSTest[<span class="number">1428</span>:<span class="number">68939</span>] 打印x：<span class="number">1234</span></span><br></pre></td></tr></table></figure><h3 id="2-2、ignore"><a href="#2-2、ignore" class="headerlink" title="2.2、ignore"></a>2.2、ignore</h3><p>忽略信号，针对信号值的某一种状态进行忽略，忽略时不会发送消息。<br>示例：监听每次的输入，但是当文本框内的内容是”a”时不会打印</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="keyword">self</span>.txtField.rac_textSignal ignore:<span class="string">@&quot;a&quot;</span>] subscribeNext:^(<span class="built_in">NSString</span> * _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;ignore测试打印：%@&quot;</span>,x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h3 id="2-3、distinctUntilChanged"><a href="#2-3、distinctUntilChanged" class="headerlink" title="2.3、distinctUntilChanged"></a>2.3、distinctUntilChanged</h3><p>当上次的值与当前值有变化时才会发出消息，否则信息被忽略</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为了方便测试，我们监测控制器的currentText属性来修改Label的文本值。</span></span><br><span class="line">__<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>)weakSelf = <span class="keyword">self</span>;</span><br><span class="line">[[RACObserve(<span class="keyword">self</span>, currentText) distinctUntilChanged] subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;使用%@更新testLabel的值&quot;</span>,x);</span><br><span class="line">    weakSelf.testLabel.text = x;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">//currentTxt未被赋初值，所以第一次打印null,我们自己修改三次值，只打印两次</span></span><br><span class="line"><span class="keyword">self</span>.currentText = <span class="string">@&quot;hello&quot;</span>;</span><br><span class="line"><span class="keyword">self</span>.currentText = <span class="string">@&quot;world&quot;</span>;</span><br><span class="line"><span class="keyword">self</span>.currentText = <span class="string">@&quot;world&quot;</span>;</span><br><span class="line"></span><br><span class="line">控制台打印:</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">16</span>:<span class="number">43</span>:<span class="number">54.617385</span>+<span class="number">0800</span> ZSTest[<span class="number">3598</span>:<span class="number">220992</span>] 使用(null)更新testLabel的值</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">16</span>:<span class="number">43</span>:<span class="number">54.618026</span>+<span class="number">0800</span> ZSTest[<span class="number">3598</span>:<span class="number">220992</span>] 使用hello更新testLabel的值</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">16</span>:<span class="number">43</span>:<span class="number">54.618380</span>+<span class="number">0800</span> ZSTest[<span class="number">3598</span>:<span class="number">220992</span>] 使用world更新testLabel的值 </span><br></pre></td></tr></table></figure><h2 id="3-信号合并：combineLatest、reduce、merge、zipWith"><a href="#3-信号合并：combineLatest、reduce、merge、zipWith" class="headerlink" title="3.信号合并：combineLatest、reduce、merge、zipWith"></a>3.信号合并：combineLatest、reduce、merge、zipWith</h2><p>为了便于测试，这里先创建两个RACSubject类型的信号用于测试，此类信号只有发送信号sendNext方法执行时，订阅者才会执行nextBlock里的内容;</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">RACSubject *signalOne = [RACSubject subject];</span><br><span class="line">[signalOne subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;订阅信号one：%@&quot;</span>,x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">RACSubject *signalTwo = [RACSubject subject];</span><br><span class="line">[signalTwo subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;订阅信号Two：%@&quot;</span>,x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h3 id="3-1、combineLatest：合并信号"><a href="#3-1、combineLatest：合并信号" class="headerlink" title="3.1、combineLatest：合并信号"></a>3.1、combineLatest：合并信号</h3><p>合并信号的效果就是，这多个信号都至少有过一次订阅信号sendNext的操作，才会触发合并的信号。下面的测试如果只有signalOne执行sendNext方法，那么combineLatest后的信号不会被触发。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[[RACSignal combineLatest:@[signalOne,signalTwo]] subscribeNext:^(RACTuple * _Nullable x) &#123;</span><br><span class="line">    <span class="comment">//解元组：合并信号得到的是一个元组,里面存放的是两个信号发送的消息</span></span><br><span class="line">    RACTupleUnpack(<span class="built_in">NSString</span> *str1,<span class="built_in">NSString</span> *str2) = x;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;combineLatest:str1-%@,str2-%@&quot;</span>,str1,str2);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[signalOne sendNext:<span class="string">@&quot;1&quot;</span>];</span><br><span class="line">[signalTwo sendNext:<span class="string">@&quot;2”];</span></span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">控制台打印：</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">14</span>:<span class="number">29</span>:<span class="number">53.198724</span>+<span class="number">0800</span> ZSTest[<span class="number">2172</span>:<span class="number">143774</span>] 订阅信号one：<span class="number">1</span></span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">14</span>:<span class="number">29</span>:<span class="number">53.199673</span>+<span class="number">0800</span> ZSTest[<span class="number">2172</span>:<span class="number">143774</span>] 订阅信号Two：<span class="number">2</span></span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">14</span>:<span class="number">29</span>:<span class="number">53.200075</span>+<span class="number">0800</span> ZSTest[<span class="number">2172</span>:<span class="number">143774</span>] combineLatest:&lt;RACTuple: <span class="number">0x60000000d9a0</span>&gt; (</span><br><span class="line">    <span class="number">1</span>,</span><br><span class="line">    <span class="number">2</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="3-2、reduce：聚合信号"><a href="#3-2、reduce：聚合信号" class="headerlink" title="3.2、reduce：聚合信号"></a>3.2、reduce：聚合信号</h3><p>combineLatest合并后的信号订阅后，得到的是一个元组(包含每个被合并信号的新值)。然而在开发中，我们往往需要检测多个信号合并后的效果(比如用户名和密码信号有效时，登录按钮才可以点击)，这里就用到了reduce来实现信号聚合。<br>reduce聚合操作中的block参数个数随合并信号的数量而定，有多少个信号被合并，blcok中的参数就有多少个。这些参数一一对应被合并的信号，是它们对应的新值。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[[RACSignal combineLatest:@[signalOne,signalTwo] reduce:^<span class="type">id</span>(<span class="built_in">NSString</span> *strOne,<span class="built_in">NSString</span> *strTwo)&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%@-%@&quot;</span>,strOne,strTwo];</span><br><span class="line">&#125;] subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;combineLatest-reduce：%@&quot;</span>,x);</span><br><span class="line">&#125;];</span><br><span class="line">[signalOne sendNext:<span class="string">@&quot;1&quot;</span>];</span><br><span class="line">[signalTwo sendNext:<span class="string">@&quot;2&quot;</span>];</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">控制台打印：</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">14</span>:<span class="number">40</span>:<span class="number">08.977580</span>+<span class="number">0800</span> ZSTest[<span class="number">2288</span>:<span class="number">149816</span>] 订阅信号one：<span class="number">1</span></span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">14</span>:<span class="number">40</span>:<span class="number">08.978566</span>+<span class="number">0800</span> ZSTest[<span class="number">2288</span>:<span class="number">149816</span>] 订阅信号Two：<span class="number">2</span></span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">14</span>:<span class="number">40</span>:<span class="number">08.979587</span>+<span class="number">0800</span> ZSTest[<span class="number">2288</span>:<span class="number">149816</span>] combineLatest-reduce：<span class="number">1</span><span class="number">-2</span></span><br></pre></td></tr></table></figure><h3 id="3-3、merge：合并信号"><a href="#3-3、merge：合并信号" class="headerlink" title="3.3、merge：合并信号"></a>3.3、merge：合并信号</h3><p>当合并后的信号被订阅时，就会订阅里面所有的信号<br>测试1：将多个信号合并之后，当其中任何一个信号发送消息时，都能被监测到。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *mergeSignal = [signalOne merge:signalTwo];</span><br><span class="line">[mergeSignal subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;mergeSignal：%@&quot;</span>,x);</span><br><span class="line">&#125;];</span><br><span class="line"><span class="comment">//只调用其中一个信号,就会触发merge合并的信号</span></span><br><span class="line">[signalOne sendNext:<span class="string">@&quot;测试信号1&quot;</span>];</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">控制台打印：</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">14</span>:<span class="number">53</span>:<span class="number">34.342899</span>+<span class="number">0800</span> ZSTest[<span class="number">2577</span>:<span class="number">160009</span>] 订阅信号one：测试信号<span class="number">1</span></span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">14</span>:<span class="number">53</span>:<span class="number">34.343124</span>+<span class="number">0800</span> ZSTest[<span class="number">2577</span>:<span class="number">160009</span>] mergeSignal：测试信号<span class="number">1</span></span><br></pre></td></tr></table></figure><p>测试2：当合并后的信号被订阅时，就会订阅里面所有的信号</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signal1 = [RACSignal createSignal:^RACDisposable *(<span class="type">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:<span class="string">@&quot;signal1&quot;</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">RACSignal *signal2 = [RACSignal createSignal:^RACDisposable *(<span class="type">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:<span class="string">@&quot;signal2&quot;</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">RACSignal *mergeSignals = [signal1 merge:signal2];</span><br><span class="line">    [mergeSignals subscribeNext:^(<span class="type">id</span> x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;mergeSignals：%@&quot;</span>,x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">控制台打印：</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">18</span>:<span class="number">10</span>:<span class="number">29.623099</span>+<span class="number">0800</span> ZSTest[<span class="number">4444</span>:<span class="number">270816</span>] mergeSignals：signal1</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">18</span>:<span class="number">10</span>:<span class="number">29.623721</span>+<span class="number">0800</span> ZSTest[<span class="number">4444</span>:<span class="number">270816</span>] mergeSignals：signal2</span><br></pre></td></tr></table></figure><h3 id="3-4、zipWith：压缩信号"><a href="#3-4、zipWith：压缩信号" class="headerlink" title="3.4、zipWith：压缩信号"></a>3.4、zipWith：压缩信号</h3><p>1.zipWith把两个信号压缩成为一个信号。<br>2.只有当两个信号同时发出信号时，两个信号的内容才会被合并为一个元组，触发压缩流的next事件。比如：当一个界面多个请求的时候，要等所有请求完成才更新UI。元组内元素顺序只与压缩信号的顺序有关，与发送信号的顺序无关。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *zipSignal = [signalOne zipWith:signalTwo];</span><br><span class="line">[zipSignal subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="comment">//解元组：合并信号得到的是一个元组,里面存放的是两个信号发送的消息</span></span><br><span class="line">    RACTupleUnpack(<span class="built_in">NSString</span> *str1,<span class="built_in">NSString</span> *str2) = x;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;zipSignal：str1-%@,str2-%@&quot;</span>,str1,str2);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[signalOne sendNext:<span class="string">@&quot;测试zipSignalMsgOne&quot;</span>];</span><br><span class="line">[signalTwo sendNext:<span class="string">@&quot;测试zipSignalMsgTwo&quot;</span>];</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">控制台打印：</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">15</span>:<span class="number">23</span>:<span class="number">58.989780</span>+<span class="number">0800</span> ZSTest[<span class="number">2926</span>:<span class="number">177798</span>] 订阅信号one：测试zipSignalMsgOne</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">15</span>:<span class="number">23</span>:<span class="number">58.990012</span>+<span class="number">0800</span> ZSTest[<span class="number">2926</span>:<span class="number">177798</span>] 订阅信号Two：测试zipSignalMsgTwo</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">15</span>:<span class="number">23</span>:<span class="number">58.991056</span>+<span class="number">0800</span> ZSTest[<span class="number">2926</span>:<span class="number">177798</span>] zipSignal：str1-测试zipSignalMsgOne,str2-测试zipSignalMsgTwo</span><br></pre></td></tr></table></figure><h2 id="4-信号拼接：concat、then"><a href="#4-信号拼接：concat、then" class="headerlink" title="4.信号拼接：concat、then"></a>4.信号拼接：concat、then</h2><h3 id="4-1、concat"><a href="#4-1、concat" class="headerlink" title="4.1、concat"></a>4.1、concat</h3><p>1.使用concat可以按序拼接多个信号，拼接后的信号按序执行。<br>2.使用concat连接信号后，每个信号无需再单独订阅，其内部会按序自动订阅<br>3.前面的信号必须执行sendCompleted，后面的信号才会被激活</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signalOne = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="type">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:<span class="string">@&quot;signalOne&quot;</span>];</span><br><span class="line">    [subscriber sendCompleted];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line">    </span><br><span class="line">RACSignal *signalTwo = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="type">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:<span class="string">@&quot;signalTwo&quot;</span>];</span><br><span class="line">    [subscriber sendCompleted];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">RACSignal *signalThree = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="type">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:<span class="string">@&quot;signalThree&quot;</span>];</span><br><span class="line">    [subscriber sendCompleted];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line">   </span><br><span class="line"><span class="comment">//拼接了三个信号，订阅之后，三个信号依次激活</span></span><br><span class="line">RACSignal *concatSignal = [[signalOne concat:signalThree] concat:signalTwo];</span><br><span class="line">[concatSignal subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;信号被激活:%@&quot;</span>,x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">控制台打印：</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-22</span> <span class="number">17</span>:<span class="number">36</span>:<span class="number">47.565105</span>+<span class="number">0800</span> ZSTest[<span class="number">6018</span>:<span class="number">274201</span>] 信号被激活:signalOne</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-22</span> <span class="number">17</span>:<span class="number">36</span>:<span class="number">47.565403</span>+<span class="number">0800</span> ZSTest[<span class="number">6018</span>:<span class="number">274201</span>] 信号被激活:signalThree</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-22</span> <span class="number">17</span>:<span class="number">36</span>:<span class="number">47.565609</span>+<span class="number">0800</span> ZSTest[<span class="number">6018</span>:<span class="number">274201</span>] 信号被激活:signalTwo</span><br></pre></td></tr></table></figure><h3 id="4-2、then-连接信号"><a href="#4-2、then-连接信号" class="headerlink" title="4.2、then:连接信号"></a>4.2、then:连接信号</h3><p>使用then连接信号，上一个信号完成后，才会连接then返回的信号，所以then连接的上一个信号必须使用sendCompleted，否则后续信号无法执行。<br><strong>then连接的多个信号与concat不同的是：之前的信号会被忽略掉，即订阅信号只会接收到最后一个信号的值</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[[[[RACSignal createSignal:^RACDisposable *(<span class="type">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;信号1&quot;</span>);</span><br><span class="line">        [subscriber sendNext:<span class="string">@&quot;发送信号1&quot;</span>];</span><br><span class="line">        [subscriber sendCompleted];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;] then:^RACSignal *&#123;</span><br><span class="line">        <span class="keyword">return</span> [RACSignal createSignal:^RACDisposable *(<span class="type">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;信号2&quot;</span>);</span><br><span class="line">            [subscriber sendNext:<span class="string">@&quot;发送信号2&quot;</span>];</span><br><span class="line">            [subscriber sendCompleted];</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;]then:^RACSignal * _Nonnull&#123;</span><br><span class="line">        <span class="keyword">return</span> [RACSignal createSignal:^RACDisposable *(<span class="type">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;信号3&quot;</span>);</span><br><span class="line">            [subscriber sendNext:<span class="string">@&quot;发送信号3&quot;</span>];</span><br><span class="line">            [subscriber sendCompleted];</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;] subscribeNext:^(<span class="type">id</span> x) &#123;</span><br><span class="line">        <span class="comment">//只能接收到最后一个信号的值</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;订阅信号：%@&quot;</span>,x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">控制台打印：</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">16</span>:<span class="number">53</span>:<span class="number">52.819003</span>+<span class="number">0800</span> ZSTest[<span class="number">3668</span>:<span class="number">227466</span>] 信号<span class="number">1</span></span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">16</span>:<span class="number">53</span>:<span class="number">52.819762</span>+<span class="number">0800</span> ZSTest[<span class="number">3668</span>:<span class="number">227466</span>] 信号<span class="number">2</span></span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">16</span>:<span class="number">53</span>:<span class="number">52.820008</span>+<span class="number">0800</span> ZSTest[<span class="number">3668</span>:<span class="number">227466</span>] 信号<span class="number">3</span></span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">16</span>:<span class="number">53</span>:<span class="number">52.820139</span>+<span class="number">0800</span> ZSTest[<span class="number">3668</span>:<span class="number">227466</span>] 订阅信号：发送信号<span class="number">3</span></span><br></pre></td></tr></table></figure><h2 id="5-信号操作时间：timeout、interval、dely"><a href="#5-信号操作时间：timeout、interval、dely" class="headerlink" title="5.信号操作时间：timeout、interval、dely"></a>5.信号操作时间：timeout、interval、dely</h2><h3 id="5-1、interval"><a href="#5-1、interval" class="headerlink" title="5.1、interval"></a>5.1、interval</h3><p>创建定时器信号，每固定时间发送一次信号</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *intervalSignal = [RACSignal interval:<span class="number">1</span> onScheduler:[RACScheduler currentScheduler]];</span><br><span class="line"></span><br><span class="line"><span class="comment">//只知道使用take结束定时器这一种方法，不知道还有没有其他方法</span></span><br><span class="line">[[intervalSignal take:<span class="number">5</span>]subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="comment">//订阅定时器信号，启动定时器，只打印5次</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;interval,定时器打印&quot;</span>);</span><br><span class="line">   &#125;];</span><br></pre></td></tr></table></figure><h3 id="5-2、timeout"><a href="#5-2、timeout" class="headerlink" title="5.2、timeout"></a>5.2、timeout</h3><p>可以设置超时操作，让一个信号在规定时间之后自动报错<br><strong>创建信号时不能使用sendCompleted，因为这样的话一旦发送了消息就取消订阅了。</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *timeOutSignal = [[RACSignal createSignal:^RACDisposable * _Nullable(<span class="type">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:<span class="string">@&quot;timeOutSignal发送信号&quot;</span>];</span><br><span class="line">    <span class="comment">//[subscriber sendCompleted];</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;] timeout:<span class="number">5</span> onScheduler:[RACScheduler currentScheduler]];</span><br><span class="line">   </span><br><span class="line">[timeOutSignal subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;timeOutSignal:%@&quot;</span>,x);</span><br><span class="line"> &#125; error:^(<span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">    <span class="comment">//5秒后执行打印：</span></span><br><span class="line">    <span class="comment">//timeOutSignal:出现Error-Error Domain=RACSignalErrorDomain Code=1 &quot;(null)&quot;</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;timeOutSignal:出现Error-%@&quot;</span>,error);</span><br><span class="line">&#125; completed:^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;timeOutSignal:complete&quot;</span>);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h3 id="5-3、delay"><a href="#5-3、delay" class="headerlink" title="5.3、delay"></a>5.3、delay</h3><p>延迟发送sendNext</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *delaySignal = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="type">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:<span class="string">@&quot;delaySignal-sendNext&quot;</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line">   </span><br><span class="line"><span class="comment">//10秒后才收到消息，执行打印</span></span><br><span class="line">[[delaySignal delay:<span class="number">10</span>] subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;delaySignal:%@&quot;</span>,x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h3 id="6-信号取值take、takeLast、takeUntil"><a href="#6-信号取值take、takeLast、takeUntil" class="headerlink" title="6.信号取值take、takeLast、takeUntil"></a>6.信号取值take、takeLast、takeUntil</h3><p>首先创建一个signal来测试这三个方法：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="type">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:<span class="string">@&quot;发送消息1&quot;</span>];</span><br><span class="line">    [subscriber sendNext:<span class="string">@&quot;发送消息2&quot;</span>];</span><br><span class="line">    [subscriber sendNext:<span class="string">@&quot;发送消息3&quot;</span>];</span><br><span class="line">    [subscriber sendNext:<span class="string">@&quot;发送消息4&quot;</span>];</span><br><span class="line">    [subscriber sendCompleted];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h3 id="6-1、take：从开始共取N次的next值"><a href="#6-1、take：从开始共取N次的next值" class="headerlink" title="6.1、take：从开始共取N次的next值"></a>6.1、take：从开始共取N次的next值</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[[signal take:<span class="number">2</span>] subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;订阅信号:%@&quot;</span>,x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">控制台打印：</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">17</span>:<span class="number">15</span>:<span class="number">09.865290</span>+<span class="number">0800</span> ZSTest[<span class="number">3835</span>:<span class="number">237999</span>] 订阅信号:发送消息<span class="number">1</span></span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">17</span>:<span class="number">15</span>:<span class="number">09.865617</span>+<span class="number">0800</span> ZSTest[<span class="number">3835</span>:<span class="number">237999</span>] 订阅信号:发送消息<span class="number">2</span> </span><br></pre></td></tr></table></figure><h3 id="6-2、takeLast：从最后共取值N次next的值"><a href="#6-2、takeLast：从最后共取值N次next的值" class="headerlink" title="6.2、takeLast：从最后共取值N次next的值"></a>6.2、takeLast：从最后共取值N次next的值</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[[signal takeLast:<span class="number">3</span>]subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;订阅信号：%@&quot;</span>,x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">控制台打印：</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">17</span>:<span class="number">19</span>:<span class="number">51.343909</span>+<span class="number">0800</span> ZSTest[<span class="number">3933</span>:<span class="number">241042</span>] 订阅信号：发送消息<span class="number">2</span></span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">17</span>:<span class="number">19</span>:<span class="number">51.344063</span>+<span class="number">0800</span> ZSTest[<span class="number">3933</span>:<span class="number">241042</span>] 订阅信号：发送消息<span class="number">3</span></span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">17</span>:<span class="number">19</span>:<span class="number">51.344177</span>+<span class="number">0800</span> ZSTest[<span class="number">3933</span>:<span class="number">241042</span>] 订阅信号：发送消息<span class="number">4</span> </span><br></pre></td></tr></table></figure><h3 id="6-3、takeUntil-RACSignal"><a href="#6-3、takeUntil-RACSignal" class="headerlink" title="6.3、takeUntil:(RACSignal *)"></a>6.3、takeUntil:(RACSignal *)</h3><p>使用RACSubject类型的信号来测试，直到某个信号执行完成  ,才获取信号</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">RACSubject *signalA = [RACSubject subject];</span><br><span class="line"></span><br><span class="line">[signalA subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;订阅信号A：%@&quot;</span>,x);</span><br><span class="line">&#125;];</span><br><span class="line">    </span><br><span class="line">__<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>)weakSelf = <span class="keyword">self</span>;</span><br><span class="line"><span class="comment">//[RACObserve(self, currentText)发送消息知道signalA信号结束</span></span><br><span class="line">[[RACObserve(<span class="keyword">self</span>, currentText) takeUntil:signalA] subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;使用%@更新testLabel的值&quot;</span>,x);</span><br><span class="line">    weakSelf.testLabel.text = x;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="keyword">self</span>.currentText = <span class="string">@&quot;0&quot;</span>;</span><br><span class="line"><span class="keyword">self</span>.currentText = <span class="string">@&quot;1&quot;</span>;</span><br><span class="line"><span class="keyword">self</span>.currentText = <span class="string">@&quot;2&quot;</span>;</span><br><span class="line">[signalA sendCompleted];<span class="comment">//信号A结束之后，监听testLabel文本的信号也不在发送消息了</span></span><br><span class="line"><span class="keyword">self</span>.currentText = <span class="string">@&quot;3&quot;</span>;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;代码执行到此行。。。。&quot;</span>);</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">控制台打印：</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">17</span>:<span class="number">31</span>:<span class="number">08.907925</span>+<span class="number">0800</span> ZSTest[<span class="number">4044</span>:<span class="number">247412</span>] 使用(null)更新testLabel的值</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">17</span>:<span class="number">31</span>:<span class="number">08.908531</span>+<span class="number">0800</span> ZSTest[<span class="number">4044</span>:<span class="number">247412</span>] 使用<span class="number">0</span>更新testLabel的值</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">17</span>:<span class="number">31</span>:<span class="number">08.908957</span>+<span class="number">0800</span> ZSTest[<span class="number">4044</span>:<span class="number">247412</span>] 使用<span class="number">1</span>更新testLabel的值</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">17</span>:<span class="number">31</span>:<span class="number">08.909194</span>+<span class="number">0800</span> ZSTest[<span class="number">4044</span>:<span class="number">247412</span>] 使用<span class="number">2</span>更新testLabel的值</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">17</span>:<span class="number">31</span>:<span class="number">08.909725</span>+<span class="number">0800</span> ZSTest[<span class="number">4044</span>:<span class="number">247412</span>] 代码执行到此行。。。。</span><br></pre></td></tr></table></figure><h2 id="7-信号跳过：skip"><a href="#7-信号跳过：skip" class="headerlink" title="7.信号跳过：skip"></a>7.信号跳过：skip</h2><p>使用skip跳过几个信号</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="type">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:<span class="string">@&quot;第一次发送消息&quot;</span>];</span><br><span class="line">    [subscriber sendNext:<span class="string">@&quot;第二次发送消息&quot;</span>];</span><br><span class="line">    [subscriber sendNext:<span class="string">@&quot;第三次发送消息&quot;</span>];</span><br><span class="line">    [subscriber sendNext:<span class="string">@&quot;第四次发送消息&quot;</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[[signal skip:<span class="number">2</span>] subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>,x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">控制台打印：</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">17</span>:<span class="number">48</span>:<span class="number">06.479104</span>+<span class="number">0800</span> ZSTest[<span class="number">4284</span>:<span class="number">259095</span>] 第三次发送消息</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">17</span>:<span class="number">48</span>:<span class="number">06.479376</span>+<span class="number">0800</span> ZSTest[<span class="number">4284</span>:<span class="number">259095</span>] 第四次发送消息</span><br></pre></td></tr></table></figure><h2 id="8-信号发送顺序：doNext、doCompleted"><a href="#8-信号发送顺序：doNext、doCompleted" class="headerlink" title="8.信号发送顺序：doNext、doCompleted"></a>8.信号发送顺序：doNext、doCompleted</h2><p>发送信号前与发送信号后操作：doNext、doCompleted<br><strong>doNext</strong>：在订阅者发送消息sendNext之前执行<br><strong>doCompleted</strong>：在订阅者发送完成sendCompleted之后执行</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="type">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:<span class="string">@&quot;发送信号：1&quot;</span>];</span><br><span class="line">    [subscriber sendCompleted];</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line">    </span><br><span class="line">[[[signal doNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@&quot;执行doNext&quot;</span>);</span><br><span class="line">&#125;] doCompleted:^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;执行doComplete&quot;</span>);</span><br><span class="line">&#125;] subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@&quot;订阅信号：%@&quot;</span>,x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">控制台打印：</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-28</span> <span class="number">11</span>:<span class="number">20</span>:<span class="number">42.881535</span>+<span class="number">0800</span> ZSTest[<span class="number">2656</span>:<span class="number">81106</span>] 执行doNext</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-28</span> <span class="number">11</span>:<span class="number">20</span>:<span class="number">42.881841</span>+<span class="number">0800</span> ZSTest[<span class="number">2656</span>:<span class="number">81106</span>] 订阅信号：发送信号：<span class="number">1</span></span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-28</span> <span class="number">11</span>:<span class="number">20</span>:<span class="number">42.882583</span>+<span class="number">0800</span> ZSTest[<span class="number">2656</span>:<span class="number">81106</span>] 执行doComplete</span><br></pre></td></tr></table></figure><h2 id="9-获取信号中的信号：switchToLatest"><a href="#9-获取信号中的信号：switchToLatest" class="headerlink" title="9.获取信号中的信号：switchToLatest"></a>9.获取信号中的信号：switchToLatest</h2><p>switchToLatest只能用于信号中的信号(否则崩溃)，获取最新发送的信号。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个普通信号</span></span><br><span class="line">RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="type">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:<span class="string">@&quot;发送信号：1&quot;</span>];</span><br><span class="line">    [subscriber sendCompleted];</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个发送信号的信号，信号的信号</span></span><br><span class="line">RACSignal *signalOfSignals = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="type">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:signal];</span><br><span class="line">    [subscriber sendCompleted];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line">    </span><br><span class="line"><span class="comment">//订阅最近发出的信号</span></span><br><span class="line">[signalOfSignals.switchToLatest subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="comment">//控制台打印：switchToLatest打印：发送信号：1</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;switchToLatest打印：%@&quot;</span>,x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>特别说明：<br><strong>可以看出switchToLatest和flattenMap的功能很相似，但是它们有一主要区别：</strong></p><h2 id="10-信号错误重试：retry"><a href="#10-信号错误重试：retry" class="headerlink" title="10.信号错误重试：retry"></a>10.信号错误重试：retry</h2><p>retry：只要失败就重新执行信号</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> signalANum = <span class="number">0</span>;</span><br><span class="line">RACSignal *signalA = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="type">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    <span class="keyword">if</span> (signalANum == <span class="number">5</span>) &#123;</span><br><span class="line">        [subscriber sendNext:<span class="string">@&quot;signalANum is 5&quot;</span>];</span><br><span class="line">        [subscriber sendCompleted];</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;signalANum错误！！!&quot;</span>);</span><br><span class="line">        [subscriber sendError:<span class="literal">nil</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    signalANum++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line">  </span><br><span class="line">[[signalA retry] subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;StringA-Next：%@&quot;</span>,x);</span><br><span class="line">&#125; error:^(<span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">    <span class="comment">//特别注意：这里并没有打印</span></span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@&quot;signalA-Errror&quot;</span>);</span><br><span class="line">&#125;] ;</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">控制台打印：</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-24</span> <span class="number">09</span>:<span class="number">46</span>:<span class="number">38.996888</span>+<span class="number">0800</span> ZSTest[<span class="number">818</span>:<span class="number">14322</span>] signalANum错误！！!</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-24</span> <span class="number">09</span>:<span class="number">46</span>:<span class="number">39.063427</span>+<span class="number">0800</span> ZSTest[<span class="number">818</span>:<span class="number">14322</span>] signalANum错误！！!</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-24</span> <span class="number">09</span>:<span class="number">46</span>:<span class="number">39.064203</span>+<span class="number">0800</span> ZSTest[<span class="number">818</span>:<span class="number">14322</span>] signalANum错误！！!</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-24</span> <span class="number">09</span>:<span class="number">46</span>:<span class="number">39.064567</span>+<span class="number">0800</span> ZSTest[<span class="number">818</span>:<span class="number">14322</span>] signalANum错误！！!</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-24</span> <span class="number">09</span>:<span class="number">46</span>:<span class="number">39.064819</span>+<span class="number">0800</span> ZSTest[<span class="number">818</span>:<span class="number">14322</span>] signalANum错误！！!</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-24</span> <span class="number">09</span>:<span class="number">46</span>:<span class="number">39.065199</span>+<span class="number">0800</span> ZSTest[<span class="number">818</span>:<span class="number">14322</span>] StringA-Next：signalANum is <span class="number">5</span></span><br></pre></td></tr></table></figure><h2 id="11-信号节流：throttle"><a href="#11-信号节流：throttle" class="headerlink" title="11.信号节流：throttle"></a>11.信号节流：throttle</h2><p>当某个信号发送比较频繁时，可以使用throttle节流，在某一段时间不发送信号内容，过了一段时间获取信号的最新内容发出。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[[[RACSignal createSignal:^RACDisposable * _Nullable(<span class="type">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:<span class="string">@&quot;发送消息11&quot;</span>];</span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">2</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            [subscriber sendNext:<span class="string">@&quot;发送消息21&quot;</span>];</span><br><span class="line">            [subscriber sendNext:<span class="string">@&quot;发送消息22&quot;</span>];</span><br><span class="line">    &#125;);</span><br><span class="line">        </span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">3</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            [subscriber sendNext:<span class="string">@&quot;发送消息31&quot;</span>];</span><br><span class="line">            [subscriber sendNext:<span class="string">@&quot;发送消息32&quot;</span>];</span><br><span class="line">            [subscriber sendNext:<span class="string">@&quot;发送消息33&quot;</span>];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">4</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            [subscriber sendNext:<span class="string">@&quot;发送消息41&quot;</span>];</span><br><span class="line">            [subscriber sendNext:<span class="string">@&quot;发送消息42&quot;</span>];</span><br><span class="line">            [subscriber sendNext:<span class="string">@&quot;发送消息43&quot;</span>];</span><br><span class="line">            [subscriber sendNext:<span class="string">@&quot;发送消息44&quot;</span>];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;    </span><br><span class="line">&#125;] throttle:<span class="number">2</span>] subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;Next:%@&quot;</span>,x);</span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">控制台打印：</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-24</span> <span class="number">11</span>:<span class="number">05</span>:<span class="number">48.411464</span>+<span class="number">0800</span> ZSTest[<span class="number">2063</span>:<span class="number">62521</span>] Next:发送消息<span class="number">11</span></span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-24</span> <span class="number">11</span>:<span class="number">05</span>:<span class="number">52.426162</span>+<span class="number">0800</span> ZSTest[<span class="number">2063</span>:<span class="number">62521</span>] Next:发送消息<span class="number">44</span></span><br></pre></td></tr></table></figure><h2 id="12-信号关于线程的操作"><a href="#12-信号关于线程的操作" class="headerlink" title="12.信号关于线程的操作"></a>12.信号关于线程的操作</h2><p><strong>副作用</strong>：关于信号与线程,我们把在创建信号时block中的代码称之为副作用。<br><strong>deliverON</strong>：切换到指定线程中，可用于回到主线中刷新UI,内容传递切换到指定线程中，<br><strong>subscribeOn</strong>：内容传递和副作用都会切换到指定线程中。<br><strong>deliverOnMainThread</strong>：能保证原信号subscribeNext，sendError，sendCompleted都在主线程MainThread中执行。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试1：系统并行队列中异步执行,未使用deliverON切换线程</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">        [[RACSignal createSignal:^RACDisposable * _Nullable(<span class="type">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">            [subscriber sendNext:<span class="string">@&quot;测试1-endNext&quot;</span>];</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;测试1-当前线程：%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">        &#125;] subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;测试1-Next:%@&quot;</span>,x);</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;测试1-Next当前线程：%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;) ;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//测试2：系统并行队列中异步执行,使用deliverON切换线程</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">        [[[RACSignal createSignal:^RACDisposable * _Nullable(<span class="type">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">            [subscriber sendNext:<span class="string">@&quot;测试2-endNext&quot;</span>];</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;测试2-当前线程：%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">        &#125;] deliverOn:[RACScheduler mainThreadScheduler]] subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;测试2-Next:%@&quot;</span>,x);</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;测试2-Next当前线程：%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;) ;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//测试3：系统并行队列中异步执行,使用subscribeOn切换线程</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">        [[[RACSignal createSignal:^RACDisposable * _Nullable(<span class="type">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">            [subscriber sendNext:<span class="string">@&quot;测试3-sendNext&quot;</span>];</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;测试3-sendNext当前线程：%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">        &#125;] subscribeOn:[RACScheduler mainThreadScheduler]] subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;测试3-Next:%@&quot;</span>,x);</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;测试3-Next当前线程：%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;) ;</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">控制台打印：</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-24</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">48.025872</span>+<span class="number">0800</span> ZSTest[<span class="number">2624</span>:<span class="number">109537</span>] 测试<span class="number">1</span>-Next:测试<span class="number">1</span>-endNext</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-24</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">48.026152</span>+<span class="number">0800</span> ZSTest[<span class="number">2624</span>:<span class="number">109537</span>] 测试<span class="number">1</span>-Next当前线程：&lt;<span class="built_in">NSThread</span>: <span class="number">0x60400046e640</span>&gt;&#123;number = <span class="number">5</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-24</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">48.026746</span>+<span class="number">0800</span> ZSTest[<span class="number">2624</span>:<span class="number">109537</span>] 测试<span class="number">1</span>-sendNext当前线程：&lt;<span class="built_in">NSThread</span>: <span class="number">0x60400046e640</span>&gt;&#123;number = <span class="number">5</span>, name = (null)&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-24</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">48.027784</span>+<span class="number">0800</span> ZSTest[<span class="number">2624</span>:<span class="number">109537</span>] 测试<span class="number">2</span>-sendNext当前线程：&lt;<span class="built_in">NSThread</span>: <span class="number">0x60400046e640</span>&gt;&#123;number = <span class="number">5</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-24</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">48.073294</span>+<span class="number">0800</span> ZSTest[<span class="number">2624</span>:<span class="number">109360</span>] 测试<span class="number">2</span>-Next:测试<span class="number">2</span>-sendNext</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-24</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">48.073890</span>+<span class="number">0800</span> ZSTest[<span class="number">2624</span>:<span class="number">109360</span>] 测试<span class="number">2</span>-Next当前线程：&lt;<span class="built_in">NSThread</span>: <span class="number">0x60400006a280</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-24</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">48.074181</span>+<span class="number">0800</span> ZSTest[<span class="number">2624</span>:<span class="number">109360</span>] 测试<span class="number">3</span>-Next:测试<span class="number">3</span>-sendNext</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-24</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">48.074511</span>+<span class="number">0800</span> ZSTest[<span class="number">2624</span>:<span class="number">109360</span>] 测试<span class="number">3</span>-Next当前线程：&lt;<span class="built_in">NSThread</span>: <span class="number">0x60400006a280</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-24</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">48.074646</span>+<span class="number">0800</span> ZSTest[<span class="number">2624</span>:<span class="number">109360</span>] 测试<span class="number">3</span>-sendNext当前线程：&lt;<span class="built_in">NSThread</span>: <span class="number">0x60400006a280</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br></pre></td></tr></table></figure><p>分析：<br><strong>测试1：未切换线程，发送消息与接收消息都在异步线程中</strong><br><strong>测试2：使用deliverON，发送消息还在原来的线程，但是接收消息切换到主线程。</strong><br><strong>测试2：使用subscribeON，发送消息和接收消息都被切换到了主线程中执行。</strong></p><h1 id="四、RAC常用的处理事件响应的方法"><a href="#四、RAC常用的处理事件响应的方法" class="headerlink" title="四、RAC常用的处理事件响应的方法"></a>四、RAC常用的处理事件响应的方法</h1><h2 id="1-代替代理的使用"><a href="#1-代替代理的使用" class="headerlink" title="1.代替代理的使用"></a>1.代替代理的使用</h2><p>基础篇里已经有一种使用RACSubject替换代理的方法，这里是另一种形式的替换。在视图控制中添加自定义视图CustomView，其上有一按钮testBtn添加了响应方法testBtnClick:。此时可以使用RAC在不使用代理的情况下，在视图控制中监听自定义视图中按钮的点击:<br><strong>关键方法：rac_signalForSelector</strong><br>使用说明：<br>1.通过rac_signalForSelector方法，以按钮响应方法为参数，得到一个信号。<br>2.订阅信号，在按钮点击时会发出信号。经过测试，即使testBtnClick方法没有在自定义视图的.h文件中声明，执行也是正常的。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[_customView  rac_signalForSelector:<span class="keyword">@selector</span>(testBtnClick:)] subscribeNext:^(RACTuple * _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;testBtn点击了。。。&quot;</span>);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h2 id="2-代替按钮等控制视图的响应事件"><a href="#2-代替按钮等控制视图的响应事件" class="headerlink" title="2.代替按钮等控制视图的响应事件"></a>2.代替按钮等控制视图的响应事件</h2><p>创建一个类似按钮的响应控件，我们可以不必再为其添加响应方法。使用RAC可以将按钮点击事件转化为信号，点击按钮会发送信号，执行订阅方法。<br><strong>关键方法：rac_signalForControlEvents</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[testBtn rac_signalForControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>] subscribeNext:^(__kindof <span class="built_in">UIControl</span> * _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;testBtn点击了。。。&quot;</span>);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h2 id="3-代替KVO，监听对象属性变化"><a href="#3-代替KVO，监听对象属性变化" class="headerlink" title="3.代替KVO，监听对象属性变化"></a>3.代替KVO，监听对象属性变化</h2><p><strong>关键方法：rac_valuesAndChangesForKeyPath</strong><br>使用说明：<br>1.自定义视图_customView属性frame的变化被转化信号，frame发生变化的时候，会发送信号。<br>2.observer可以为nil,但是会报警告。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[[_customView rac_valuesAndChangesForKeyPath:<span class="string">@&quot;frame&quot;</span> options:<span class="built_in">NSKeyValueObservingOptionNew</span> observer: <span class="literal">nil</span>] subscribeNext:^(<span class="type">id</span> x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;CustomView的Frame值变化了：%@&quot;</span>,x);</span><br><span class="line">&#125;];</span><br><span class="line">_customView.frame = <span class="built_in">CGRectZero</span>;</span><br></pre></td></tr></table></figure><h2 id="4-监听文本输入变化"><a href="#4-监听文本输入变化" class="headerlink" title="4.监听文本输入变化"></a>4.监听文本输入变化</h2><p><strong>关键方法：rac_textSignal</strong><br>UITextField与UITextView输入视图内容的变化，我们也可以采用RAC的方法来监听</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[_testTxtView rac_textSignal] subscribeNext:^(<span class="built_in">NSString</span> * _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;当前文本输入内容：%@&quot;</span>,x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h2 id="5-代替通知的使用"><a href="#5-代替通知的使用" class="headerlink" title="5.代替通知的使用"></a>5.代替通知的使用</h2><p><strong>关键方法：rac_addObserverForName</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//步骤1： 添加通知</span></span><br><span class="line">[[[<span class="built_in">NSNotificationCenter</span> defaultCenter] rac_addObserverForName:<span class="string">@&quot;SecondVCNotificaitonName&quot;</span> object:<span class="literal">nil</span>] subscribeNext:^(<span class="built_in">NSNotification</span> * _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSDictionary</span> *objectDic = (<span class="built_in">NSDictionary</span> *)x.object;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;获取到通知里的文本：%@&quot;</span>,objectDic[<span class="string">@&quot;text&quot;</span>]);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">//步骤2：发起通知</span></span><br><span class="line"><span class="comment">//SecondVC中点击按钮，将输入框中的文本封装成字典，将其作为参数发起通知</span></span><br><span class="line">- (<span class="keyword">IBAction</span>)completeBtnClick:(<span class="type">id</span>)sender &#123;</span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:<span class="string">@&quot;SecondVCNotificaitonName&quot;</span> object:@&#123;<span class="string">@&quot;text&quot;</span>:<span class="keyword">self</span>.txtField.text&#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-多请求汇总处理"><a href="#6-多请求汇总处理" class="headerlink" title="6.多请求汇总处理"></a>6.多请求汇总处理</h2><p><strong>关键方法：rac_liftSelector：withSignals：</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下载任务1</span></span><br><span class="line">RACSignal *downLoad1 = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="type">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:@&#123;<span class="string">@&quot;data2&quot;</span>:<span class="string">@&quot;value1&quot;</span>&#125;];</span><br><span class="line">    [subscriber sendCompleted];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">//下载任务2</span></span><br><span class="line">RACSignal *downLoad2  = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="type">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:@&#123;<span class="string">@&quot;data2&quot;</span>:<span class="string">@&quot;value2&quot;</span>&#125;];</span><br><span class="line">    [subscriber sendCompleted];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line">    </span><br><span class="line"><span class="comment">//多信号对应多参数，注意顺序与格式</span></span><br><span class="line">[<span class="keyword">self</span> rac_liftSelector:<span class="keyword">@selector</span>(handleAllTasksWithT1:withT2:) withSignals:downLoad1,downLoad2, <span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//集中处理所有的请求</span></span><br><span class="line">- (<span class="type">void</span>)handleAllTasksWithT1:(<span class="type">id</span>)data1 withT2:(<span class="type">id</span>)data2&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;下载任务全部完成：%@，%@&quot;</span>,data1,data2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="五、本篇总结"><a href="#五、本篇总结" class="headerlink" title="五、本篇总结"></a>五、本篇总结</h1><p>写到这里，其实RAC还是有好多东西没有在这里涉及，本篇也只是对于它最常用的部分进行了归纳总结，尤其是我对于RAC在MVVM架构中的使用还不太熟练。RAC的学习，这仅仅是一个开始，继续努力吧！</p><p>参考链接：<br>1.<a href="http://ios.jobbole.com/86357/">RAC核心元素与信号流</a><br>2.<a href="https://www.jianshu.com/p/a4fefb434652">iOS常用API整理</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;使用RAC其实就是一个创建信号订阅信号的过程。上篇&lt;a href=&quot;https://www.jianshu.com/p/ba90d649ecb8&quot;&gt;ReactiveCocoa函数响应式编程-基础篇&lt;/a&gt;，主要简单介绍了RAC的信号机制，本篇则以信号为核心，就信号常用的类、操作信号的方法，替换响应处理等方面总结RAC的使用。&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="https://wuyubeichen.github.io/categories/iOS/"/>
    
    
    <category term="移动开发" scheme="https://wuyubeichen.github.io/tags/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
    
    <category term="iOS" scheme="https://wuyubeichen.github.io/tags/iOS/"/>
    
    <category term="Reactive" scheme="https://wuyubeichen.github.io/tags/Reactive/"/>
    
  </entry>
  
  <entry>
    <title>ReactiveCocoa函数响应式编程-基础篇</title>
    <link href="https://wuyubeichen.github.io/2018/04/03/ReactiveCocoa%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
    <id>https://wuyubeichen.github.io/2018/04/03/ReactiveCocoa%E5%9F%BA%E7%A1%80%E7%AF%87/</id>
    <published>2018-04-03T06:34:57.000Z</published>
    <updated>2022-08-18T06:43:25.108Z</updated>
    
    <content type="html"><![CDATA[<p><code>ReactiveCocoa</code>(简称<code>RAC</code>)，<code>Reactive</code>表示响应式，<code>Cocoa</code>是苹果整个框架的简称，许多苹果框架都以<code>Cocoa</code>结尾。所以<code>RAC</code>是<code>Github</code>上为我们提供函数响应式编程方法的<code>iOS</code>开发框架。</p><span id="more"></span><p><strong>主要内容：</strong></p><ol><li>了解函数响应式编程</li><li>ReactiveCocoa简介</li><li>ReactiveCocoa集成</li><li>理解什么是信号</li><li>从源码理解RAC的信号机制</li><li>本篇总结</li></ol><h1 id="一、了解函数响应式编程"><a href="#一、了解函数响应式编程" class="headerlink" title="一、了解函数响应式编程"></a>一、了解函数响应式编程</h1><p><img src="https://upload-images.jianshu.io/upload_images/1244124-613e9c9d4106f91b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><strong>函数式编程(Funcational Programming)</strong><br>使用高阶函数编程，即函数可采用多种函数作为它们的参数和返回值。</p><p><strong>响应式编程(Reactive Programming)</strong><br>一种面向数据流和变化传播的编程范式</p><p><strong>函数响应式编程(Funcational Reacitve Programming)</strong><br>简称FRP，ReactiveCocoa就是一个典型的FRP框架，响应式的编程思想，函数式的代码形式。</p><h1 id="二、ReactiveCocoa简介"><a href="#二、ReactiveCocoa简介" class="headerlink" title="二、ReactiveCocoa简介"></a>二、ReactiveCocoa简介</h1><p>iOS开发中，我们需要使用按钮点击、代理、通知等这些方法来处理响应事件。而RAC框架使用Category为很多基本的UIKit控件添加信号Signal，这样我们可以通过信号来监听数据流与变化传播，把将监听的代码与处理代码放在一起，从而方便我们管理。利用此特点结合MVVM架构，RAC也有十分显著的作用。</p><h1 id="三、ReactiveCocoa集成"><a href="#三、ReactiveCocoa集成" class="headerlink" title="三、ReactiveCocoa集成"></a>三、ReactiveCocoa集成</h1><p>RAC.5.0相对于之前版本对于自身项目结构进行了较大调整，被拆分ReactiveCocoa、ReactiveSwift、ReactiveObjC、ReactiveObjCBridge四个库，我们需要根据不同的情况来集成。<br><a href="https://github.com/ReactiveCocoa/ReactiveCocoa">GitHub地址：https://github.com/ReactiveCocoa/ReactiveCocoa</a><br>通常，我们都使用Cocoapods集成RAC，**需要注意的是Podfile文件中必须使用user_framework!**，然后，针对于不同的代码环境，有三种集成情况：</p><h2 id="1-纯OC工程"><a href="#1-纯OC工程" class="headerlink" title="1.纯OC工程"></a>1.纯OC工程</h2><p>ReactiveObjc库包含原RAC2的全部代码，在纯OC工程中使用</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">platform :ios, <span class="string">&#x27;8.0&#x27;</span></span><br><span class="line">use_frameworks!     #必须添加</span><br><span class="line">target <span class="string">&#x27;ZSTest&#x27;</span> <span class="keyword">do</span>  #工程名</span><br><span class="line"><span class="meta">#pod &#x27;ReactiveObjC&#x27; #默认导入最新的RAC版本         </span></span><br><span class="line">end</span><br></pre></td></tr></table></figure><h2 id="2-纯Swift工程"><a href="#2-纯Swift工程" class="headerlink" title="2.纯Swift工程"></a>2.纯Swift工程</h2><p>纯Swfit工程继续使用ReactiveCocoa，但RAC依赖ReactiveSwift，所以相当于引入两个库。<br>集成方法同上，只不过将ReactiveObjc换成ReactiveCocoa。</p><h2 id="3-OC与Swift混编工程"><a href="#3-OC与Swift混编工程" class="headerlink" title="3.OC与Swift混编工程"></a>3.OC与Swift混编工程</h2><p>混编工程需要同时引入ReactiveCocoa与ReactiveObjCBridge，但是ReactiveObjCBridge库依赖于ReactiveObjc库，所以相当于同时引入四个库了。示例如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">platform :ios, <span class="string">&#x27;8.0&#x27;</span></span><br><span class="line">use_frameworks!     #必须添加</span><br><span class="line">target <span class="string">&#x27;ZSTest&#x27;</span> <span class="keyword">do</span>  #工程名</span><br><span class="line">pod <span class="string">&#x27;ReactiveCocoa&#x27;</span></span><br><span class="line">pod <span class="string">&#x27;ReactiveObjC&#x27;</span>  </span><br><span class="line">pod <span class="string">&#x27;ReactiveObjCBridge&#x27;</span></span><br><span class="line">end</span><br></pre></td></tr></table></figure><h1 id="四、ReactiveCocoa信号理解"><a href="#四、ReactiveCocoa信号理解" class="headerlink" title="四、ReactiveCocoa信号理解"></a>四、ReactiveCocoa信号理解</h1><p>我觉得学习RAC的第一个关口就是理解信号RACSignal了，什么是信号也许是困惑我们的第一个问题。</p><p>作为RAC中最为核心的一个类，<strong>信号可以理解为传递数据变化信息的工具</strong>，信号会在数据发生变化时发送事件流给它的订阅者，然后订阅者执行响应方法。信号本身不具备发送信号的能力，而是交给一个订阅者去发出。</p><p>首先上一段代码，演示信号的一个基本使用。<br>测试场景：我们要对一个用于输入用户名的UITextFiled进行检测，每次输入内容变化的时候都打出输入框的内容，使用RAC来实现此操作的关键代码如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span>.userNameTxtField.rac_textSignal subscribeNext:^(<span class="built_in">NSString</span> * _Nullable x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;测试：%@&quot;</span>,x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">控制台打印：</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">17</span>:<span class="number">57</span>:<span class="number">00.497956</span>+<span class="number">0800</span> ZSTest[<span class="number">4351</span>:<span class="number">263810</span>] 测试：<span class="number">1</span></span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">17</span>:<span class="number">57</span>:<span class="number">00.498237</span>+<span class="number">0800</span> ZSTest[<span class="number">4351</span>:<span class="number">263810</span>] 测试：<span class="number">12</span></span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">17</span>:<span class="number">57</span>:<span class="number">00.498375</span>+<span class="number">0800</span> ZSTest[<span class="number">4351</span>:<span class="number">263810</span>] 测试：<span class="number">123</span></span><br></pre></td></tr></table></figure><p>没错的，不使用代理方法，也没有action的响应处理，我们仅仅使用了一行方法就实现了对文本框输入内容的实时打印。由此，RAC的实用性可见一斑。</p><h1 id="五、ReactiveCocoa信号机制"><a href="#五、ReactiveCocoa信号机制" class="headerlink" title="五、ReactiveCocoa信号机制"></a>五、ReactiveCocoa信号机制</h1><p>我们会对上面的代码产生疑问，RAC是怎么做到上述代码功能的呢？而且我们常说的订阅者又在哪里呢？</p><p>其实RAC已经使用Category的形式为我们基本的UI控件创建了信号(<strong>如上例中的rac_textSignal</strong>)，所以这里我们才可以很方便的实现信号订阅，而且订阅者在整个过程中也是对于我们隐藏的。 现在我们使用自定义信号的方法，从创建信号到订阅信号细致的了解一下这个过程。首先上一段创建信号的测试代码如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建信号</span></span><br><span class="line">RACSignal *testSignal = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="type">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    <span class="comment">//1.订阅者发送信号内容</span></span><br><span class="line">    [subscriber sendNext:<span class="string">@&quot;发送信号内容&quot;</span>];</span><br><span class="line">    <span class="comment">//2.订阅者发送信号完成的信息，不需要再发送数据时，最好发送信号完成，可以内部调起清理信号的操作。</span></span><br><span class="line">    [subscriber sendCompleted];</span><br><span class="line">    <span class="comment">//3.创建信号的Block参数，需要返回一个RACDisposable对象 ，可以返回nil。</span></span><br><span class="line">    <span class="comment">//RACDisposable对象用于取消订阅信号，此block在信号完成或者错误时调用。</span></span><br><span class="line">    RACDisposable *racDisposable = [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">       <span class="built_in">NSLog</span>(<span class="string">@&quot;信号Error或者Complete时销毁&quot;</span>);</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="keyword">return</span> racDisposable;</span><br><span class="line">&#125;];</span><br><span class="line">    </span><br><span class="line"><span class="comment">//订阅信号</span></span><br><span class="line">[testSignal subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="comment">//新变化的值</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;订阅信号：subscribeNext:%@&quot;</span>,x);</span><br><span class="line">&#125; error:^(<span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">    <span class="comment">//信号错误，被取消订阅,被移除观察</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;订阅信号：Error:%@&quot;</span>,error.description);</span><br><span class="line">&#125; completed:^&#123;</span><br><span class="line">    <span class="comment">//信号已经完成，被取消订阅，被移除观察</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;订阅信号：subscribeComplete&quot;</span>);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">控制台打印:</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">17</span>:<span class="number">57</span>:<span class="number">00.497956</span>+<span class="number">0800</span> ZSTest[<span class="number">4351</span>:<span class="number">263810</span>] 订阅信号：subscribeNext:发送信号内容</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">17</span>:<span class="number">57</span>:<span class="number">00.498237</span>+<span class="number">0800</span> ZSTest[<span class="number">4351</span>:<span class="number">263810</span>] 订阅信号：subscribeComplete</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">17</span>:<span class="number">57</span>:<span class="number">00.498375</span>+<span class="number">0800</span> ZSTest[<span class="number">4351</span>:<span class="number">263810</span>] 信号Error或者Complete时销毁</span><br></pre></td></tr></table></figure><p>我们通过观察源码来理解整个过程:</p><h2 id="1-创建信号"><a href="#1-创建信号" class="headerlink" title="1.创建信号"></a>1.创建信号</h2><p>创建信号，我们需要使用RACSignal的类方法createSignal。该方法需要一个Block作为参数。查看源码，我们就会发现RACSignal最终是通过调用自己子类RACDynamicSignal的createSignal方法，将这个Block设置给了自己的didSubscribe属性的。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RACSignal.m文件</span></span><br><span class="line">+ (RACSignal *)createSignal:(RACDisposable * (^)(<span class="type">id</span>&lt;RACSubscriber&gt; subscriber))didSubscribe &#123;</span><br><span class="line"> <span class="keyword">return</span> [RACDynamicSignal createSignal:didSubscribe];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RACDynamicSignal.h文件</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RACDynamicSignal</span> ()</span></span><br><span class="line"><span class="comment">// The block to invoke for each subscriber.</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readonly</span>) RACDisposable * (^didSubscribe)(<span class="type">id</span>&lt;RACSubscriber&gt; subscriber);</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RACDynamicSignal.m文件</span></span><br><span class="line">+ (RACSignal *)createSignal:(RACDisposable * (^)(<span class="type">id</span>&lt;RACSubscriber&gt; subscriber))didSubscribe &#123;</span><br><span class="line"> RACDynamicSignal *signal = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line"> signal-&gt;_didSubscribe = [didSubscribe <span class="keyword">copy</span>];</span><br><span class="line"> <span class="keyword">return</span> [signal setNameWithFormat:<span class="string">@&quot;+createSignal:&quot;</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>didSubscribe</strong>：这是创建信号时候需要传入的一个block，它的传入参数是订阅者subscriber，而返回值是需要是一个RACDisposable对象。创建信号后的didSubscrib是一个等待执行的block。</p><p><strong>RACSubscriber</strong>：表示订阅者，创建信号时订阅者发送信号，这里的订阅者是一个协议而非一个类。信号需要订阅者帮助其发送数据。查看RACSubscriber的协议，我可以看到以下几个方法：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发送信息</span></span><br><span class="line">- (<span class="type">void</span>)sendNext:(<span class="keyword">nullable</span> <span class="type">id</span>)value;</span><br><span class="line"><span class="comment">//发送错误消息</span></span><br><span class="line">- (<span class="type">void</span>)sendError:(<span class="keyword">nullable</span> <span class="built_in">NSError</span> *)error;</span><br><span class="line"><span class="comment">//发送完成信息</span></span><br><span class="line">- (<span class="type">void</span>)sendCompleted;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">- (<span class="type">void</span>)didSubscribeWithDisposable:(RACCompoundDisposable *)disposable;</span><br></pre></td></tr></table></figure><p>在创建一个信号的时候，订阅者使用sendNext发送信息。而且如果我们不再发送数据，最好在这里执行一次sendCompleted方法，这样的话，信号内部会自动调用对应的方法取消信号订阅。</p><p><strong>RACDisposable</strong>：这个类用于取消订阅信号和清理资源，在信号出现错误或者信号完成的时候，信号会自动调起RACDisposable对象的block方法。在代码中我们也可以看到，创建RACDisposable对象是使用disposableWithBlock方法设置了一个block操作，执行block操作之后，信号就不再被订阅了。</p><p><strong>总结：创建信号就是使用createSignal方法，创建一个信号，并为信号设置了一个didSubscribe属性(也就是一系列订阅者需要做的操作)。</strong></p><h2 id="2-订阅信号"><a href="#2-订阅信号" class="headerlink" title="2.订阅信号"></a>2.订阅信号</h2><p>进入订阅信号的源码我们看到如下代码：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (RACDisposable *)subscribeNext:(<span class="type">void</span> (^)(<span class="type">id</span> x))nextBlock error:(<span class="type">void</span> (^)(<span class="built_in">NSError</span> *error))errorBlock completed:(<span class="type">void</span> (^)(<span class="type">void</span>))completedBlock &#123;</span><br><span class="line"> <span class="built_in">NSCParameterAssert</span>(nextBlock != <span class="literal">NULL</span>);</span><br><span class="line"> <span class="built_in">NSCParameterAssert</span>(errorBlock != <span class="literal">NULL</span>);</span><br><span class="line"> <span class="built_in">NSCParameterAssert</span>(completedBlock != <span class="literal">NULL</span>);</span><br><span class="line"> </span><br><span class="line"> RACSubscriber *o = [RACSubscriber subscriberWithNext:nextBlock error:errorBlock completed:completedBlock];</span><br><span class="line"> <span class="keyword">return</span> [<span class="keyword">self</span> subscribe:o];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在此方法中，我们可以看到订阅信号有两个过程：<br><strong>过程1：使用subscribeNext的方法参数，创建出一个订阅者subscriber。</strong><br><strong>过程2：信号对象执行了订阅操作subscribe，方法中传入参数是刚创建的订阅者。</strong></p><p><strong>注：这也就解释了我们常提起却看不见的订阅者存在哪里的问题。真实开发中我们只关心订阅者需要发送的值就行了，而不需要关心其内部订阅的过程。</strong></p><p>继续打开信号的subscribe方法，看到源码如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (RACDisposable *)subscribe:(<span class="type">id</span>&lt;RACSubscriber&gt;)subscriber &#123;</span><br><span class="line"> <span class="built_in">NSCParameterAssert</span>(subscriber != <span class="literal">nil</span>);</span><br><span class="line"> RACCompoundDisposable *disposable = [RACCompoundDisposable compoundDisposable];</span><br><span class="line"> subscriber = [[RACPassthroughSubscriber alloc] initWithSubscriber:subscriber signal:<span class="keyword">self</span> disposable:disposable];</span><br><span class="line"> <span class="keyword">if</span> (<span class="keyword">self</span>.didSubscribe != <span class="literal">NULL</span>) &#123;</span><br><span class="line"> RACDisposable *schedulingDisposable = [RACScheduler.subscriptionScheduler schedule:^&#123;</span><br><span class="line"> RACDisposable *innerDisposable = <span class="keyword">self</span>.didSubscribe(subscriber);</span><br><span class="line"> [disposable addDisposable:innerDisposable];</span><br><span class="line"> &#125;];</span><br><span class="line"> [disposable addDisposable:schedulingDisposable];</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> disposable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中我们不难看出：<strong>除了对于订阅者和清理对象的再次封装外，最重要的就是创建信号时为信号设置Block(didSubscribe)被调用了，而且Block参数使用了我们创建的订阅者。</strong></p><h1 id="六、本篇总结"><a href="#六、本篇总结" class="headerlink" title="六、本篇总结"></a>六、本篇总结</h1><p>1.自创建信号会传入一个Block(didSubscribe)，Block中遵循协议的订阅者会调用sendNext方法发送消息。而在订阅信号subscribeNext时，会在内部创建一个订阅者，并将其传递给原先赋值的didSubscribe，并执行这个Block。</p><p>2.<strong>但是我们应该注意</strong>：上述的分析只是其中信号机制的一种情况罢了。RAC对于UI组件信号的封装可能有所不同，比如之前我们看到的输入框信号，执行订阅信号subscribeNext时并不立即执行打印，而是监听到输入时打印。这其实是该信号使用了concat又做了一系列的操作。<strong>对于不同的信号我们只需要理解上述分析中提到几个关键属性，就可以结合源码很好的理解信号机制的使用了。</strong></p><p>本篇的重点在于对RAC的基本介绍，是为了更好的理解信号机制，这仅相当于打开一个切入口来认识RAC。关于RAC的详细用法可以参考下一篇：<a href="https://www.jianshu.com/p/16b4b9d74b7c">ReactiveCocoa函数响应式编程-应用篇</a>，这里将总结RAC关于信号的各种用法。</p><p>其他参考链接：<br>1.<a href="http://www.cocoachina.com/ios/20150123/10994.html">ReactiveCocoa入门教程：第一部分</a><br>2.<a href="https://www.jianshu.com/p/87ef6720a096">最快让你上手ReactiveCocoa之基础篇</a><br>3.<a href="http://ios.jobbole.com/82356/">这样好用的ReactiveCocoa,根本停不下来</a><br>4.<a href="https://www.cnblogs.com/zhenw/p/6160931.html">函数式编程与面向对象的比较</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;ReactiveCocoa&lt;/code&gt;(简称&lt;code&gt;RAC&lt;/code&gt;)，&lt;code&gt;Reactive&lt;/code&gt;表示响应式，&lt;code&gt;Cocoa&lt;/code&gt;是苹果整个框架的简称，许多苹果框架都以&lt;code&gt;Cocoa&lt;/code&gt;结尾。所以&lt;code&gt;RAC&lt;/code&gt;是&lt;code&gt;Github&lt;/code&gt;上为我们提供函数响应式编程方法的&lt;code&gt;iOS&lt;/code&gt;开发框架。&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="https://wuyubeichen.github.io/categories/iOS/"/>
    
    
    <category term="iOS" scheme="https://wuyubeichen.github.io/tags/iOS/"/>
    
    <category term="ReactiveCocoa" scheme="https://wuyubeichen.github.io/tags/ReactiveCocoa/"/>
    
  </entry>
  
  <entry>
    <title>搭建个人博客网站Github、Hexo与Next</title>
    <link href="https://wuyubeichen.github.io/2018/02/28/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2Github%E3%80%81Hexo%E4%B8%8ENext/"/>
    <id>https://wuyubeichen.github.io/2018/02/28/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2Github%E3%80%81Hexo%E4%B8%8ENext/</id>
    <published>2018-02-28T06:34:57.000Z</published>
    <updated>2022-08-18T06:38:50.944Z</updated>
    
    <content type="html"><![CDATA[<p>温馨提示：由于本篇是后期整理的文章，一些在实际操作中遇到的错误可能会遗漏，但都是可以百度到的，当然，我也欢迎大家留言问题，以供完善记录。</p><p>效果展示：<a href="https://dreamcoffeezs.github.io/">梧雨北辰的博客</a></p><span id="more"></span><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><p>一、准备工作<br>二、搭建博客(远程与本地)<br>三、发布博客<br>四、更换主题<br>五、博客网站美化<br>六、在不同电脑管理hexo博客<br>七、遇到问题<br>八、其他方案</p><h1 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a>一、准备工作</h1><h2 id="1-了解Hexo"><a href="#1-了解Hexo" class="headerlink" title="1.了解Hexo"></a>1.了解Hexo</h2><p><a href="https://github.com/hexojs/hexo">Hexo</a>是高效的静态站点生成框架，她基于Node.js。 通过 Hexo 你可以轻松地使用 Markdown 编写文章，除了 Markdown 本身的语法之外，还可以使用 Hexo 提供的标签插件来快速的插入特定形式的内容，而且相对于其他框架，Hexo在速度上也有很大优势。</p><h2 id="2-搭建Node-js环境"><a href="#2-搭建Node-js环境" class="headerlink" title="2. 搭建Node.js环境"></a>2. 搭建Node.js环境</h2><p>我们了解到Hexo基于Node.js的，那么我们搭建博客网站首先需要安装Node.js环境。 Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境，可以在非浏览器环境下，解释运行 JS 代码。<br>下载地址：<a href="http://nodejs.cn/download">http://nodejs.cn/download</a><br>测试安装：命令行使用node -v 、mpm -v，查看显示版本号即成功。</p><h2 id="3-安装Hexo博客框架工具"><a href="#3-安装Hexo博客框架工具" class="headerlink" title="3.安装Hexo博客框架工具"></a>3.安装Hexo博客框架工具</h2><p>Hexo是一个建站工具，可以帮助我们快速生成基本的博客文件，安装它需要在控制台下使用如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure><p>若报错，请尝试在命令前加上sudo</p><h2 id="4-安装Git版本工具"><a href="#4-安装Git版本工具" class="headerlink" title="4.安装Git版本工具"></a>4.安装Git版本工具</h2><p>Git是目前世界上最流行的分布式版本控制系统，是的，没有之一。使用Git可以帮助我们把本地的网页和文章等内容提交到Gihub上，实现同步。<br>下载地址：<a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a><br>Windows系统需下载，Mac系统因为自带Git无需操作。<br>测试安装：git  - -version，查看显示版本号即成功。</p><h2 id="5-注册Github账号"><a href="#5-注册Github账号" class="headerlink" title="5.注册Github账号"></a>5.注册Github账号</h2><p>gitHub是一个面向开源及私有软件项目的托管平台，因为只支持git 作为唯一的版本库格式进行托管，故名gitHub。这里用到Github，是因为我们需要通过Github得到自己的博客网站域名，而且需要使用gitHub同步我们个人博客的相关文件。<br>注册地址：<a href="https://github.com/">https://github.com</a><br>注册流程：<a href="https://www.baidu.com/">https://www.baidu.com</a>，百度一下，你就知道啦。</p><p>注意：注册Github的时候一定要选择一个合适的名字，因为后来博客网站的域名也会用到这个名字。虽然Github用户名支持后期修改，但是还是会带来很多不必要的麻烦。github的使用在网上有很多教程，这里也就不再累述了。</p><h1 id="二、开始搭建博客"><a href="#二、开始搭建博客" class="headerlink" title="二、开始搭建博客"></a>二、开始搭建博客</h1><h2 id="1-开启GitHub-Pages服务"><a href="#1-开启GitHub-Pages服务" class="headerlink" title="1.开启GitHub Pages服务"></a>1.开启GitHub Pages服务</h2><p>搭建我们的个人博客需要一个唯一的域名，当然我们可以申请购买一个域名来使用，但是在不是太必要的情况下，我们也可以通过Github Pages获得一个免费使用的域名，这需要我们在Github上新建一个仓库，如下：</p><p><img src="http://upload-images.jianshu.io/upload_images/1244124-7ab2930306e23157.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="Create a new repository"></p><p>这个过程和建立普通的仓库没什么区别，关键在于新仓库的名字，一定要是UserName+“github.io”的形式。这也是之前强调的要起一个好的用户名的原因。这样之后我们最后的博客网站的链接就会是：<a href="http://dreamcoffeezs.github.io/">https://UserName.github.io</a>的形式。<br>注意：固定新仓库的名字格式并非必须，只是这样操作生成的博客域名比较短小简洁，另起他名生成博客域名会很冗长。</p><p>点击Create Repository之后，随后选择Setting进入设置，找到Github Pages如下：</p><p><img src="http://upload-images.jianshu.io/upload_images/1244124-5e0f79282ae8140c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="Github Pages"></p><p>这里我们需要点击Choose a theme任意选择一个选择主题，然后界面会跳转到仓库，我们看到有两个文件如下：</p><p><img src="http://upload-images.jianshu.io/upload_images/1244124-75e5fceb23b7b85a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="屏幕快照 2018-02-07 下午2.45.24.png"></p><p>此时若再查看setting，我们会看到开启GitHub Pages之后得到的域名如下：</p><p><img src="http://upload-images.jianshu.io/upload_images/1244124-685aeb93cbe41235.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="image.png"></p><p>现在，我们就可以使用<a href="https://dreamcoffeezs.github.io/">https://UserName.github.io</a>，访问自己的博客网站了，打开链接我们会看到默认主题的个人博客样式如下(虽然有点点丑，是吧)：</p><p><img src="http://upload-images.jianshu.io/upload_images/1244124-e1b205aeaf1442b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="image.png"></p><h2 id="2-创建本地博客站点"><a href="#2-创建本地博客站点" class="headerlink" title="2.创建本地博客站点"></a>2.创建本地博客站点</h2><p>上述的步骤相当于我们使用Github page，创建了一个默认的博客页，并且得到了一个可外部访问的域名。但是这个博客页很Low。我们的目的是创建自己个性化的博客网站，所以我们使用Hexo在本地先创建一个本地博客站点，优化后再把它部署到github上。接下来我们使用控制台命令在本地一个合适的位置创建博客站点文件夹如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init  myHexoBlog       //myHexoBlog是项目名</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/1244124-8f17110330f1d146.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>下面来测试本地博客站点，在本地博客根目录下使用控制台命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo g  //g是generetor的缩写，生成博客</span><br><span class="line"></span><br><span class="line">hexo s  //s是server的缩写，启动服务</span><br></pre></td></tr></table></figure><p>此时打开浏览器，输入 <a href="http://localhost:4000/">http://localhost:4000/</a>，我们将会看到Hexo自带默认主题显示的博客样式如下(呃，是好看了那么一点点)：<br><img src="http://upload-images.jianshu.io/upload_images/1244124-3e96fc83cdb07011.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500"></p><h2 id="3-同步Github-允许公共访问"><a href="#3-同步Github-允许公共访问" class="headerlink" title="3.同步Github,允许公共访问"></a>3.同步Github,允许公共访问</h2><p>在本地我们已经搭建了博客，但是还只能自己本地访问。若要别人也能看到，那就需要我们将其同步部署到GitHub上了。还记得我们之前准备的Github仓库吗，这里就要用到了。<br>首先找到我们的博客仓库，并拷贝仓库地址：</p><p><img src="http://upload-images.jianshu.io/upload_images/1244124-467d7e51b973d1c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500"></p><p>然后修改本地博客目录的配置：<br>修改本次博客根目录下的_config.yml文件，修改deploy下的配置如下：</p><p><img src="http://upload-images.jianshu.io/upload_images/1244124-32a2a2a1b31ffc24.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500"><br>最后执行控制台命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git —save //安装部署插件</span><br><span class="line"></span><br><span class="line">hexo d //部署到github</span><br></pre></td></tr></table></figure><p>现在，我们再次访问链接：<a href="https://dreamcoffeezs.github.io/">https://userName.github.io</a>，就会发现这里的界面和本地的一样了。如此一来我们搭建的个人博客网站就基本完成了。</p><h1 id="三、发布博客"><a href="#三、发布博客" class="headerlink" title="三、发布博客"></a>三、发布博客</h1><p>激动人心的时候到了，终于可以发布自己的第一篇博客了。来尝试一下以下的步骤：<br>在本地博客文件夹根目录输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;我个人博客的第一篇博客，哈哈哈...&quot;</span><br><span class="line"></span><br><span class="line">hexo g   //生成网页</span><br><span class="line"></span><br><span class="line">hexo d  //部署到远端(github)</span><br></pre></td></tr></table></figure><p>查看我们本地的博客文件夹，将会看到我们创建一个条新的博客文章：</p><p><img src="http://upload-images.jianshu.io/upload_images/1244124-214d608a5c3be183.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="image.png"></p><p>现在打开我们的博客网站：<a href="http://username.github.io/">http://UserName.github.io</a>,会看到网页如下(显示可能会延时，不如先喝杯茶放松下吧)：</p><p><img src="http://upload-images.jianshu.io/upload_images/1244124-cbdb263feca887f1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500"></p><p>这就是我们发布博客的方法啦，当然这里是为了演示，真正做的时候我们要找到_posts里的博客原文，先编辑内容，然后再部署到github上。</p><h2 id="四、更换主题"><a href="#四、更换主题" class="headerlink" title="四、更换主题"></a>四、更换主题</h2><p>现在我们已经看见个人博客的雏形了，但是现在的博客网页一点也不高大上。为了让它看起来更美观一些，我们可以为其更换主题（当然也可以自己在默认主题下自己编写美化博客界面，可是我还不太会前端，以后再突破吧）。这里以使用github上的next主题为例：</p><h2 id="1-创建next文件夹"><a href="#1-创建next文件夹" class="headerlink" title="1.创建next文件夹"></a>1.创建next文件夹</h2><p>切换到本地博客根目录下，在主题文件thems下创建一个新文件夹next存放即将下载的next主题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir themes/next</span><br></pre></td></tr></table></figure><h2 id="2-下载主题Next"><a href="#2-下载主题Next" class="headerlink" title="2.下载主题Next"></a>2.下载主题Next</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -s [https://api.github.com/repos/iissnan/hexo-theme-next/releases/latest](https://api.github.com/repos/iissnan/hexo-theme-next/releases/latest) | grep tarball_url | cut -d &#x27;&quot;&#x27; -f 4 | wget -i - -O- | tar -zx -C themes/next --strip-components=1</span><br></pre></td></tr></table></figure><p>此步骤可参考：<a href="https://github.com/iissnan/hexo-theme-next">https://github.com/iissnan/hexo-theme-next</a></p><p>下载成之后我们会看到next的主题已经存在thems里了如下：</p><p><img src="http://upload-images.jianshu.io/upload_images/1244124-c1330c2ff817ab5c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500"></p><h2 id="3-修改博客配置文件，更换主题配置"><a href="#3-修改博客配置文件，更换主题配置" class="headerlink" title="3.修改博客配置文件，更换主题配置"></a>3.修改博客配置文件，更换主题配置</h2><p>修改博客根目录(不是next主题)下的_config.yml文件，搜索theme字段，并将其值修改为next。</p><p><img src="http://upload-images.jianshu.io/upload_images/1244124-7f63babdcf1a854a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>然后在控制台下输入如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo clean  //清理缓存</span><br><span class="line"></span><br><span class="line">hexo g    //重新生成博客代码</span><br><span class="line"></span><br><span class="line">hexo d   //部署到本地</span><br></pre></td></tr></table></figure><p>再次打开我们的博客网站：<a href="https://dreamcoffeezs.github.io/">https://UserName.github.io</a>，将会看到更换主题后的博客网页如下：</p><p><img src="http://upload-images.jianshu.io/upload_images/1244124-892e7a2bcd8b1f39.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="屏幕快照 2018-02-07 下午3.50.50.png"></p><h1 id="五、博客网站美化"><a href="#五、博客网站美化" class="headerlink" title="五、博客网站美化"></a>五、博客网站美化</h1><p>终于我们的博客也算像点样子了，如果你和我一样是个完美主义者，那我们来继续美化它吧。这需要我们对博客中的各种配置进行修改。</p><p>首先说明一下：<strong>在Hexo中有两份主要的配置文件，其名称都是 _config.yml。 其中，一份位于站点根目录下，主要包含 Hexo本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。</strong></p><h2 id="1-站点配置："><a href="#1-站点配置：" class="headerlink" title="1.站点配置："></a>1.站点配置：</h2><p>在本地的博客根目录下找到_config.yml，用编辑器打开，如下：</p><p><img src="http://upload-images.jianshu.io/upload_images/1244124-e66dd07f4d17947a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500"></p><p>这里可以修改博客网站的标题、描述，语言等属性，上面更换主题也是在这个文件中修改的。大家可以在这里稍作设置。</p><h2 id="2-主题设置"><a href="#2-主题设置" class="headerlink" title="2.主题设置"></a>2.主题设置</h2><p>关于博客主题的配置这块本来想着自己写下呢，却发现官方文档更加详尽。大家可以参考Next文档来学习。<br>文档地址：<a href="http://theme-next.iissnan.com/getting-started.html">http://theme-next.iissnan.com/getting-started.html</a><br>其他参考：<br><a href="https://www.jianshu.com/p/f054333ac9e6">hexo的next主题个性化教程</a><br><a href="https://reuixiy.github.io/technology/computer/computer-aided-art/2017/06/09/hexo-next-optimization.html#">打造个性超赞博客Hexo+Next+githubPages的超深度优化</a></p><h2 id="3-更多主题选择"><a href="#3-更多主题选择" class="headerlink" title="3.更多主题选择"></a>3.更多主题选择</h2><p>next只是众多Hexo主题的一种，还有很多优秀的主题可供我们选择，参考以上的更换及配置方法我们就可以进一步美化我们的个人博客网站了。<br>更多主题选择：<a href="https://github.com/hexojs/hexo/wiki/Themes">https://github.com/hexojs/hexo/wiki/Themes</a></p><h1 id="六、在不同电脑管理hexo博客"><a href="#六、在不同电脑管理hexo博客" class="headerlink" title="六、在不同电脑管理hexo博客"></a>六、在不同电脑管理hexo博客</h1><p>其实，这也是我在使用Hexo搭建博客遇到的一个问题，如果我们检查自己博客在Github上的文件就会发现，github仓库里的文件和我们本地博客站点的文件夹是不同的，确切来说是少了很多内容。如果我们想在不同的电脑上管理自己的博客，就必须有源文件存在远端供我们随时下载、然后修改后重新部署到远端。</p><p>我们要理解这样一个过程：hexo -d是把本地博客源文件生成的静态网页文件同步到github上，实现部署。但是博客网站的源文件仍需要我们自己保存。这里主要有两种思路可以选择：</p><p>1.在github存放我们博客静态网页文件的仓库里另建分支brach，单独用于存放源文件。<br>2.将本地博客文件存放在<a href="https://gitee.com/">码云</a>上。</p><p>这些都是关于git的操作，所以这里不用细说了。单对于这两种方法来说，我更倾向于第二种。因为毕竟这些都是我们搭建个人博客的源文件，将来还要在网站上发表文章，很多数据都在这里。使用码云我们可以创建私有仓库，将这些源文件私有存放更好一些，而且源文件和静态博客网页文件分开存放也避免使用分支频繁切换。</p><h1 id="七、遇到问题"><a href="#七、遇到问题" class="headerlink" title="七、遇到问题"></a>七、遇到问题</h1><p> ####1.修改了配置，网站没有变化<br> 这种情况，大多因为修改后配置后我们直接部署，没有执行hexo clean。<br> ####2.代码无法高亮显示<br> 在Hexo的next主题下，我们使用markDown编辑文章，如果代码无法高亮，这有可能是我们没有在标记语言后添加语言类型，我需要在添加代码片段的时候使用如下的样式：<br> <br> <img src="http://upload-images.jianshu.io/upload_images/1244124-77df0d562485c6fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500"><br> <br> 类似其他语言用：java、python… </p><h1 id="八、其他方案"><a href="#八、其他方案" class="headerlink" title="八、其他方案"></a>八、其他方案</h1><p> 还有一种搭建博客网站的方案是<a href="https://www.jekyll.com.cn/">Jekyll</a>，还没有细致研究呢，先记在这里为以后扩展思路。<br> <br> 终于写完了，祝新的一年越来越好，加油！- 2018-02-13</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;温馨提示：由于本篇是后期整理的文章，一些在实际操作中遇到的错误可能会遗漏，但都是可以百度到的，当然，我也欢迎大家留言问题，以供完善记录。&lt;/p&gt;
&lt;p&gt;效果展示：&lt;a href=&quot;https://dreamcoffeezs.github.io/&quot;&gt;梧雨北辰的博客&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="闲暇所学" scheme="https://wuyubeichen.github.io/categories/%E9%97%B2%E6%9A%87%E6%89%80%E5%AD%A6/"/>
    
    
    <category term="个人博客" scheme="https://wuyubeichen.github.io/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    
    <category term="Github" scheme="https://wuyubeichen.github.io/tags/Github/"/>
    
  </entry>
  
  <entry>
    <title>iOS多Target开发相似App</title>
    <link href="https://wuyubeichen.github.io/2018/02/10/iOS%E5%A4%9ATarget%E5%BC%80%E5%8F%91/"/>
    <id>https://wuyubeichen.github.io/2018/02/10/iOS%E5%A4%9ATarget%E5%BC%80%E5%8F%91/</id>
    <published>2018-02-10T09:20:47.000Z</published>
    <updated>2022-08-17T03:01:16.092Z</updated>
    
    <content type="html"><![CDATA[<p>我们在iOS开发中可能会遇到同时开发多个类似项目的情况。这些项目大同小异，有诸多代码可以共用，如果每个项目都分别开发，这在后期的迭代中会十分繁琐。为了解决这个问题，使用多Target开发是一种比较好的选择，本文就这一技术实现进行简要总结。</p><span id="more"></span><h1 id="一、理解项目中的Porject与Target"><a href="#一、理解项目中的Porject与Target" class="headerlink" title="一、理解项目中的Porject与Target"></a>一、理解项目中的Porject与Target</h1><p>使用Xcode来开发项目，其中的Project是一个整体项目相当于一个仓库，包括了所有的代码和资源文件。而Target相当于一个具体的产品，包含了对于代码，资源文件的具体使用规则和配置。一个Project可以包含多个Target，也就是说通过不同Target我们可以生成不同的APP。</p><h1 id="二、多Target开发项目的实践步骤"><a href="#二、多Target开发项目的实践步骤" class="headerlink" title="二、多Target开发项目的实践步骤"></a>二、多Target开发项目的实践步骤</h1><p>使用多Target来创建项目，就以我当前正在开发的亲戚买房APP为例。需求是这样的：亲戚买房是一个为买房人提供砍价服务的APP，APP的用户需要区分为用户，专家和砍价师三个用户群体。所以这里以Customer，Consul，Bargain三个Target来开发应用</p><h2 id="1-以QQMF-亲戚买房-为名创建一个新的工程如下"><a href="#1-以QQMF-亲戚买房-为名创建一个新的工程如下" class="headerlink" title="1.以QQMF(亲戚买房)为名创建一个新的工程如下:"></a>1.以QQMF(亲戚买房)为名创建一个新的工程如下:</h2><p><img src="http://upload-images.jianshu.io/upload_images/1244124-72d370487e724419.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2017-11-20 上午11.25.03.png"></p><h2 id="2-创建三种Target"><a href="#2-创建三种Target" class="headerlink" title="2.创建三种Target"></a>2.创建三种Target</h2><p>创建新Target的方式有两种：<br>第一种：依次选择File-&gt;New-&gt;Target，然后选择一个模板(通常是Single View App)来创建。只是这样创建的target带有Appdelegate和main等文件，在这里并不会用到这些文件，所以我们采用第二种方式创建。<br>第二种：<br>在Targets中点击已有的Target，右键选择Duplicate可以复制生成一个<strong>copy的新Target，并且在文件目录中生成对应的</strong>copy-Info.plist文件。这样生成的target与被拷贝的target相似度很大，减少了过多的修改。通常为了减少后期的修改，我们也会首先在原有的Target中修改一些配置之后再Duplicate。<br><img src="http://upload-images.jianshu.io/upload_images/1244124-355533856df44b16.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2017-11-20 上午11.27.06.png"></p><p>执行了Duplicate操作之后的效果如下：<br><img src="http://upload-images.jianshu.io/upload_images/1244124-b78642363f7d0a0d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2017-11-20 上午11.29.38.png"></p><h2 id="3-修改Targe和plist文件的名称为自己需要的名称"><a href="#3-修改Targe和plist文件的名称为自己需要的名称" class="headerlink" title="3.修改Targe和plist文件的名称为自己需要的名称"></a>3.修改Targe和plist文件的名称为自己需要的名称</h2><p>在Target里可以直接修改Target的名称，在文件目录下也可以直接修改plist文件的名称。如果我们不想文件结构那么乱，也可以像其他文件一样移动plist文件的位置并重新引用到工程中，如下：<br><img src="http://upload-images.jianshu.io/upload_images/1244124-ae5e46a7d2c3f927.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2017-11-20 下午6.35.12.png"><br>特别注意：我们在移动文件的时候可能需要重新引用文件到工程中，此时add文件的时候一定要注意选择Target，如果是共用文件一定要勾选对应的Target，类似AppDelegate这样文件的操作如下：<br><img src="http://upload-images.jianshu.io/upload_images/1244124-8a3839defed21646.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2017-11-20 下午6.29.01.png"></p><h2 id="4-修改Xcode左上角的Target名称"><a href="#4-修改Xcode左上角的Target名称" class="headerlink" title="4.修改Xcode左上角的Target名称"></a>4.修改Xcode左上角的Target名称</h2><p>选中Xcode左上角的创建工程时的Target(QQMF)，选择Manage schemes<br><img src="http://upload-images.jianshu.io/upload_images/1244124-63a550909a0a2bbc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2017-11-20 下午6.38.06.png"><br>在如下的schemes中修改Target的名称，这里也可以删除多余的最初的QQMF<br><img src="http://upload-images.jianshu.io/upload_images/1244124-a9d8cd9d9082380d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2017-11-20 上午11.47.18.png"></p><p>特别说明：QQMF是我们创建工程自带的Target,其实也可以修改它的名字以供自定义使用，而这里我们是直接删掉了它，这样之后，项目自带的info.plist也是没用的了，也可以删掉。</p><h2 id="5-设置Target与plist文件对应"><a href="#5-设置Target与plist文件对应" class="headerlink" title="5.设置Target与plist文件对应"></a>5.设置Target与plist文件对应</h2><p>切换到Target目录下，我们可以在这里删掉用不到的QQMF，选择其中一个Target之后并选择general，然后可以看到每个Target的右侧都有对应的choose info.plist file选项，点击可以选择与Target对应的plist文件。这也就相当于不同的Target项目对应了不同的plist配置。<br><img src="http://upload-images.jianshu.io/upload_images/1244124-3d5dfd16700ceb2c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2017-11-20 下午2.01.27.png"></p><h2 id="6-为每个Target设置Display-Name，Bundle-Identifier等信息"><a href="#6-为每个Target设置Display-Name，Bundle-Identifier等信息" class="headerlink" title="6.为每个Target设置Display Name，Bundle Identifier等信息"></a>6.为每个Target设置Display Name，Bundle Identifier等信息</h2><p>点击Target-&gt;选择General，我们分别设置不同项目的名称和BundleID信息，以及证书等<br><img src="http://upload-images.jianshu.io/upload_images/1244124-3db248a3e49c6a4f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2017-11-20 下午2.28.17.png"></p><h2 id="7-同一份代码区分不同Target的操作"><a href="#7-同一份代码区分不同Target的操作" class="headerlink" title="7.同一份代码区分不同Target的操作"></a>7.同一份代码区分不同Target的操作</h2><p>使用多Target是为了共用一部分代码，但是有些共用的文件在不同的Target下是有细微不同的，那么我们在具体实现的时候就需要作出区分。这里解决的方法是针对不同的Target定义宏。<br>首先选择一个Target,如Customer，依次选择Build Settings -&gt;搜索PreprocessorMacros,  在找到PreprocessorMacros之后，我们分别在Debug和Release中设置TargetType&#x3D;1如下图进行设置：<br><img src="http://upload-images.jianshu.io/upload_images/1244124-afb7d7a92379c410.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2017-11-20 下午6.45.35.png"></p><p>其他的Target也是同样的设置方式，只是要区分TargetType的值，分别是2，3(TargetType及其值都是自定义的)。然后就是在代码中的使用如下图，分别选择Xcode左上角不同的Target运行，查看控制台验证是否成功。</p><p><img src="http://upload-images.jianshu.io/upload_images/1244124-f24686677a7e4cdb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2017-11-20 下午6.55.02.png"></p><h2 id="8-解决使用Cocoapods的问题"><a href="#8-解决使用Cocoapods的问题" class="headerlink" title="8.解决使用Cocoapods的问题"></a>8.解决使用Cocoapods的问题</h2><p>因为存在多个Target，我们需要区别的设置不同target需要的第三方库，如下图。这里可能出现的问题是如果有很多类似AFNetworking这样的被多个Target需要的类库，我们在删除和增加的时候就会频繁的操作而且会代码冗余。<br><img src="http://upload-images.jianshu.io/upload_images/1244124-f010d430c1b3426b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2017-11-20 下午7.22.34.png"><br>解决上述问题的比较优雅的做法是如下：<br><img src="http://upload-images.jianshu.io/upload_images/1244124-9d2efd2a48a3c8f9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2017-11-20 下午7.39.25.png"></p><h2 id="三、遇到的问题"><a href="#三、遇到的问题" class="headerlink" title="三、遇到的问题"></a>三、遇到的问题</h2><ol><li>问题：invalid token at start of a preprocessor expression<br>原因：这是我在pch文件中判断target类型出现的错误，这句话的大致意思是：在预编译阶段，代码并未运行，无法判断宏定义的值。最后查找到原因是我在上述步骤设置宏定义的时候，手误设置了TargetType&#x3D;&#x3D;1，这本是一句需要执行才能得到结果的代码。所以无法在#if的条件编译中通过。<br>解决：在条件编译中不使用代码运行时才生成的量即可。</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;我们在iOS开发中可能会遇到同时开发多个类似项目的情况。这些项目大同小异，有诸多代码可以共用，如果每个项目都分别开发，这在后期的迭代中会十分繁琐。为了解决这个问题，使用多Target开发是一种比较好的选择，本文就这一技术实现进行简要总结。&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="https://wuyubeichen.github.io/categories/iOS/"/>
    
    
    <category term="移动开发" scheme="https://wuyubeichen.github.io/tags/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
</feed>
