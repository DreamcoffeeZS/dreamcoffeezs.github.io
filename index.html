<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/header.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/header.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/header.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"wuyubeichen.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="iOS Developer, Beijing China">
<meta property="og:type" content="website">
<meta property="og:title" content="梧雨北辰的博客">
<meta property="og:url" content="https://wuyubeichen.github.io/index.html">
<meta property="og:site_name" content="梧雨北辰的博客">
<meta property="og:description" content="iOS Developer, Beijing China">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Zhou Shuai">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://wuyubeichen.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>梧雨北辰的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="梧雨北辰的博客" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">梧雨北辰的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">天行健，君子以自强不息！</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wuyubeichen.github.io/2021/11/08/iOS%E9%AB%98%E7%BA%A7-%E9%9D%99%E6%80%81%E5%BA%93%E4%B8%8E%E5%8A%A8%E6%80%81%E5%BA%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Author">
      <meta itemprop="description" content="iOS Developer, Beijing China">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="梧雨北辰的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/08/iOS%E9%AB%98%E7%BA%A7-%E9%9D%99%E6%80%81%E5%BA%93%E4%B8%8E%E5%8A%A8%E6%80%81%E5%BA%93/" class="post-title-link" itemprop="url">iOS高级-静态库与动态库</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-11-08 22:23:12" itemprop="dateCreated datePublished" datetime="2021-11-08T22:23:12+08:00">2021-11-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-29 09:39:32" itemprop="dateModified" datetime="2022-08-29T09:39:32+08:00">2022-08-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS%E9%AB%98%E7%BA%A7/" itemprop="url" rel="index"><span itemprop="name">iOS高级</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>主要内容：</strong></p>
<ol>
<li>库的概念总结</li>
<li>库的格式类型</li>
<li>区分静态库与动态库</li>
<li>使用静态库与动态库</li>
</ol>
<h4 id="一、库的概念总结"><a href="#一、库的概念总结" class="headerlink" title="一、库的概念总结"></a>一、库的概念总结</h4><p>所谓库(<code>Libary</code>)，其实就是代码共享的一种方式，将具备一定功能的模块代码整理起来，方便多次使用；<br><img src="http://182.92.228.41/wp-content/uploads/libray_classification.png" width="600" align=center/></p>
<h5 id="1-开源库："><a href="#1-开源库：" class="headerlink" title="1.开源库："></a>1.开源库：</h5><p>库中代码公开，可以方便使用者学习和根据自己的需求随意修改源代码；</p>
<h5 id="2-闭源库："><a href="#2-闭源库：" class="headerlink" title="2.闭源库："></a>2.闭源库：</h5><ol>
<li>闭源库中代码不公开，只能通过其公开的一些头文件来调用；</li>
<li>闭源库中代码库是已经编译好的二进制文件，程序的运行只需要在编译的时候链接(<code>Link</code>)一下就好了，不会浪费编译时间;</li>
<li>闭源库由于链接的方式不同，就分为了<code>静态库(静态链接)</code>和<code>动态库(动态链接)</code>；</li>
</ol>
<h5 id="3-封装库的作用"><a href="#3-封装库的作用" class="headerlink" title="3.封装库的作用"></a>3.封装库的作用</h5><ol>
<li><code>方便复用</code>：将不经常改动的功能但经常使用的代码封装成库；</li>
<li><code>编译效率</code>：动态库与静态库都是二进制文件，程序运行时只要链接这些文件即可，节约时间；</li>
<li><code>代码安全</code>：重要的代码不想公开，但又需要提供功能给别人使用，可以封装为闭源库；</li>
</ol>
<h5 id="4-Cocoapods里的动、静态库"><a href="#4-Cocoapods里的动、静态库" class="headerlink" title="4.Cocoapods里的动、静态库"></a>4.Cocoapods里的动、静态库</h5><p><code>静态库</code>与<code>动态库</code>都是闭源库(都是二进制的)，是看不到源码的, 只能看到头文件，但是<code>Cocoapods</code>集成后却是可以看见的，这是因为：</p>
<ol>
<li><code>Cocoapods</code>是集成了源码放到了新建的<code>Pods</code>工程里；</li>
<li><code>Pods</code>工程的<code>target</code>依赖了我们所有导入的第三方库, 然后主<code>App</code>对<code>Pods</code>工程中的这个<code>target</code> 的生成的<code>product</code>进行依赖, 形成了我们好像直接可以使用第三方库源码的错觉；</li>
<li>其实<code>App</code>最终链接的还是静态库或者动态库。</li>
</ol>
<p>可以在<code>Xcode</code>中查看到效果如下：<br><img src="http://182.92.228.41/wp-content/uploads/libray_app_cocoapods.png" width="800" align=center/></p>
<h4 id="二、库的格式类型"><a href="#二、库的格式类型" class="headerlink" title="二、库的格式类型"></a>二、库的格式类型</h4><p><code>iOS</code>中动态库与静态库的后缀类型有以下几种：</p>
<h5 id="1-后缀类型-a"><a href="#1-后缀类型-a" class="headerlink" title="1.后缀类型.a"></a>1.后缀类型<code>.a</code></h5><ol>
<li><code>.a</code>是是典型的静态库，是纯二进制文件，不能直接使用, 至少还要有<code>.h</code>文件配合；</li>
<li>创建<code>.a</code>静态库：<code>Xode -&gt; File -&gt; New -&gt; Project</code>中的<code>Static Library</code>即可新建；</li>
</ol>
<h5 id="2-后缀类型-framework"><a href="#2-后缀类型-framework" class="headerlink" title="2.后缀类型.framework"></a>2.后缀类型<code>.framework</code></h5><ol>
<li><code>Framework</code>只是一种打包方式，不代表库的<code>链接</code>特性，所以不能以此区分<code>静态库</code>和<code>动态库</code>；</li>
<li><code>Framework</code>经过打包，可以将代码文件、头文件、资源文件、说明文档等集中在一起，方便开发者使用；</li>
<li><code>Framework</code>既可以做成静态库, 也可以做成动态库，只需在创建的<code>Framework</code>工程中修改某个 <code>target</code> 的 <code>Build Setting</code>，切换<code>Mach-O Type</code>即可；</li>
</ol>
<h5 id="3-后缀类型tbd-之前叫-dylib"><a href="#3-后缀类型tbd-之前叫-dylib" class="headerlink" title="3. 后缀类型tbd(之前叫.dylib)"></a>3. 后缀类型<code>tbd(之前叫.dylib)</code></h5><p><code>tbd</code>全称是<code>text-based stub libraries</code>，本质上就是一个<code>YAML</code>描述的文本文件；</p>
<ol>
<li>用于记录动态库的一些信息，包括导出的符号、动态库的架构信息、动态库的依赖信息；</li>
<li>用于避免在真机开发过程中直接使用传统的<code>dylib</code>；</li>
<li>对于真机来说，由于动态库都是在设备上，在<code>Xcode</code>上使用基于<code>tbd</code>格式的伪<code>framework</code>可以大大减少<code>Xcode</code>的大小；</li>
</ol>
<h5 id="4-后缀类型XCFramework"><a href="#4-后缀类型XCFramework" class="headerlink" title="4.后缀类型XCFramework"></a>4.后缀类型<code>XCFramework</code></h5><p><code>XCFramework</code>是苹果官方在<code>2019</code>年推出的新的库类型，支持包含多平台架构。<code>XCFramework</code>需要<code>Xcode11</code>以上支持；</p>
<p><code>XCFramework</code>的优势：</p>
<ol>
<li><code>Framework</code>只能包含多个架构(如<code>x86_64</code>、<code>arm64e</code>等)，而<code>XCFramework</code>可以按照平台划分，包含相同架构的不同平台文件(如将<code>iOS</code>，<code>macOS</code>，<code>watchOS</code>等多平台的<code>arm64</code>架构合并在一起)；</li>
<li><code>XCFramework</code>可以包含其他第三方的库；</li>
<li><code>XCFramework</code>可以更好的支持<code>Mac Catalyst</code>和<code>ARM</code>芯片的<code>MacOS</code>；</li>
<li><code>XCFramework</code>可以不用设置复杂的头文件路径；</li>
<li><code>XCFramework</code>可以在库里面设置权限；</li>
<li><code>XCFramework</code>使用时，不需要再通过脚本去剥离不需要的架构体系。</li>
</ol>
<p>举例：<code>libpo</code>命令不支持将相同架构合并在一起，比如<code>iOS</code>的<code>arm64</code>的与<code>macOS</code>的<code>arm64</code>不能合并；</p>
<h4 id="二、区分静态库与动态库"><a href="#二、区分静态库与动态库" class="headerlink" title="二、区分静态库与动态库"></a>二、区分静态库与动态库</h4><p>静态库与动态库，都是以二进制形式提供代码复用的代码库；</p>
<h5 id="1-静态库"><a href="#1-静态库" class="headerlink" title="1.静态库"></a>1.静态库</h5><p>静态库是在<code>编译期</code>链接的库，需要链接到<code>Mach-O</code>文件里；</p>
<p>优点：</p>
<ol>
<li>静态库在链接时, 会被完整的复制到可执行文件中; </li>
<li>使用静态库时，目标程序没有外部依赖，直接就可以运行，效率较高；</li>
</ol>
<p>缺点：</p>
<ol>
<li>多次使用, 就会有多次的拷贝(<code>import</code>)，会使用目标程序的体积增大；</li>
<li>无法动态加载和更新，每次更新都需要重新编译一次；</li>
</ol>
<img src="http://182.92.228.41/wp-content/uploads/libray_static_use_in_system.png" width="300" hegiht="300" align=center/>


<h5 id="2-动态库"><a href="#2-动态库" class="headerlink" title="2.动态库"></a>2.动态库</h5><p>动态库是在运行时才链接的库，链接时不会拷贝，系统只加载一次动态库；</p>
<p>优点：</p>
<ol>
<li>代码共享：同一份库可以被多个程序使用，节省内存易于维护；</li>
<li>减少可执行文件的体积：动态库不需要拷贝到目标程序中，不会影响目标程序的体积；</li>
<li>动态更新：动态库不绑定到可执行程序上，所以升级替换动态库很容易，不需要重新编译代码；类似<code>windows</code>和<code>linux</code>上面一般插件和模块机制都是这样实现的；</li>
</ol>
<p>缺点：</p>
<ol>
<li>动态载入会带来一部分性能损失(可以忽略不计）</li>
<li>动态库也会使得程序依赖于外部环境，如果环境缺少动态库或者库的版本不正确，就会导致程序无法运行(<code>Linux lib not found</code>错误)；</li>
</ol>
<img src="http://182.92.228.41/wp-content/uploads/libray_dynamic_use_in_system.png" width="300" hegiht="300" align=center/>


<p><strong>补充：</strong>常见动态库有<code>Windows</code>下的<code>.dll</code>，<code>Linux</code>下的<code>.so</code>，<code>Mac</code>下的<code>.dylib/.tbd</code></p>
<h4 id="三、使用静态库与动态库"><a href="#三、使用静态库与动态库" class="headerlink" title="三、使用静态库与动态库"></a>三、使用静态库与动态库</h4><img src="http://182.92.228.41/wp-content/uploads/libray_framework_use_in_ios.png" width="400" align=center/>

<h5 id="1-iOS8之前：iOS平台不允许使用动态库"><a href="#1-iOS8之前：iOS平台不允许使用动态库" class="headerlink" title="1. iOS8之前：iOS平台不允许使用动态库"></a>1. iOS8之前：iOS平台不允许使用动态库</h5><ol>
<li>所有的<code>ipa</code>都需要经过<code>App</code>的秘钥加密后才能使用，所以即使使用动态库也会因为签名不对无法加载(除非越狱和非<code>AppStoree</code>)；</li>
<li><code>iOS8</code>之前的所有应用都运行在沙盒中，不同程序间不可共享代码，而且<code>iOS</code>是单进程，所以共享库没有存在必要；</li>
<li>苹果禁止动态下载你代码，无法发挥动态库的优势；</li>
</ol>
<h5 id="2-iOS8之后：允许使用Embedded-Framework"><a href="#2-iOS8之后：允许使用Embedded-Framework" class="headerlink" title="2. iOS8之后：允许使用Embedded Framework"></a>2. iOS8之后：允许使用Embedded Framework</h5><ol>
<li>由于<code>iOS</code>主<code>App</code>需要和<code>Extension</code>共享代码，<code>Swift</code>语言机制也需要动态库，于是苹果后来提出了<code>Embedded Framework</code>；</li>
<li>这种动态库允许<code>APP</code>和<code>APP Extension</code>共享代码，但是这份动态库的生命被限定在一个<code>APP</code>进程内。简单点可以理解为被阉割的动态库；</li>
<li><code>iOS</code>中的<code>Embedded Framework</code>可以理解为独立的没有<code>main</code>函数的可执行文件。</li>
</ol>
<table>
<thead>
<tr>
<th>库</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Static Framework</code></td>
<td>用户可制作的静态库，相当于<code>头文件 + 资源文件 + 二进制代码</code>；</td>
</tr>
<tr>
<td><code>Dynamic Framework</code></td>
<td>1.具有所有动态库的特性，比如<code>UIKit.framework</code>，系统提供的<code>framework</code>都是动态库；<br>2.系统的<code>Framework</code>不需要拷贝到目标程序中;<br>3.系统的的动态库是给多个进程用的；</td>
</tr>
<tr>
<td><code>Embedded Framework</code></td>
<td>1.用户可以制作的<code>framework</code>动态库；<br>2.需要拷贝到<code>App</code>中，并在<code>Xcode</code>中进行动态库的配置：<code>TARGET</code> -&gt; <code>General</code> -&gt; <code>Frameworks,Libraries,and Enbedded Content </code>；<br>3.只具有部分动态特性，因为受到<code>iOS</code>平台限制(签名机制和沙盒机制限制)；<br>3.只是给单进程里多个可执行文件(<code>Extension</code>可执行文件和APP可执行文件)用；<br></td>
</tr>
</tbody></table>
<p>上面提到跟<code>Swift</code>也有原因，在<code>Swift</code>的项目使用外部代码，可选的方式只有两种：</p>
<ol>
<li>把代码拷贝到工程中；</li>
<li>使用动态库<code>Framework</code>；</li>
</ol>
<p><code>Swift</code>不支持使用静态库，这个问题的根本原因主要是：</p>
<ol>
<li><code>Swift runtime</code>没有被包含在<code>iOS</code>系统中，而是会打包进<code>App</code>中；</li>
<li>这也是造成<code>Swift App</code>体积大的原因，若使用静态库会导致最终的目标程序中包含重复的运行库；</li>
</ol>
<h5 id="3-“Do-Not-Embed”、“Embed-amp-Sign”、“Embed-Without-Signing”-区别？"><a href="#3-“Do-Not-Embed”、“Embed-amp-Sign”、“Embed-Without-Signing”-区别？" class="headerlink" title="3. “Do Not Embed”、“Embed &amp; Sign”、“Embed Without Signing” 区别？"></a>3. “Do Not Embed”、“Embed &amp; Sign”、“Embed Without Signing” 区别？</h5><ul>
<li><strong>Embed</strong>：嵌入，对于静态库选择<code>Do Not Embed</code>，动态链接选择<code>Embed</code>；</li>
<li><strong>Sign</strong>：签名，如果代码没有签名则选择<code>Embed &amp; Sign</code>，否则<code>Embed Without Signing</code>；</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wuyubeichen.github.io/2021/11/06/iOS%E9%AB%98%E7%BA%A7-MachO%E7%AC%A6%E5%8F%B7%E5%88%86%E7%B1%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Author">
      <meta itemprop="description" content="iOS Developer, Beijing China">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="梧雨北辰的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/06/iOS%E9%AB%98%E7%BA%A7-MachO%E7%AC%A6%E5%8F%B7%E5%88%86%E7%B1%BB/" class="post-title-link" itemprop="url">iOS高级-MachO符号分类</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-11-06 22:23:12" itemprop="dateCreated datePublished" datetime="2021-11-06T22:23:12+08:00">2021-11-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-29 09:39:32" itemprop="dateModified" datetime="2022-08-29T09:39:32+08:00">2022-08-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS%E9%AB%98%E7%BA%A7/" itemprop="url" rel="index"><span itemprop="name">iOS高级</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>主要内容：</strong></p>
<ol>
<li>理解<code>Symbol</code>的概念</li>
<li>查看<code>Symbol</code>的方式</li>
<li>符号表<code>Symbol Table</code></li>
<li>重定位符号</li>
<li>全局符号与本地符号</li>
<li>导出符号</li>
<li>间接符号</li>
<li>弱符号</li>
<li>未初始化的全局符号</li>
<li>重新导出符号</li>
<li><code>Swift</code>符号</li>
</ol>
<h4 id="一、理解Symbol的概念"><a href="#一、理解Symbol的概念" class="headerlink" title="一、理解Symbol的概念"></a>一、理解Symbol的概念</h4><p><code>Mahc-O</code>文件中的符号表<code>Symbol Table</code>，在<code>Mach-O</code>的整个链接和运行过程中起着重要作用；</p>
<h5 id="1-符号的概念"><a href="#1-符号的概念" class="headerlink" title="1.符号的概念"></a>1.符号的概念</h5><ol>
<li><code>Symbol</code>：包含了名称(<code>String</code>)和类型等信息的数据结构，对应的是一个函数或者数据的地址；</li>
<li><code>Symbol Table</code>：保存符号信息的表；</li>
<li><code>String Table</code>：保存符号名称的表；</li>
<li><code>Indirect Symbol Table</code>：间接符号表，保存使用的外部符号，更准确一点就是使用的外部动态库的符号，它是<code>Symbol Table</code>的子集；</li>
</ol>
<h5 id="2-符号与链接"><a href="#2-符号与链接" class="headerlink" title="2.符号与链接"></a>2.符号与链接</h5><p>链接的作用：链接器把多个<code>.m文件</code>编译产生的<code>.o</code>文件和(<code>dylib</code>、<code>a</code>、<code>tbd</code>）文件，合成一个<code>Mach-O</code>格式的可执行文件；</p>
<p>链接阶段的重要目的：符号解析和重定位</p>
<ul>
<li>符号解析：将每个<code>符号</code>引用和对应的<code>符号</code>定义关联起来；</li>
<li>重定位：将每个<code>符号</code>定义与一个<code>内存位置</code>关联起来，然后修改所有对这些符号的引用；</li>
</ul>
<p>举例：二进制文件<code>main</code>中用到了二进制<code>A</code>中的函数<code>a</code>，则<code>main</code>就可以读取二进制<code>A</code>维护的符号表，进而在<code>A</code>找到函数<code>a</code>的实现；</p>
<h5 id="3-符号与调试"><a href="#3-符号与调试" class="headerlink" title="3.符号与调试"></a>3.符号与调试</h5><p><code>Xcode</code>调试时，需要通过符号表将<code>符号</code>和<code>源文件</code>映射起来，而如果将<code>调试符号</code>裁剪掉(如图，将<code>Deployment Postprocessing</code>设置为<code>YES</code>)，就会使得断点失效。<br><img src="http://182.92.228.41/wp-content/uploads/symbol_deployment_postprocessing.png" width="600" align=center/></p>
<p>注意：<code>Release</code>模式下是可以裁剪掉符号的，因为<code>release</code>模式下默认有<code>dsym</code>文件，调试器仍然可以从中获取到信息正常工作；</p>
<h4 id="二、查看Symbol的方式"><a href="#二、查看Symbol的方式" class="headerlink" title="二、查看Symbol的方式"></a>二、查看Symbol的方式</h4><h5 id="1-使用MachOView查看"><a href="#1-使用MachOView查看" class="headerlink" title="1.使用MachOView查看"></a>1.使用MachOView查看</h5><p>使用<code>MachOView</code>查看<code>Mach-O</code>文件，效果如下：</p>
<img src="http://182.92.228.41/wp-content/uploads/symbol_view_macho1.png" width="600" align=center/>

<h5 id="2-使用objdump命令查看"><a href="#2-使用objdump命令查看" class="headerlink" title="2.使用objdump命令查看"></a>2.使用objdump命令查看</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查看重定位符号表</span></span><br><span class="line">objdump <span class="operator">-</span>—macho <span class="operator">-</span>—reloc .o文件</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看符号表</span></span><br><span class="line">objdump <span class="operator">--</span>macho <span class="operator">--</span>syms .o文件或<span class="type">MachO文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看导出符号</span></span><br><span class="line">objdump <span class="operator">--</span>macho <span class="operator">--</span>exports<span class="operator">-</span>trie .o文件或<span class="type">Mach</span><span class="operator">-</span><span class="type">O文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看间接符号表</span></span><br><span class="line">objdump <span class="operator">--</span>macho <span class="operator">--</span><span class="keyword">indirect</span><span class="operator">-</span>symbols .o文件或<span class="type">Mach</span><span class="operator">-</span><span class="type">O文件</span></span><br></pre></td></tr></table></figure>


<h4 id="三、符号表Symbol-Table"><a href="#三、符号表Symbol-Table" class="headerlink" title="三、符号表Symbol Table"></a>三、符号表Symbol Table</h4><h5 id="1-符号表在Mach-O中的位置"><a href="#1-符号表在Mach-O中的位置" class="headerlink" title="1.符号表在Mach-O中的位置"></a>1.符号表在Mach-O中的位置</h5><p>下面的图，能够更加直观的展示<code>符号表</code>在<code>Mach-O</code>文件中的位置：<br><img src="http://182.92.228.41/wp-content/uploads/symbol_view_macho2.png" width="600" align=center/></p>
<p>这里需要注意两个重要的<code>Load Commands</code>：</p>
<ul>
<li><code>LC_SYMTAB</code> ：描述当前<code>Mach-O</code>中的符号表信息；</li>
<li><code>LC_DYSYMTAB</code> ：描述动态连接器使用其他符号表的信息；</li>
</ul>
<p>其中<code>LC_SYMTAB</code>对应的数据结构<code>symtab_command</code>，其源码如下：<br> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">struct</span> <span class="title class_">symtab_command</span> &#123;</span><br><span class="line">    <span class="comment">// 共有属性。指明当前描述的加载命令，当前被设置为LC_SYMTAB</span></span><br><span class="line">    uint32_t cmd ;</span><br><span class="line">    <span class="comment">// 共有属性。指明加载命令的大小，当前被设置为sizeof(symtab_command)</span></span><br><span class="line">    uint32_t cmdsize;</span><br><span class="line">    <span class="comment">// 表示从文件开始到symbol table所在位置的偏移量。symbol table用[nlist]来表示</span></span><br><span class="line">    uint32_t symoff;</span><br><span class="line">    <span class="comment">// 符号表内符号的数量</span></span><br><span class="line">    uint32_t nsyms;</span><br><span class="line">    <span class="comment">// 表示从文件开始到string table所在位置的偏移量。</span></span><br><span class="line">    uint32_t stroff;</span><br><span class="line">    <span class="comment">// 表示string table大小(以byteカ单位)</span></span><br><span class="line">    uint32_t strsize;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br><code>LC_SYMTAB</code>的使用场景：</p>
<ol>
<li>静态链接器、动态链接器链接文件时；</li>
<li>调试器寻找调试信息时；</li>
</ol>
<h5 id="2-符号表的源码分析"><a href="#2-符号表的源码分析" class="headerlink" title="2.符号表的源码分析"></a>2.符号表的源码分析</h5><p><code>Symbol Table</code>中存储着符号，而<code>Symbol</code>则是一个数据结构，包含了名称(<code>String</code>)和类型等元数据，符号对应一个函数或者数据的地址，其在代码的定义如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">nlist_64</span> &#123;</span><br><span class="line">    union &#123;</span><br><span class="line">        uint32_t  n_strx; <span class="comment">/* index into the string table */</span></span><br><span class="line">    &#125; n_un;</span><br><span class="line">    uint8_t n_type;        <span class="comment">/* type flag, see below */</span></span><br><span class="line">    uint8_t n_sect;        <span class="comment">/* section number or NO_SECT */</span></span><br><span class="line">    uint16_t n_desc;       <span class="comment">/* see &lt;mach-o/stab.h&gt; */</span></span><br><span class="line">    uint64_t n_value;      <span class="comment">/* value of this symbol (or stab offset) */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>代码中<code>n_strx</code>字段存储的就是符号在<code>String Table</code>的下标，符号表与符号的关系可用下图表示：</p>
<img src="http://182.92.228.41/wp-content/uploads/symbol_relation_table_symbol.png" width="600" align=center/>


<h4 id="四、重定位符号"><a href="#四、重定位符号" class="headerlink" title="四、重定位符号"></a>四、重定位符号</h4><p>概念理解：</p>
<ol>
<li>在链接生成<code>Mach-O</code>可执行文件之前，编译生成<code>.o</code>目标文件会对符号进行归类，而其中使用到的外部符号会暂存到重定位符号表中；</li>
<li>等到真正链接生成<code>Mach-O</code>文件时，这些符号会统一存到<code>Symbol Table</code>中；</li>
</ol>
<p>查看重定位符号的命令：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump <span class="operator">-</span>—macho <span class="operator">-</span>—reloc .o目标文件</span><br></pre></td></tr></table></figure>

<p>以下是验证过程：</p>
<h5 id="1-准备测试文件"><a href="#1-准备测试文件" class="headerlink" title="1.准备测试文件"></a>1.准备测试文件</h5><p>创建一个<code>main.m</code>文件，写入代码如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#<span class="keyword">import</span> &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char <span class="operator">*</span> argv[]) &#123;</span><br><span class="line">	<span class="type">NSLog</span>(@<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用命令分别生成<code>.o目标文件</code>与<code>Mach-O可执行文件</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xcrun clang <span class="operator">-</span>fmodules <span class="operator">-</span>c main.m <span class="operator">-</span>o main.o   <span class="comment">//得到目标文件</span></span><br><span class="line">xcrun clang main.o <span class="operator">-</span>o main  <span class="comment">//得到Mach-O可执行文件</span></span><br></pre></td></tr></table></figure>
<h5 id="2-对比-Text代码段"><a href="#2-对比-Text代码段" class="headerlink" title="2.对比__Text代码段"></a>2.对比__Text代码段</h5><p>使用<code>objdump</code>命令，分别查看目标文件与可执行文件中的<code>__TEXT</code>段，对比之下会发现：<code>前者</code>的符号调用<code>callq _NSLog</code>是没有地址的。</p>
<p>控制台中显示效果如下：<br><img src="http://182.92.228.41/wp-content/uploads/symbol_relocation_compare_text.png" width="600" align=center/></p>
<h5 id="3-查看重定位符号表"><a href="#3-查看重定位符号表" class="headerlink" title="3.查看重定位符号表"></a>3.查看重定位符号表</h5><img src="http://182.92.228.41/wp-content/uploads/symbol_relocation_check.png" width="600" align=center/>

<h5 id="4-重定位符号表中的字段说明"><a href="#4-重定位符号表中的字段说明" class="headerlink" title="4.重定位符号表中的字段说明"></a>4.重定位符号表中的字段说明</h5><img src="http://182.92.228.41/wp-content/uploads/symbol_relocation_table_desc.png" width="600" align=center/>


<h4 id="五、全局符号与本地符号"><a href="#五、全局符号与本地符号" class="headerlink" title="五、全局符号与本地符号"></a>五、全局符号与本地符号</h4><p>概念理解：</p>
<ul>
<li>全局符号：整个工程可见的符号；比如定义一个全局变量，所有文件都能访问到；</li>
<li>本地符号：只有当前文件可访问的符号，比如在当前文件中定义一个<code>static</code>修饰的变量；</li>
</ul>
<p>查看符号的命令：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump <span class="operator">--</span>macho <span class="operator">--</span>syms .o文件或<span class="type">Mach</span><span class="operator">-</span><span class="type">O文件</span></span><br></pre></td></tr></table></figure>

<h5 id="1-验证全局符号与本地符号"><a href="#1-验证全局符号与本地符号" class="headerlink" title="1. 验证全局符号与本地符号"></a>1. 验证全局符号与本地符号</h5><p>创建一个<code>main.m</code>文件，写入代码如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#<span class="keyword">import</span> &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">int global_init_value <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="keyword">static</span> int static_init_value <span class="operator">=</span> <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char <span class="operator">*</span> argv[]) &#123;</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;%d&quot;</span>, static_init_value);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用命令生成可执行文件，并查看符号，效果如下：<br><img src="http://182.92.228.41/wp-content/uploads/symbol_global_local.png" width="600" align=center/></p>
<p>第二列符号标签的含义：</p>
<ul>
<li><code>l</code>代表本地符号；</li>
<li><code>g</code>代表全局符号；</li>
</ul>
<p>第三列符号标签的含义，按照功能区分：</p>
<ul>
<li><code>f</code>：<code>File</code>，文件；</li>
<li><code>F</code>：<code>Function</code>，方法；</li>
<li><code>O</code>：	<code>Data</code>，数据；</li>
<li><code>d</code>：	<code>Debug</code>，调试符号（链接过程中，可通过<code>OTHER_LDFLAGS = -Xlinker -S</code>参数隐藏)；</li>
<li><code>ABS</code>：	<code>Absolute</code>；</li>
<li><code>COM</code>：	<code>Common</code>；</li>
<li><code>UND</code>：	未定义；</li>
</ul>
<h5 id="2-隐藏全局符号"><a href="#2-隐藏全局符号" class="headerlink" title="2. 隐藏全局符号"></a>2. 隐藏全局符号</h5><p>除了使用<code>static</code>修饰外，还有一种隐藏全局符号的方法，那就是使用<code>__attribute__</code>编译属性；</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((visibility(<span class="string">&quot;default&quot;</span>)))  <span class="comment">//默认</span></span><br><span class="line">__attribute__((visibility(<span class="string">&quot;hideen&quot;</span>)))  <span class="comment">//隐藏</span></span><br></pre></td></tr></table></figure>
<p><code>visibility</code>：用于设置动态链接库中函数的可见性，将变量或函数设置为<code>hidden</code>，则该符号仅在本文件中可见，在其他库中则不可见；</p>
<p>测试使用<code>__attribute__</code>编译属性修改<code>global_init_value</code>变量：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int global_init_value __attribute__((visibility(<span class="string">&quot;hidden&quot;</span>))) <span class="operator">=</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>重新使用命令生成<code>Mach-O可执行文件</code>，并查看符号，效果如下：<br><img src="http://182.92.228.41/wp-content/uploads/symbol_global_hide.png" width="600" align=center/></p>
<h4 id="六、导入符号和导出符号"><a href="#六、导入符号和导出符号" class="headerlink" title="六、导入符号和导出符号"></a>六、导入符号和导出符号</h4><p>概念理解：</p>
<ol>
<li>当前文件中使用到的<code>外部变量</code>、<code>外部方法</code>等，都属于其所属文件的导出符号；</li>
<li>导出符号一定是全局符号 ，将一个符号声明为全局，也就会默认成为导出符号，可供外界使用；</li>
<li><code>OC</code>中所有的符号都默认是导出符号；</li>
</ol>
<p>以<code>NSLog</code>为例：</p>
<ul>
<li>对于<code>Foundation</code>库来说，<code>NSLog</code>是提供外部使用的导出符号;</li>
<li>对于当前程序来说，<code>NSLog</code>使用的是从<code>Foundation</code>库中导入的符号;</li>
</ul>
<p>查看导出符号的命令：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump <span class="operator">--</span>macho <span class="operator">--</span>exports<span class="operator">-</span>trie .o文件或<span class="type">Mach</span><span class="operator">-</span><span class="type">O文件</span></span><br></pre></td></tr></table></figure>

<h5 id="1-验证导出符号"><a href="#1-验证导出符号" class="headerlink" title="1.验证导出符号"></a>1.验证导出符号</h5><p>在工程中创建一个空类<code>TestObject</code>，并在<code>main.m</code>文件中写入代码如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#<span class="keyword">import</span> &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">int global_init_value <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="keyword">static</span> int static_init_value <span class="operator">=</span> <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char <span class="operator">*</span> argv[]) &#123;</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;%d&quot;</span>, static_init_value);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为这里涉及多个文件，所以，测试时可以使用上节讲到<code>Mach-O</code>终端调试方法；</p>
<p>查看导出符号，结果如下：<br><img src="http://182.92.228.41/wp-content/uploads/symbol_export.png" width="600" align=center/></p>
<p>查看符号，结果如下：<br><img src="http://182.92.228.41/wp-content/uploads/symbol_export_check.png" width="600" align=center/><br>可以看出，导出符号正好与全局符号对应；</p>
<h5 id="2-设置符号不导出"><a href="#2-设置符号不导出" class="headerlink" title="2.设置符号不导出"></a>2.设置符号不导出</h5><p>全局符号不可剥离，但如果将其设置为不导出，符号就变成了本地符号类型了，不仅可以避免外界的错误使用，而且还可以脱符号处理，以减小<code>Mach-O</code>的体积；</p>
<p>为实现这一点，我们可以在自定义动态库时，在配置文件中增加链接器参数，具体如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例：OTHER_LDFLAGS =$(inherited) -Xlinker -unexported_symbol -Xlinker +符号名</span></span><br><span class="line"><span class="type">OTHER_LDFLAGS</span> <span class="operator">=</span>$(inherited) <span class="operator">-</span><span class="type">Xlinker</span> <span class="operator">-</span>unexported_symbol <span class="operator">-</span><span class="type">Xlinker</span> _OBJC_METACLASS_<span class="variable">$_TestObject</span></span><br><span class="line"><span class="type">OTHER_LDFLAGS</span> <span class="operator">=</span>$(inherited) <span class="operator">-</span><span class="type">Xlinker</span> <span class="operator">-</span>unexported_symbol <span class="operator">-</span><span class="type">Xlinker</span> _OBJC_CLASS_<span class="variable">$_TestObject</span></span><br></pre></td></tr></table></figure>
<p>再次查看导出符号，已经没有了<code>OC</code>类的导出符号，控制台显示结果如下：<br><img src="http://182.92.228.41/wp-content/uploads/symbol_export_hide.png" width="600" align=center/></p>
<p>需要注意：由于<code>OC</code>是运行时语言，所以，不能直接使用<code>visibility(&quot;hidden&quot;)</code>；</p>
<h5 id="3-查看Mach-O中使用的库以及符号信息，并生成文件"><a href="#3-查看Mach-O中使用的库以及符号信息，并生成文件" class="headerlink" title="3.查看Mach-O中使用的库以及符号信息，并生成文件"></a>3.查看Mach-O中使用的库以及符号信息，并生成文件</h5><p>在配置文件中，增加如下设置：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">OTHER_LDFLAGS</span> <span class="operator">=</span>$(inherited) <span class="operator">-</span><span class="type">Xlinker</span> <span class="operator">-</span><span class="type">S</span> <span class="operator">-</span><span class="type">Xlinker</span> <span class="operator">-</span>map <span class="operator">-</span><span class="type">Xlinker</span> $&#123;<span class="type">SRCROOT</span>&#125;<span class="operator">/</span><span class="type">MachOTest_Symbol</span>.text</span><br></pre></td></tr></table></figure>
<p>运行工程后将生成的文件，文件中包含以下信息：</p>
<ol>
<li>编译过程中生成的目标文件；</li>
<li>项目中使用的三方库；</li>
<li>项目中的<code>Sections</code>和<code>Symbols</code>等信息；</li>
</ol>
<h4 id="七、间接符号-Indirect-Symbol"><a href="#七、间接符号-Indirect-Symbol" class="headerlink" title="七、间接符号(Indirect Symbol)"></a>七、间接符号(Indirect Symbol)</h4><p>概念理解：</p>
<ol>
<li>间接符号就是使用的外部符号，例如：使用的系统库、外部动态库符号；</li>
<li>间接符号表中保存当前可执行文件使用的其他的动态库的符号；</li>
</ol>
<p>查看间接符号的命令：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CMD</span> <span class="operator">=</span> objdump <span class="operator">--</span>macho <span class="operator">--</span><span class="keyword">indirect</span><span class="operator">-</span>symbols .o文件或<span class="type">Mach</span><span class="operator">-</span><span class="type">O文件</span></span><br></pre></td></tr></table></figure>

<p>验证间接符号，在<code>main.m</code>文件中写入代码如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#<span class="keyword">import</span> &lt;Foundation/Foundation.h&gt;</span><br><span class="line">int main(int argc, const char <span class="operator">*</span> argv[]) &#123;</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查看间接符号，效果如下：<br><img src="http://182.92.228.41/wp-content/uploads/symbol_indirect_symbol.png" width="600" align=center/><br>可以看到，<code>NSLog</code>就是间接符号，它属于<code>Foundation</code>动态库：</p>
<ul>
<li><code>adress</code>：表示间接符号链接地址；</li>
<li><code>name</code>：符号名；</li>
</ul>
<h4 id="八、弱符号-Weak-Symbol"><a href="#八、弱符号-Weak-Symbol" class="headerlink" title="八、弱符号(Weak Symbol)"></a>八、弱符号(Weak Symbol)</h4><p><code>Weak Reference Symbol</code>: 表示此未定义符号是弱引用；</p>
<ol>
<li>如果动态链接器找不到该符号的定义，则将其设置为<code>0</code>；</li>
<li>链接器会将此符号设置弱链接标志；</li>
</ol>
<p><code>Weak defintion Symbol</code>: 表示此符号为弱定义符号</p>
<ol>
<li>如果静态链接器或动态链接器为此符号找到另一个(非弱)定义，则弱定义将被忽略；</li>
<li>只能将合并部分中的符号标记为弱定义；</li>
</ol>
<h5 id="1-验证弱引用符号"><a href="#1-验证弱引用符号" class="headerlink" title="1.验证弱引用符号"></a>1.验证弱引用符号</h5><p>对于弱引用符号，更确切的理解是：如果未被定义(没有实现)，系统不会报错；</p>
<p>创建<code>WeakImportSymbol.h/m</code>文件，但只在其<code>.h</code>文件中定义一个没有实现体的弱引用方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void weak_import_function(void) __attribute__((weak_import));</span><br></pre></td></tr></table></figure>

<p>然后，在<code>main.m</code>中增加如下的代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#<span class="keyword">import</span> &quot;WeakImportSymbol.h&quot;</span><br><span class="line">int main(int argc, char <span class="operator">*</span>argv[]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (weak_import_function) &#123;</span><br><span class="line">        weak_import_function();</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时运行报错：<code>Undefined symbol: _weak_import_function</code>，因为链接时需要知道符号具体的地址在什么地方，否则就会提示错误；</p>
<p>解决方法：可以通过配置文件告诉编译器，这个符号是动态链接的，<code>dyld</code>运行时会自动查找；</p>
<p>于是，我们在配置文件中增加的配置如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// -U参数：告诉编译器该符号没有定义，需要动态查找</span></span><br><span class="line"><span class="type">OTHER_LDFLAGS</span> <span class="operator">=</span>$(inherited) <span class="operator">-</span><span class="type">Xlinker</span> <span class="operator">-</span><span class="type">U</span> <span class="operator">-</span><span class="type">Xlinker</span> _weak_import_function</span><br></pre></td></tr></table></figure>

<p><code>Weak Reference Symbol</code>的好处：</p>
<ol>
<li>可以判断其他的库是否有这个符号，如果有这个符号就可以调用，否则就不调用；</li>
<li>可以将整个动态库文件声明成一个弱引用，也意味着如果你这个库没有导入的话，也不会报动态库找不到的错误；</li>
</ol>
<h5 id="2-验证弱定义符号"><a href="#2-验证弱定义符号" class="headerlink" title="2.验证弱定义符号"></a>2.验证弱定义符号</h5><p>创建<code>WeakSymbol.h/m</code>文件，增加代码如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// WeakSymbol.h</span></span><br><span class="line">int global_int_value</span><br><span class="line">void weak_function(void);</span><br><span class="line"></span><br><span class="line"><span class="comment">/// WeakSymbol.m</span></span><br><span class="line">void weak_function(void) &#123;</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;weak_function&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，在<code>main.m</code>中增加如下的代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#<span class="keyword">import</span> &quot;WeakSymbol.h&quot;</span><br><span class="line"></span><br><span class="line">int global_int_value;</span><br><span class="line"></span><br><span class="line">void weak_function(void) &#123;</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;weak_function_main&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char <span class="operator">*</span>argv[]) &#123;</span><br><span class="line">    weak_function();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时运行报错：<code>2 duplicate symbols for architecture x86_64</code>；</p>
<p>解决方法：将任意一个文件中的全局变量声明为<code>弱定义符号</code>，这样在链接的过程<br> 中，找到符号的另一个(非弱)定义，则弱定义将被忽略，从而避免符号重定义；</p>
<p>于是，我们修改<code>WeakSymbol.h</code>中的代码如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int global_int_value __attribute__((<span class="keyword">weak</span>));</span><br><span class="line">void weak_function(void)  __attribute__((<span class="keyword">weak</span>));</span><br></pre></td></tr></table></figure>
<p>运行工程后，成功打印结果：<code>weak_function_main</code>；</p>
<h5 id="3-弱定义的本地符号"><a href="#3-弱定义的本地符号" class="headerlink" title="3.弱定义的本地符号"></a>3.弱定义的本地符号</h5><p>将弱定义的符号声明成一个隐藏符号，它就会变成了一个弱定义的本地符号：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void weak_hidden_function(void) __attribute__((<span class="keyword">weak</span>, visibility(<span class="string">&quot;hidden&quot;</span>)));</span><br></pre></td></tr></table></figure>


<h4 id="九、未初始化的全局符号-Common-Symbol"><a href="#九、未初始化的全局符号-Common-Symbol" class="headerlink" title="九、未初始化的全局符号(Common Symbol)"></a>九、未初始化的全局符号(Common Symbol)</h4><p>概念理解：在定义时未初始化的全局符号；</p>
<p>符号作用：</p>
<ol>
<li>在编译和链接的过程中，如果找到定义的符号，会自动将未定义符号删掉；</li>
<li>在链接过程中，链接器默认会把未定义符号变成强制定义的符号；</li>
</ol>
<p>链接器设置：</p>
<ul>
<li><code>-d</code>：强制定义<code>Common Symbol</code>；</li>
<li><code>-commons</code>：指定对待<code>Common Symbol</code>如何响应；</li>
</ul>
<h5 id="1-查看Common-Symbol"><a href="#1-查看Common-Symbol" class="headerlink" title="1.查看Common Symbol"></a>1.查看Common Symbol</h5><p>在<code>main.m</code>文件，写入代码如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int global_uninit_value;</span><br><span class="line"></span><br><span class="line">int main(int argc, char <span class="operator">*</span>argv[]) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查看符号表，控制台显示如下：<br><img src="http://182.92.228.41/wp-content/uploads/symbol_common_symbol.png" width="600" align=center/></p>
<h5 id="2-验证Common-Symbol的作用"><a href="#2-验证Common-Symbol的作用" class="headerlink" title="2.验证Common Symbol的作用"></a>2.验证Common Symbol的作用</h5><p>在<code>main.m</code>文件，写入代码如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int global_init_value <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">int global_init_value;</span><br><span class="line"></span><br><span class="line">int main(int argc, char <span class="operator">*</span>argv[]) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查看符号表，控制台显示如下：<br><img src="http://182.92.228.41/wp-content/uploads/symbol_common_symbol_check.png" width="600" align=center/></p>
<h4 id="十、重新导出符号"><a href="#十、重新导出符号" class="headerlink" title="十、重新导出符号"></a>十、重新导出符号</h4><p>概念理解：</p>
<ol>
<li>重新导出符号就是通过对间接符号起别名的方式，将其变成导出符号；</li>
<li>重新导出之后的符号会放在本文件的导出符号表中，此时外界究竟可以查看使用这个符号了；</li>
<li>重新导出符号可以让一个<code>符号</code>可见，也可以让一个<code>动态库</code>可见；</li>
</ol>
<p>举例：当程序链接<code>动态库A</code>，而<code>动态库A</code>又链接<code>动态库B</code>时，<code>动态库B</code>对于程序来说是不可见的，此时就可以使用重新导出符号的方式，使<code>动态库B</code>对程序可见；</p>
<h5 id="2-验证重新导出NSLog"><a href="#2-验证重新导出NSLog" class="headerlink" title="2.验证重新导出NSLog"></a>2.验证重新导出NSLog</h5><p>其实，<code>Foundation</code>已经对<code>NSLog</code>做了重新导出，否则外界是无法使用的；</p>
<p>查看当前符号表，可以看到，<code>NSLog</code>对于当前工程来说还是一个未定义符号：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000000000000000</span>         <span class="operator">*</span><span class="type">UND</span><span class="operator">*</span> _NSLog</span><br></pre></td></tr></table></figure>
<p>现在，我们尝试自己重新导出<code>NSLog</code>符号，可以在配置文件中修改链接器中的参数<code>-alias(起别名)</code>，具体的配置如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">OTHER_LDFLAGS</span> <span class="operator">=</span> $(inherited) <span class="operator">-</span><span class="type">Xlinker</span> <span class="operator">-</span>alias <span class="operator">-</span><span class="type">Xlinker</span> _NSLog <span class="operator">-</span><span class="type">Xlinker</span> <span class="type">ZS_NSLog</span></span><br></pre></td></tr></table></figure>
<p>再次查看符号表，此时将看到<code>ZS_NSLog</code>成为导出符号，而且被标记为<code>re-export</code>；</p>
<h4 id="十一、Swift符号"><a href="#十一、Swift符号" class="headerlink" title="十一、Swift符号"></a>十一、Swift符号</h4><p>创建一个<code>SwiftSymbol.swift</code>文件，在其中增加代码如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">PrivateObject</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">testMethod</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PublicObject</span>&#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">testMethod</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查看当前符号表，控制台的效果如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0000000100003bb0 l     <span class="type">F</span> __TEXT,__text <span class="keyword">_</span><span class="variable">$s9MachOTest13PrivateObject33_C45E5A1705242B42AFDE1C0627FBB932LLC10testMethodyyF</span></span><br><span class="line"></span><br><span class="line"><span class="operator">....</span></span><br><span class="line">0000000100003c80 g     <span class="type">F</span> __TEXT,__text <span class="keyword">_</span><span class="variable">$s9MachOTest12PublicObjectC10testMethodyyF</span></span><br></pre></td></tr></table></figure>
<p>结果分析：</p>
<ol>
<li><code>Swift</code>文件产生的符号要比<code>OC</code>文件多出很多；</li>
<li>作为访问控制修饰符的<code>public</code>、<code>private</code>，分别对应着去全局符号(<code>g</code>)、本地符号(<code>l</code>)两种类型；</li>
</ol>
<h4 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h4><ol>
<li><a target="_blank" rel="noopener" href="https://sourceforge.net/projects/machoview/">MachView软件下载地址</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/DreamcoffeeZS/TestProjects/tree/main/01.MachO%E4%B8%8E%E7%AC%A6%E5%8F%B7">文中相关Demo下载地址</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wuyubeichen.github.io/2021/11/04/iOS%E9%AB%98%E7%BA%A7-MachO%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Author">
      <meta itemprop="description" content="iOS Developer, Beijing China">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="梧雨北辰的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/04/iOS%E9%AB%98%E7%BA%A7-MachO%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">iOS高级-MachO简单分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-11-04 22:23:12" itemprop="dateCreated datePublished" datetime="2021-11-04T22:23:12+08:00">2021-11-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-29 09:39:32" itemprop="dateModified" datetime="2022-08-29T09:39:32+08:00">2022-08-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS%E9%AB%98%E7%BA%A7/" itemprop="url" rel="index"><span itemprop="name">iOS高级</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>主要内容：</strong></p>
<ol>
<li><code>Mach-O</code>的读写特性</li>
<li>查看命令文档</li>
<li>查看<code>Mach-O</code></li>
<li>查看<code>Symbol</code></li>
<li>配置<code>Mach-O</code>终端调试工具</li>
</ol>
<h4 id="一、Mach-O的读写特性"><a href="#一、Mach-O的读写特性" class="headerlink" title="一、Mach-O的读写特性"></a>一、Mach-O的读写特性</h4><p><code>Mach-O</code>文件其实等价于： <code>文件配置 + 二进制代码</code>；</p>
<p><code>Mach-O</code>文件是可读可写的，分析<code>Mach-O</code>文件的结构，可以解释程序运行中的许多问题；</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a9d64afd74384beaa9e32663f3857dfc~tplv-k3u1fbpfcp-watermark.image" alt="MachO-简化结构.png"></p>
<h5 id="1-Mach-O可读"><a href="#1-Mach-O可读" class="headerlink" title="1. Mach-O可读"></a>1. Mach-O可读</h5><ol>
<li><code>Header</code>：提供读取所需的身份信息，包括<code>CPU类型</code>、<code>文件类型</code>等；</li>
<li><code>Load Commands</code>：提供读取所需的文件的信息，以<code>Load Command _TEXT</code>为例，其中记录有<ol>
<li><code>_TEXT</code>代码段的起始位置；</li>
<li><code>_TEXT</code>代码段的大小；</li>
</ol>
</li>
<li><code>__TEXT</code>,<code>__DATA</code>,<code>符号表</code>等，这些都是代码编译后的文件、数据存放的位置；</li>
</ol>
<h5 id="2-Mach-O可写"><a href="#2-Mach-O可写" class="headerlink" title="2.Mach-O可写"></a>2.Mach-O可写</h5><ol>
<li><code>Mach-O</code>能被执行是因为有签名，当我们修改了<code>Mach-O</code>文件，需要重新签名才能被苹果系统所接受；</li>
<li>破解软件都需要重新签名，正是这种原因；</li>
</ol>
<h4 id="二、查看命令文档"><a href="#二、查看命令文档" class="headerlink" title="二、查看命令文档"></a>二、查看命令文档</h4><p>有时候，需要在终端查询一些命令的具体用法，有两种方式(以查询<code>nm</code>命令为例)：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">man nm      <span class="comment">//推荐使用</span></span><br><span class="line">nm <span class="operator">--</span>help   </span><br></pre></td></tr></table></figure>

<p>当终端里显示<code>nm</code>的使用文档后，还可快速定位查询，以查询<code>&quot;-a&quot;</code>参数为例：</p>
<ul>
<li><code>/-a</code>：快速匹配文档中<code>-a</code>的位置；</li>
<li><code>n</code>：向下定位<code>-a</code>位置；</li>
<li><code>N</code>：向上定位<code>-a</code>位置；</li>
<li><code>q</code>：退出文档查看；</li>
</ul>
<h4 id="三、查看Mach-O"><a href="#三、查看Mach-O" class="headerlink" title="三、查看Mach-O"></a>三、查看Mach-O</h4><h5 id="1-常用的查看命令"><a href="#1-常用的查看命令" class="headerlink" title="1.常用的查看命令"></a>1.常用的查看命令</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查看Header（$&#123;MACH_PATH&#125;表示Mach-O文件位置）</span></span><br><span class="line">objdump <span class="operator">--</span>macho <span class="operator">--</span><span class="keyword">private</span><span class="operator">-</span>header $&#123;<span class="type">MACH_PATH</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看Header 和 Load commands</span></span><br><span class="line">objdump <span class="operator">--</span>macho <span class="operator">--</span><span class="keyword">private</span><span class="operator">-</span>headers $&#123;<span class="type">MACH_PATH</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看__TEXT</span></span><br><span class="line">objdump <span class="operator">--</span>macho <span class="operator">-</span>d $&#123;<span class="type">MACH_PATH</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看符号表</span></span><br><span class="line">objdump <span class="operator">--</span>macho <span class="operator">--</span>syms $&#123;<span class="type">MACH_PATH</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看导出符号</span></span><br><span class="line">objdump <span class="operator">--</span>macho <span class="operator">--</span>exports<span class="operator">-</span>trie $&#123;<span class="type">MACH_PATH</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看间接符号表</span></span><br><span class="line">objdump <span class="operator">--</span>macho <span class="operator">--</span><span class="keyword">indirect</span><span class="operator">-</span>symbols $&#123;<span class="type">MACH_PATH</span>&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-测试查看命令"><a href="#2-测试查看命令" class="headerlink" title="2.测试查看命令"></a>2.测试查看命令</h5><p>为了避免过多文件的干扰，创建测试工程时，选择选择<code>MacOS</code> -&gt;<code>Command Line Tool</code>；</p>
<p>进入工程后，在<code>main.m</code>文件中写入代码如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#<span class="keyword">import</span> &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">int global_init_value <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="keyword">static</span> int static_init_value <span class="operator">=</span> <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char <span class="operator">*</span> argv[]) &#123;</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;%d&quot;</span>, static_init_value);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Xcode</code>运行成功后，<code>Products</code>下的黑色文件即<code>Mach-O可执行文件</code>，如下图：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/71a980af83aa4486889b61d4afbec224~tplv-k3u1fbpfcp-watermark.image" alt="MachO-可执行文件位置.png"></p>
<p>切换到可执行文件的目录下，使用<code>objdump</code>命令，查看<code>Header</code>:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump <span class="operator">--</span>macho <span class="operator">--</span><span class="keyword">private</span><span class="operator">-</span>header <span class="type">MachOTest</span></span><br></pre></td></tr></table></figure>

<p>终端的打印结果如下：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5a50badce80f40c4b20043043fef1a14~tplv-k3u1fbpfcp-watermark.image" alt="objdump-查看Header.png"></p>
<p>使用<code>objdump</code>命令，查看<code>Header</code>以及<code>Load commands</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump <span class="operator">--</span>macho <span class="operator">--</span><span class="keyword">private</span><span class="operator">-</span>headers <span class="type">MachOTest</span></span><br></pre></td></tr></table></figure>

<p>终端的打印结果如下：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/166474471e0a4d969591eb433827d636~tplv-k3u1fbpfcp-watermark.image" alt="objdump-查看Header&amp;Commands.png"></p>
<p>如上，我们在<code>Mach-O</code>文件的<code>Load Commands</code>中，可以找到<code>程序入口函数</code>以及<code>依赖系统动态库</code>的相关信息；</p>
<h4 id="四、查看Symbol"><a href="#四、查看Symbol" class="headerlink" title="四、查看Symbol"></a>四、查看Symbol</h4><p>查看符号，除了可以使用<code>objdump</code>命令以外，还可以使用<code>nm</code>命令；</p>
<h5 id="1-nm命令简介"><a href="#1-nm命令简介" class="headerlink" title="1.nm命令简介"></a>1.nm命令简介</h5><ol>
<li><code>nm</code>是<code>name</code>的缩写，它显示指定文件中的符号信息，文件可以是对象文件、可执行文件或对象文件库；</li>
<li>如果文件中没有包含符号信息，<code>nm</code>报告该情况，但不把他解释为出错；</li>
<li><code>nm</code>缺省情况下报告十进制符号表示法下的数字值；</li>
</ol>
<p>可以在终端使用<code>man nm</code>命令查看其具体用法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">%</span> man nm</span><br><span class="line">nm <span class="operator">-</span> display name list (symbol table)</span><br></pre></td></tr></table></figure>

<p>即，<code>nm</code>是一个可以查看展示符号表信息的命令。</p>
<h5 id="2-常用命令参数"><a href="#2-常用命令参数" class="headerlink" title="2.常用命令参数"></a>2.常用命令参数</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">-</span>a <span class="comment">//显示符号表所有内容</span></span><br><span class="line"><span class="operator">-</span>p <span class="comment">//不排序，显示符号本来的顺序</span></span><br><span class="line"><span class="operator">-</span>g <span class="comment">//显示全局符号</span></span><br><span class="line"><span class="operator">-</span>r <span class="comment">//逆转排序</span></span><br><span class="line"><span class="operator">-</span>u <span class="comment">//显示未定义符号</span></span><br><span class="line"><span class="operator">-</span>m <span class="comment">//显示N_SECT类型的符号(Mach-O符号)显示</span></span><br></pre></td></tr></table></figure>

<h5 id="3-使用举例"><a href="#3-使用举例" class="headerlink" title="3.使用举例"></a>3.使用举例</h5><p>使用<code>nm</code>命令，查看<code>MachO</code>可执行文件中的符号：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nm <span class="operator">-</span>pa $&#123;<span class="type">MACH_PATH</span>&#125;</span><br></pre></td></tr></table></figure>

<p>终端的打印结果如下：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4ba8fff296804a5180a7ec427f862bf0~tplv-k3u1fbpfcp-watermark.image" alt="nm-查看符号.png"></p>
<p>其中，第二列符号标签的含义如下：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0df1fe934d0943beb02b34a2da3a2df5~tplv-k3u1fbpfcp-watermark.image" alt="nm-符号类型.png"></p>
<p>注：标记<code>①</code>的<code>Type</code>，⼩写代表本地符号(<code>local symbol</code>);</p>
<h4 id="五、配置Mach-O终端测试工具"><a href="#五、配置Mach-O终端测试工具" class="headerlink" title="五、配置Mach-O终端测试工具"></a>五、配置Mach-O终端测试工具</h4><p>如上的调试过程十分繁琐，每次都需要等到程序运行完成，然后再切换到终端测试命令。为了更方便分析<code>Mach-O</code>，这里可以对工程进一步配置，使其运行时可直接将结果打印在终端里，具体的步骤如下：</p>
<h5 id="1-测试将Xcode打印重定向到终端"><a href="#1-测试将Xcode打印重定向到终端" class="headerlink" title="1.测试将Xcode打印重定向到终端"></a>1.测试将Xcode打印重定向到终端</h5><p>1.新建一个终端，使用<code>tty</code>命令获取其标识位置：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1a6712973a5b484ea17dd1a96e79a31e~tplv-k3u1fbpfcp-watermark.image" alt="TTYDemo-获取终端位置.png"></p>
<p>2.在<code>Xcode</code>中依次打开: <code>Build Phases</code> -&gt;<code>Run Script</code>，输入脚本命令使其能够在运行时打印：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f992f9d1db0c4b808ed2493246f1372d~tplv-k3u1fbpfcp-watermark.image" alt="TTYDemo-配置RunScript.png"></p>
<p>3.运行工程，可以看到终端的打印如下</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/72c865804e78457b9a27a54a2e36b31b~tplv-k3u1fbpfcp-watermark.image" alt="TTYDemo-测试RunScript.png"></p>
<h5 id="2-测试Xcode脚本命令执行项目中的代码"><a href="#2-测试Xcode脚本命令执行项目中的代码" class="headerlink" title="2.测试Xcode脚本命令执行项目中的代码"></a>2.测试Xcode脚本命令执行项目中的代码</h5><p>虽然成功打印信息到终端，但是<code>&quot;Hello world&quot;</code>这段信息却是固定的，为了动态获取执行参数，我们可以自定义配置文件，并在其中定义如下的参数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DEBUG_URL</span> <span class="operator">=</span> www.debug.com</span><br></pre></td></tr></table></figure>

<p>然后，修改<code>Run Script</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="string">&quot;Hello World&quot;</span> <span class="operator">&gt;</span> <span class="operator">/</span>dev<span class="operator">/</span>ttys000</span><br><span class="line">echo $&#123;<span class="type">DEBUG_URL</span>&#125; <span class="operator">&gt;</span> <span class="operator">/</span>dev<span class="operator">/</span>ttys000</span><br></pre></td></tr></table></figure>

<p>终端打印结果：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Hello</span> <span class="type">World</span></span><br><span class="line">www.debug.com</span><br></pre></td></tr></table></figure>

<p>这里就说明，<code>Xcode</code>脚本执行与配置文件是在同一个环境下，我们可以做到将配置文件中的各种参数传递给脚本中使用。</p>
<h5 id="3-实现通过脚本命令打印符号信息"><a href="#3-实现通过脚本命令打印符号信息" class="headerlink" title="3. 实现通过脚本命令打印符号信息"></a>3. 实现通过脚本命令打印符号信息</h5><p>在具备以上条件后，可以实现通过脚本命令打印符号信息到终端，具体的做法如下：</p>
<p>将执行命令的操作定义在一个脚本文件中，并起名<code>xcode_run_cmd.sh</code>，其中的关键代码如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RunCMDToTTY</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> [[ <span class="operator">!</span> <span class="operator">-</span>e <span class="string">&quot;$TTY&quot;</span> ]]; then</span><br><span class="line">        <span class="type">EchoError</span> <span class="string">&quot;=======================&quot;</span></span><br><span class="line">        <span class="type">EchoError</span> <span class="string">&quot;ERROR: Not Config tty to output.&quot;</span></span><br><span class="line">        exit <span class="operator">-</span><span class="number">1</span></span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> [[ <span class="operator">-</span>n <span class="string">&quot;$CMD&quot;</span> ]]; then</span><br><span class="line">        <span class="type">RunCommand</span> <span class="string">&quot;$CMD&quot;</span> $&#123;<span class="type">CMD_FLAG</span>&#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="type">EchoError</span> <span class="string">&quot;========================&quot;</span></span><br><span class="line">        <span class="type">EchoError</span> <span class="string">&quot;ERROR:Failed to run CMD. THE CMD must not null&quot;</span></span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">EchoError</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> [[ <span class="operator">-</span>n <span class="string">&quot;$TTY&quot;</span> ]]; then</span><br><span class="line">        echo <span class="string">&quot;$@&quot;</span> <span class="number">1</span><span class="operator">&gt;&amp;</span><span class="number">2</span><span class="operator">&gt;</span><span class="variable">$TTY</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        echo <span class="string">&quot;$@&quot;</span> <span class="number">1</span><span class="operator">&gt;&amp;</span><span class="number">2</span></span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">RunCommand</span>() &#123;</span><br><span class="line">  <span class="keyword">if</span> [[ <span class="operator">-</span>n <span class="string">&quot;$VERBOSE_SCRIPT_LOGGING&quot;</span> ]]; then</span><br><span class="line">      <span class="keyword">if</span> [[ <span class="operator">-</span>n <span class="string">&quot;$TTY&quot;</span> ]]; then</span><br><span class="line">          echo <span class="string">&quot;♦ $@&quot;</span> <span class="number">1</span><span class="operator">&gt;</span><span class="variable">$TTY</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">          echo <span class="string">&quot;♦ $*&quot;</span></span><br><span class="line">      fi</span><br><span class="line">      echo <span class="string">&quot;-----------------------------------------&quot;</span> <span class="number">1</span><span class="operator">&gt;</span><span class="variable">$TTY</span></span><br><span class="line">  fi</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> [[ <span class="operator">-</span>n <span class="string">&quot;$TTY&quot;</span> ]]; then</span><br><span class="line">      echo `$@ <span class="operator">&amp;&gt;</span><span class="variable">$TTY</span>`</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">      <span class="string">&quot;$@&quot;</span></span><br><span class="line">  fi</span><br><span class="line">  <span class="keyword">return</span> $<span class="operator">?</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">RunCMDToTTY</span></span><br></pre></td></tr></table></figure>

<p>然后，在配置文件里增加三个参数：<code>CMD</code>，<code>CMD_FLAG</code>，<code>TTY</code>，即需要在.<code>xcconfig</code>中进行定义:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Config-TestProject.debug.xcconfig</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// DEBUG_URL = www.debug.com</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// MACHO_PATH：Mach-O文件路径，即可执行文件路径，这里用到了环境变量来表示具体路径</span></span><br><span class="line"><span class="comment">// TTY = 终端位置标识</span></span><br><span class="line"><span class="comment">// CMD：运行命令</span></span><br><span class="line"><span class="comment">// CMD_FLAG = 命令参数</span></span><br><span class="line"></span><br><span class="line"><span class="type">MACHO_PATH</span> <span class="operator">=</span> $&#123;<span class="type">BUILD_DIR</span>&#125;<span class="operator">/</span>$(<span class="type">CONFIGURATION</span>)$(<span class="type">EFFECTIVE_PLATFORM_NAME</span>)<span class="operator">/</span>$&#123;<span class="type">PRODUCT_NAME</span>&#125;.app<span class="operator">/</span>$&#123;<span class="type">PRODUCT_NAME</span>&#125;</span><br><span class="line"><span class="type">TTY</span> <span class="operator">=</span> <span class="operator">/</span>dev<span class="operator">/</span>ttys000</span><br><span class="line"><span class="type">CMD</span> <span class="operator">=</span> nm</span><br><span class="line"><span class="type">CMD_FLAG</span> <span class="operator">=</span> <span class="operator">-</span>pa $&#123;<span class="type">MACHO_PATH</span>&#125;</span><br></pre></td></tr></table></figure>

<p>配置完成后的工程如下：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ea2322ca186a45308e88b39fe840514e~tplv-k3u1fbpfcp-watermark.image" alt="TTYDemo-配置文件.png"></p>
<p>最后，我们需要更改<code>Run Script</code>指令，使其执行脚本文件：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c1a81edf316474bbcc0b5107869a7bd~tplv-k3u1fbpfcp-watermark.image" alt="TTYDemo-配置脚本Script.png"></p>
<p>此时，再次运行项目，就可以直接在控制台看到使用<code>nm</code>命令分析得到的<code>Mach-O</code>信息了，而且我们可以更换<code>CMD</code>，<code>CMD_FLAG</code>参数，用以调试更多的其他命令。</p>
<h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><ol>
<li><a target="_blank" rel="noopener" href="https://github.com/DreamcoffeeZS/TestProjects.git">文中演示使用的Demo仓库</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wuyubeichen.github.io/2021/11/03/iOS%E9%AB%98%E7%BA%A7-MachO%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Author">
      <meta itemprop="description" content="iOS Developer, Beijing China">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="梧雨北辰的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/03/iOS%E9%AB%98%E7%BA%A7-MachO%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/" class="post-title-link" itemprop="url">iOS高级-MachO文件结构</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-11-03 22:57:35" itemprop="dateCreated datePublished" datetime="2021-11-03T22:57:35+08:00">2021-11-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-29 09:39:32" itemprop="dateModified" datetime="2022-08-29T09:39:32+08:00">2022-08-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS%E9%AB%98%E7%BA%A7/" itemprop="url" rel="index"><span itemprop="name">iOS高级</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>主要内容：</strong></p>
<ol>
<li>理解可执行文件</li>
<li>理解<code>Mach-O</code>文件</li>
<li><code>Mach-O</code>文件结构</li>
<li><code>Mach Header</code></li>
<li><code>Load Commands</code></li>
<li><code>Data</code></li>
<li>理解大小端模式</li>
<li>理解通用二进制文件</li>
</ol>
<h4 id="一、理解可执行文件"><a href="#一、理解可执行文件" class="headerlink" title="一、理解可执行文件"></a>一、理解可执行文件</h4><h5 id="1-可执行文件"><a href="#1-可执行文件" class="headerlink" title="1.可执行文件"></a>1.可执行文件</h5><ol>
<li><code>进程</code>，其实就是<code>可执行文件</code>在内存中加载得到的结果；</li>
<li><code>可执行文件</code>必须是操作系统可理解的格式，而且不同系统的<code>可执行文件</code>的格式也是不同的；</li>
</ol>
<h5 id="2-不同平台的可执行文件"><a href="#2-不同平台的可执行文件" class="headerlink" title="2.不同平台的可执行文件"></a>2.不同平台的可执行文件</h5><ul>
<li><code>Linux：ELF</code>文件</li>
<li><code>Windows</code>：<code>PE32／PE32+</code>文件</li>
<li><code>OS和iOS</code>：<code>Mach-O(Mach Object)</code>文件</li>
</ul>
<h4 id="二、理解Mach-O文件"><a href="#二、理解Mach-O文件" class="headerlink" title="二、理解Mach-O文件"></a>二、理解Mach-O文件</h4><p>作为<code>iOS</code>，<code>iPadOS</code>、<code>macOS</code>平台的可执行文件格式，<code>Mach-O</code>文件涉及App启动运行、<code>bitcode</code>分析、 <code>crash</code>符号化等诸多多个功能：</p>
<h5 id="1-Mach-O文件"><a href="#1-Mach-O文件" class="headerlink" title="1. Mach-O文件"></a>1. Mach-O文件</h5><ol>
<li><code>Mach-O</code>文件是<code>iOS</code>，<code>iPadOS</code>、<code>macOS</code>平台的可执行文件格式。对应系统通过应用二进制接口(<code>application binary interface</code>，缩写为<code>ABI</code>)来运行该格式的文件；</li>
<li><code>Mach-O</code>格式用来替代<code>BSD</code>系统中的<code>a.out</code>格式，保存了在编译和链接过程中产生的<code>机器代码和数据</code>，从而为静态链接和动态链接的代码提供单一文件格式。</li>
<li><code>Mach-O</code>提供了更强的扩展性，以及更快的符号表信息访问速度；</li>
</ol>
<h5 id="2-Mach-O格式的常见文件类型"><a href="#2-Mach-O格式的常见文件类型" class="headerlink" title="2.Mach-O格式的常见文件类型"></a>2.Mach-O格式的常见文件类型</h5><ol>
<li><code>Executable</code>：可执行文件(<code>.out</code> <code>.o</code>)；</li>
<li><code>Dylib</code>：动态链接库；</li>
<li><code>Bundle</code>：不能被链接，只能在运行时使用<code>dlopen()</code>加载；</li>
<li><code>Image</code>：包含<code>Executable</code>、<code>Dylib</code>和<code>Bundle</code>；</li>
<li><code>Framework</code>：包含<code>Dylib</code>、资源文件和头文件的文件夹；</li>
</ol>
<h4 id="三、Mach-O文件结构"><a href="#三、Mach-O文件结构" class="headerlink" title="三、Mach-O文件结构"></a>三、Mach-O文件结构</h4><h5 id="1-查看Mach-O的两种方法"><a href="#1-查看Mach-O的两种方法" class="headerlink" title="1.查看Mach-O的两种方法"></a>1.查看Mach-O的两种方法</h5><ol>
<li>使用<code>MachOView</code>软件，可直接查看<code>MachO</code>文件的结构；</li>
<li>使用终端命令<code>objdump</code>；</li>
</ol>
<h5 id="2-查看Mach-O文件结构"><a href="#2-查看Mach-O文件结构" class="headerlink" title="2.查看Mach-O文件结构"></a>2.查看Mach-O文件结构</h5><p>使用<code>MachOView</code>查看<code>Mach-O</code>，效果如下：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4a8b3e13b48e48bb8896b325d4b2bf82~tplv-k3u1fbpfcp-watermark.image" alt="MachO-文件结构2.png"></p>
<p><code>Mach-O</code>文件中包含三个主要的部分：</p>
<ol>
<li><code>Header</code>：头部，描述<code>CPU</code>类型、文件类型、加载命令的条数大小等信息；</li>
<li><code>Load Commands</code>：加载命令，其条数和大小已经在<code>header</code>中被提供；</li>
<li><code>Data</code>：数据段；</li>
</ol>
<p>其他的信息还有：</p>
<ol>
<li><code>Dynamic Loader Info</code>：动态库加载信息</li>
<li><code>Function Starts</code>：入口函数</li>
<li><code>Symbol Table</code>：符号表</li>
<li><code>Dynamic Symbol Table</code>： 动态库符号表</li>
<li><code>String Table</code>：字符串表</li>
</ol>
<h4 id="四、Mach-Header-可执行文件头"><a href="#四、Mach-Header-可执行文件头" class="headerlink" title="四、Mach Header(可执行文件头)"></a>四、Mach Header(可执行文件头)</h4><h5 id="1-功能总结"><a href="#1-功能总结" class="headerlink" title="1.功能总结"></a>1.功能总结</h5><ol>
<li><code>Header</code>是链接器加载时最先读取的内容，因为它决定了一些<code>基础架构</code>、<code>系统类型</code>等信息；</li>
<li><code>Header</code>包含整个<code>Mach-O</code>文件的关键信息，如<code>CPU类型</code>、<code>文件类型</code>、<code>加载命令的条数大小</code>等信息，使得系统能够迅速定位<code>Mach-O</code>文件的运行环境；</li>
<li><code>Header</code>针对<code>32</code>位和<code>64</code>位架构的<code>CPU</code>，分别对应<code>mach_header</code>和<code>mach_header_64</code>的结构体；</li>
</ol>
<h5 id="2-源码分析"><a href="#2-源码分析" class="headerlink" title="2.源码分析"></a>2.源码分析</h5><p><code>Header</code>被定义在<code>loader.h</code>文件中，具体代码如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">mach_header_64</span> &#123;</span><br><span class="line">    uint32_t    magic;          <span class="comment">// 32位或者64位，系统内核用来判断是否是mach-o格式</span></span><br><span class="line">    cpu_type_t  cputype;        <span class="comment">// CPU架构类型，比如ARM</span></span><br><span class="line">    cpu_subtype_t   cpusubtype; <span class="comment">// CPU的具体类型，例如arm64、armv7</span></span><br><span class="line">    uint32_t    filetype;       <span class="comment">// mach-o文件类型, 可执行文件、目标文件或者静态库和动态库</span></span><br><span class="line">    uint32_t    ncmds;          <span class="comment">// LoadCommands加载命令的条数（加载命令紧跟header之后）</span></span><br><span class="line">    uint32_t    sizeofcmds;     <span class="comment">// 全部LoadCommands加载命令的大小</span></span><br><span class="line">    uint32_t    flags;          <span class="comment">// 标志位标识二进制文件支持的功能，主要是和系统加载、链接有关</span></span><br><span class="line">    uint32_t    reserved;       <span class="comment">// 保留字段(相比于32位多出的字段)</span></span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<p>由于<code>可执行文件</code>、<code>目标文件</code>或者<code>静态库</code>和<code>动态库</code>等都是<code>Mach-O</code>格式，所以才需要<code>filetype</code>来说明。常用的文件类型有以下几种：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#define <span class="type">MH_OBJECT</span>   <span class="number">0x1</span>     <span class="comment">/* 目标文件*/</span></span><br><span class="line">#define <span class="type">MH_EXECUTE</span>  <span class="number">0x2</span>     <span class="comment">/* 可执行文件*/</span></span><br><span class="line">#define <span class="type">MH_DYLIB</span>    <span class="number">0x6</span>     <span class="comment">/* 动态库*/</span></span><br><span class="line">#define <span class="type">MH_DYLINKER</span> <span class="number">0x7</span>     <span class="comment">/* 动态链接器*/</span></span><br><span class="line">#define <span class="type">MH_DSYM</span>     <span class="number">0xa</span>     <span class="comment">/* 存储二进制文件符号信息，用于debug分析*/</span></span><br></pre></td></tr></table></figure>

<h5 id="3-MachOView演示"><a href="#3-MachOView演示" class="headerlink" title="3.MachOView演示"></a>3.MachOView演示</h5><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eaa795545a904c93a9b0d1cc3e7061d3~tplv-k3u1fbpfcp-zoom-1.image"></p>
<h4 id="五、Load-Commands"><a href="#五、Load-Commands" class="headerlink" title="五、Load Commands"></a>五、Load Commands</h4><h5 id="1-功能总结-1"><a href="#1-功能总结-1" class="headerlink" title="1.功能总结"></a>1.功能总结</h5><ol>
<li><code>Load Commands</code>是加载命令的列表，用于描述<code>Data</code>在二进制文件和虚拟内存中的布局信息；</li>
<li><code>Load Commands</code>记录了很多信息，例如动态链接器的位置、程序的入口、依赖库的信息、代码的位置、符号表的位置等；</li>
<li><code>Load commands</code>由内核定义，不同版本的<code>command</code>数量不同，其条数和大小记录在<code>header</code>中；</li>
<li><code>Load commands</code>的<code>type</code>是以<code>LC_</code>为前缀常量，譬如<code>LC_SEGMENT</code>、<code>LC_SYMTAB</code>等；</li>
</ol>
<h5 id="2-代码分析"><a href="#2-代码分析" class="headerlink" title="2..代码分析"></a>2..代码分析</h5><p><code>Load Command</code>被定义在<code>loader.h</code>文件中，具体代码如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">load_command</span> &#123;</span><br><span class="line">    uint32_t cmd;       <span class="comment">/* 加载命令的类型 */</span></span><br><span class="line">    uint32_t cmdsize;   <span class="comment">/* 加载命令的大小 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>每个<code>Load Command</code>都有独立的结构，但是所有结构的前两个字段是固定的。比如<code>LC_SEGMENT_64</code>，这是一个读取<code>segment</code>、<code>section</code>有关命令，具体代码如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">segment_command_64</span> &#123; <span class="comment">/* for 64-bit architectures */</span></span><br><span class="line">    uint32_t    cmd;          <span class="comment">// 表示加载命令类型</span></span><br><span class="line">    uint32_t    cmdsize;      <span class="comment">// 表示加载命令大小（还包括了紧跟其后的nsects个section的大小）</span></span><br><span class="line">    char        segname[<span class="number">16</span>];  <span class="comment">// 16个字节的段名字</span></span><br><span class="line">    uint64_t    vmaddr;       <span class="comment">// 段的虚拟内存起始地址</span></span><br><span class="line">    uint64_t    vmsize;       <span class="comment">// 段的虚拟内存大小</span></span><br><span class="line">    uint64_t    fileoff;      <span class="comment">// 段在文件中的偏移量</span></span><br><span class="line">    uint64_t    filesize;     <span class="comment">// 段在文件中的大小</span></span><br><span class="line">    vm_prot_t   maxprot;      <span class="comment">// 段页面所需要的最高内存保护（4 = r，2 = w，1 = x）</span></span><br><span class="line">    vm_prot_t   initprot;     <span class="comment">// 段页面初始的内存保护</span></span><br><span class="line">    uint32_t    nsects;       <span class="comment">// 段中section数量</span></span><br><span class="line">    uint32_t    flags;        <span class="comment">// 标志位</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="六、Data"><a href="#六、Data" class="headerlink" title="六、Data"></a>六、Data</h4><h5 id="1-功能总结-2"><a href="#1-功能总结-2" class="headerlink" title="1.功能总结"></a>1.功能总结</h5><ol>
<li><code>Data</code>中存储了实际的数据与代码，主要包含方法、符号表、动态符号表、动态库加载信息(重定向、符号绑定等)等；</li>
<li><code>Data</code>中的排布完全按照<code>Load Command</code>中的描述；</li>
<li><code>Data</code>由<code>Segment</code>（段）和 <code>Section</code> （节）的方式来组成，通常，<code>Data</code>拥有多个<code>segment</code>，每个<code>segment</code>可以有零到多个<code>section</code>节；</li>
<li>不同的<code>segment</code>都有一段<code>虚拟地址</code>映射到进程的地址空间；</li>
</ol>
<p>几乎所有的<code>Mach-O</code>文件都包含<code>3</code>个<code>segment</code></p>
<ol>
<li><strong>__TEXT</strong>：代码段，只读可执行，存储<code>函数的二进制代码(__text)</code>，<code>常量字符串(__cstring)</code>，<code>OC的类/方法名</code>等信息</li>
<li><strong>__DATA</strong>：数据段， 可读可写，存储<code>OC的字符串(__cfstring)</code>，以及<code>运行时的元数据：class/protocol/method</code>，以及全局变量，静态变量等；</li>
<li><strong>__LINKEDIT</strong>：只读，存储启动<code>App</code>需要的信息，如 <code>bind &amp; rebase 的地址</code>、函数的名称和地址等信息​；</li>
</ol>
<h5 id="2-源码分析-1"><a href="#2-源码分析-1" class="headerlink" title="2.源码分析"></a>2.源码分析</h5><p>在<code>Data</code>区中，<code>Section</code>占了很大的比例，而且在<code>Mach-O</code>中集中体现在<code>__TEXT</code>和<code>__DATA</code>两段里。</p>
<p><code>Section</code>被定义在<code>loader.h</code>文件中，具体代码如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">section_64</span> &#123; <span class="comment">/* for 64-bit architectures */</span></span><br><span class="line">    char        sectname[<span class="number">16</span>];   <span class="comment">// 当前section的名称</span></span><br><span class="line">    char        segname[<span class="number">16</span>];    <span class="comment">// section所在的segment名称</span></span><br><span class="line">    uint64_t    addr;       <span class="comment">// 内存中起始位置</span></span><br><span class="line">    uint64_t    size;       <span class="comment">// section大小</span></span><br><span class="line">    uint32_t    offset;     <span class="comment">// section的文件偏移</span></span><br><span class="line">    uint32_t    align;    <span class="comment">// 字节大小对齐</span></span><br><span class="line">    uint32_t    reloff;     <span class="comment">// 重定位入口的文件偏移</span></span><br><span class="line">    uint32_t    nreloc;   <span class="comment">// 重定位入口数量</span></span><br><span class="line">    uint32_t    flags;      <span class="comment">// 标志，section的类型和属性</span></span><br><span class="line">    uint32_t    reserved1;  <span class="comment">// 保留（用于偏移量或索引）</span></span><br><span class="line">    uint32_t    reserved2;  <span class="comment">// 保留（用于count或sizeof）</span></span><br><span class="line">    uint32_t    reserved3;  <span class="comment">// 保留</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="七、理解大小端模式"><a href="#七、理解大小端模式" class="headerlink" title="七、理解大小端模式"></a>七、理解大小端模式</h4><p>分析<code>Mach-O文</code>件时，经常会看到内存地址相关的内容，这里就涉及到了大小端模式的概念；</p>
<ol>
<li>小端模式：数据的低字节，保存在内存的低地址；</li>
<li>大端模式：数据的低字节，保存在内存的高地址；</li>
</ol>
<p><code>iOS</code>设备的处理器是基于<code>ARM</code>架构的，默认是采用<strong>小端模式</strong>(低字节放低位）读取数据的，而网络和蓝牙传输数据通常是用的<strong>大端模式</strong>(低字节放高位)：</p>
<p>下面以<code>unsigned int value = 0x12345678</code>为例，分别看看在两种字节序下其存储情况，我们可以用<code>unsigned char buf[4]</code>来表示<code>value</code></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Little</span><span class="operator">-</span><span class="type">Endian</span>: 低地址存放低位，如下：</span><br><span class="line">低地址 <span class="operator">------------------&gt;</span> 高地址</span><br><span class="line"><span class="number">0x78</span>    <span class="number">0x56</span>    <span class="number">0x34</span>    <span class="number">0x12</span></span><br><span class="line"></span><br><span class="line"><span class="type">Big</span><span class="operator">-</span><span class="type">Endian</span>: 低地址存放高位，如下：</span><br><span class="line">低地址 <span class="operator">-----------------&gt;</span> 高地址</span><br><span class="line"><span class="number">0x12</span>    <span class="number">0x34</span>    <span class="number">0x56</span>    <span class="number">0x78</span></span><br></pre></td></tr></table></figure>

<p>内存地址</p>
<p>小端模式存放内容</p>
<p>大端模式存放内容</p>
<p>0x4000</p>
<p>0x78</p>
<p>0x12</p>
<p>0x4001</p>
<p>0x56</p>
<p>0x34</p>
<p>0x4002</p>
<p>0x34</p>
<p>0x56</p>
<p>0x4003</p>
<p>0x12</p>
<p>0x78</p>
<h4 id="八、理解通用二进制文件"><a href="#八、理解通用二进制文件" class="headerlink" title="八、理解通用二进制文件"></a>八、理解通用二进制文件</h4><h5 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h5><ol>
<li>通用二进制文件的存储结构，是将多种架构的<code>Mach-O</code>文件打包在一起，<code>CPU</code>在读取该二进制文件时可以自动检测并选用合适的架构；</li>
<li>通用二进制文件会同时存储多种架构，所以比单一架构的二进制文件大很多，会占用大量的磁盘空间。但由于系统运行时会自动选择最合适的，不相关的架构代码，不会占用内存空间，所以执行效率提高了；</li>
<li>通用二进制格式也被称为胖二进制格式；</li>
</ol>
<h5 id="2-通用二进制格式分析"><a href="#2-通用二进制格式分析" class="headerlink" title="2.通用二进制格式分析"></a>2.通用二进制格式分析</h5><p>通用二进制格式的定义在<code>&lt;mach-o/fat.h&gt;</code>中:</p>
<ol>
<li>下载<a target="_blank" rel="noopener" href="https://opensource.apple.com/tarballs/xnu/">xnu</a>后，依次在 <code>xnu -&gt; EXTERNAL_HEADERS -&gt;mach-o</code>中找到该文件。</li>
<li>通用二进制文件有两个重要结构体：<code>fat_header</code>、<code>fat_arch</code>；</li>
</ol>
<p>两个结构体的定义如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> - magic：可以让系统内核读取该文件时知道是通用二进制文件</span></span><br><span class="line"><span class="comment"> - nfat_arch：表明下面有多个fat_arch结构体，即通用二进制文件包含多少个Mach-O</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">fat_header</span> &#123;</span><br><span class="line">    uint32_t    magic;      <span class="comment">/* FAT_MAGIC */</span></span><br><span class="line">    uint32_t    nfat_arch;  <span class="comment">/* number of structs that follow */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> fat_arch是描述Mach-O</span></span><br><span class="line"><span class="comment"> - cputype 和 cpusubtype：说明Mach-O适用的平台</span></span><br><span class="line"><span class="comment"> - offset（偏移）、size（大小）、align（页对齐）描述了Mach-O二进制位于通用二进制文件的位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">fat_arch</span> &#123;</span><br><span class="line">    cpu_type_t  cputype;    <span class="comment">/* cpu specifier (int) */</span></span><br><span class="line">    cpu_subtype_t   cpusubtype; <span class="comment">/* machine specifier (int) */</span></span><br><span class="line">    uint32_t    offset;     <span class="comment">/* file offset to this object file */</span></span><br><span class="line">    uint32_t    size;       <span class="comment">/* size of this object file */</span></span><br><span class="line">    uint32_t    align;      <span class="comment">/* alignment as a power of 2 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><ol>
<li><a target="_blank" rel="noopener" href="https://opensource.apple.com/tarballs/xnu/">xnu</a></li>
<li><a target="_blank" rel="noopener" href="https://opensource.apple.com/source/xnu/xnu-4903.221.2/EXTERNAL_HEADERS/mach-o/">Mach-O官方源码</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wuyubeichen.github.io/2021/11/02/iOS%E9%AB%98%E7%BA%A7-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Author">
      <meta itemprop="description" content="iOS Developer, Beijing China">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="梧雨北辰的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/02/iOS%E9%AB%98%E7%BA%A7-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">iOS高级-编译原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-11-02 22:54:10" itemprop="dateCreated datePublished" datetime="2021-11-02T22:54:10+08:00">2021-11-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-29 09:39:32" itemprop="dateModified" datetime="2022-08-29T09:39:32+08:00">2022-08-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS%E9%AB%98%E7%BA%A7/" itemprop="url" rel="index"><span itemprop="name">iOS高级</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>主要内容:</strong></p>
<ol>
<li>理解<code>C</code>、<code>C++</code>以及<code>OC</code>的关系</li>
<li>编译型语言与解释型语言</li>
<li>编译器<code>LLVM</code>与<code>CLang</code></li>
<li>理解<code>iOS</code>编译流程</li>
<li>预处理</li>
<li>编译</li>
<li>汇编</li>
<li>链接</li>
</ol>
<h4 id="一、理解C、C-以及OC的关系"><a href="#一、理解C、C-以及OC的关系" class="headerlink" title="一、理解C、C++以及OC的关系"></a>一、理解C、C++以及OC的关系</h4><h5 id="1-C语言"><a href="#1-C语言" class="headerlink" title="1.C语言"></a>1.C语言</h5><ol>
<li><code>C</code>语言是一门面向过程的计算机编程语言，既可用于系统软件开发，也适用于应用软件开发；</li>
<li><code>C</code>语言编译器普遍存在于各种不同的操作系统中，例如<code>Microsoft Windows</code>,<code>Mac OS X</code>, <code>Linux</code>, <code>Unix</code>等；</li>
<li><code>C</code>语言的设计影响了众多后来的编程语言，例如<code>C++</code>、<code>Objective-C</code>、<code>Java</code>、<code>C#</code>等；</li>
</ol>
<h5 id="2-C-语言"><a href="#2-C-语言" class="headerlink" title="2.C++语言"></a>2.C++语言</h5><ol>
<li>兼容了<code>C</code>语言面向过程特点，但又进行了扩充和完善；</li>
<li>作为一种面向对象的语言，具有封装、多继承、多态等特性；</li>
</ol>
<h5 id="3-Objective-C语言"><a href="#3-Objective-C语言" class="headerlink" title="3.Objective-C语言"></a>3.Objective-C语言</h5><ol>
<li>扩展了<code>C</code>语言的能力，使其具备面向对象设计的能力，相当于<code>C</code>的超集；</li>
<li><code>OC</code>代码中也可以有<code>C</code>和<code>C++</code>语句，它可以调用<code>C</code>函数，也可以通过<code>C++</code>对象访问方法；</li>
</ol>
<h5 id="4-OC与C-的比较"><a href="#4-OC与C-的比较" class="headerlink" title="4.OC与C++的比较"></a>4.OC与C++的比较</h5><ol>
<li><code>OC</code>与<code>C++</code>都是从<code>C</code>语言演变而来面向对象设计语言，也都兼容标准的<code>C</code>语言；但它们属于不同的面向对象学派；</li>
<li>两者最大的不同在于：<code>OC</code>提供了运行时的动态绑定机制，而<code>C++</code>是编译时静态绑定，并通过嵌入类和虚函数来模拟实现；</li>
<li><code>OC</code>在编译阶段降低了编译要求提高了灵活性，而<code>C++</code>则是提高了编译要求，在编译过程中就发现更多的潜在错误，在运行前改正，降低了灵活性；</li>
</ol>
<p>以下面的代码为例，在编译期间，<code>C++</code>认为是错误的，而<code>OC</code>则认为没有问题：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NSString</span> <span class="operator">*</span>test <span class="operator">=</span>(id) [[<span class="type">NSArray</span> alloc] <span class="keyword">init</span>];</span><br></pre></td></tr></table></figure>

<p><code>OC</code>与<code>C++</code>在使用细节上的不同如下：</p>
<ol>
<li>定型：<code>OC</code>是动态定型，可以允许根据字符串名字来访问方法和类，还可以动态链接和添加类；</li>
<li>继承：<code>OC</code>不支持多继承，<code>C++</code>支持多继承；</li>
<li>函数调用：<code>OC</code>通过消息传递实现函数调用，而<code>C++</code>直接进行函数调用；</li>
<li>接口：<code>OC</code>采用<code>Protocol</code>形式来定义接口，而<code>C++</code>采用虚函数形式来定义接口；</li>
<li>重载：<code>OC</code>不允许同一个类中两个方法有相同的名字(即使只是参数类型不同)，但<code>C++</code>可以；</li>
</ol>
<h4 id="二、编译型语言与解释型语言"><a href="#二、编译型语言与解释型语言" class="headerlink" title="二、编译型语言与解释型语言"></a>二、编译型语言与解释型语言</h4><p><code>Objective-C</code>属于编译型语言，这是为了保证<code>iPhone</code>的执行效率；</p>
<h5 id="1-编译型语言"><a href="#1-编译型语言" class="headerlink" title="1.编译型语言"></a>1.编译型语言</h5><ol>
<li>程序运行前，必须先通过<code>编译器</code>生成<code>机器码</code>，机器码直接通过<code>CPU</code>执行，运行时不需要重新翻译；</li>
<li>程序执行效率高，但依赖编译器，调试周期长、跨平台性差些；</li>
<li>代表语言：<code>C</code>、<code>C++</code>、<code>OC</code>等；</li>
</ol>
<h5 id="2-解释型语言"><a href="#2-解释型语言" class="headerlink" title="2.解释型语言"></a>2.解释型语言</h5><ol>
<li>程序运行前，不需要进行编译，而是以文本方式存储程序代码，运行时需要解释器解释后再运行；</li>
<li>程序执行效率低下，但是程序具有动态性，运行后也可以随时增加和更新代码来改变程序逻辑；</li>
<li>代表语言：<code>Javascript</code>、<code>Python</code>等；</li>
</ol>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/651ade0e8b42478994d08c42356d218f~tplv-k3u1fbpfcp-watermark.image" alt="编译原理-语言的分类.jpg"></p>
<h4 id="三、编译器LLVM与CLang"><a href="#三、编译器LLVM与CLang" class="headerlink" title="三、编译器LLVM与CLang"></a>三、编译器LLVM与CLang</h4><h5 id="1-编译器"><a href="#1-编译器" class="headerlink" title="1.编译器"></a>1.编译器</h5><p>概念：把一种编程语言(<code>原始语言</code>)转换为另一种编程语言(目标语言)的程序;</p>
<p>大多数编译器都分<code>前端</code>和<code>后端</code>两部分：</p>
<ul>
<li>前端：负责<code>词法分析</code>、<code>语法分析</code>、<code>生成中间代码</code>；</li>
<li>后端：以<code>中间代码</code>作为输入，进行与架构无关的代码优化，接着针对不同架构生成不同的机器码；</li>
</ul>
<p>补充：</p>
<ol>
<li>前后端以<code>中间代码</code>作为媒介，使得前后端可以独立的变化，互不影响；</li>
<li>这样的好处在于：新增一门语言只需要修改前端，而新增一种<code>CPU</code>架构只需要修改后端即可；</li>
</ol>
<h5 id="2-LLVM与Clang"><a href="#2-LLVM与Clang" class="headerlink" title="2.LLVM与Clang"></a>2.LLVM与Clang</h5><p><code>LLVM</code>是苹果当前使用的编译器：</p>
<ol>
<li><code>LLVM</code>是一套编译器基础设施项目，为自由软件，以<code>C++</code>写成，包含一系列模块化的编译器组件和工具链，用来开发编译器<code>前端</code>和<code>后端</code>；</li>
<li>基于 <code>LLVM</code> 衍生出了一些强大的子项目，比如：<code>Clang</code> 和 <code>LLDB</code>。</li>
</ol>
<p><code>CLang</code>基于<code>LLVM</code>，是一个高度模块化开发的轻量级编译器；</p>
<ol>
<li><code>CLang</code>主要来自苹果电脑的支持，同时支持<code>C</code>、<code>Objective-C</code>以及<code>C++</code>；</li>
<li><code>CLang</code>用于替代<code>Xcode5</code>版本前使用的<code>GCC</code>，编译速度提高了<code>3</code>倍：</li>
</ol>
<h5 id="3-理解iOS中的编译器"><a href="#3-理解iOS中的编译器" class="headerlink" title="3.理解iOS中的编译器"></a>3.理解iOS中的编译器</h5><ol>
<li>在<code>iOS</code>开发中，通常<code>LLVM</code>被认为是编译器的后端，而<code>Clang</code>是作为编译器的前端；</li>
<li>二者以 <code>IR</code>（中间代码）作为媒介，这样前后端分离，使得前后端可以独立的变化，互不影响；</li>
<li><code>C</code> 语言家族的前端是 <code>clang</code>，<code>swift</code> 的前端是 <code>swiftc</code>，但二者的后端都是 <code>LLVM</code>；</li>
</ol>
<h4 id="四、理解iOS编译流程"><a href="#四、理解iOS编译流程" class="headerlink" title="四、理解iOS编译流程"></a>四、理解iOS编译流程</h4><h5 id="1-编译流程图"><a href="#1-编译流程图" class="headerlink" title="1.编译流程图"></a>1.编译流程图</h5><p><a target="_blank" rel="noopener" href="http://llvm.org/docs/">LLVM的编译过程</a>相当复杂，<code>iOS</code>代码运行需要经过：<code>预处理</code>、<code>编译</code>、<code>汇编</code>、<code>链接</code>四个关键阶段，具体的流程如下图：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8b0e10d16e16408d86cf70758c4b8e03~tplv-k3u1fbpfcp-watermark.image" alt="编译原理-编译流程.png"></p>
<h5 id="2-准备测试文件"><a href="#2-准备测试文件" class="headerlink" title="2.准备测试文件"></a>2.准备测试文件</h5><p>以<code>OC</code>语言为例，详细分析代码的编译流程，准备一个<code>main.m</code>文件的内容如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="comment">/// 增加注释：宏定义Name</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Name <span class="string">&quot;梧雨北辰&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> &#123;</span><br><span class="line">    NSLog(@<span class="string">&quot;Hello, %s&quot;</span>, Name);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="五、预处理-Prepressing"><a href="#五、预处理-Prepressing" class="headerlink" title="五、预处理(Prepressing)"></a>五、预处理(Prepressing)</h4><h5 id="1-主要功能"><a href="#1-主要功能" class="headerlink" title="1.主要功能"></a>1.主要功能</h5><ol>
<li>替换宏：替换代码中各种宏定义，如定义的常量、函数等；</li>
<li>导入头文件：将<code>#include</code>包含的文件插入到该指令位置等；</li>
<li>清理注释：删除所有注释：<code>//</code> 、<code>/*</code> <code>*/</code>等；</li>
<li>条件编译：处理<code>#if</code>、<code>#ifdef</code>，<code>#endif</code>等类似的条件编译；</li>
<li>添加行号和文件名标识：以便于编译时编译器能够显示警告和错误的所在行号；</li>
</ol>
<h5 id="2-查看预处理结果"><a href="#2-查看预处理结果" class="headerlink" title="2.查看预处理结果"></a>2.查看预处理结果</h5><p>使用<code>xcrun</code>命令，在终端执行预处理操作：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun clang <span class="operator">-</span><span class="type">E</span> main.m</span><br></pre></td></tr></table></figure>

<p>终端显示效果如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">1</span> <span class="string">&quot;main.m&quot;</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;&lt;built-in&gt;&quot;</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="operator">...</span></span><br><span class="line"></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;/Applications/Xcode13.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/System/Library/Frameworks/Foundation.framework/Headers/FoundationLegacySwiftCompatibility.h&quot;</span> <span class="number">1</span> <span class="number">3</span></span><br><span class="line"># <span class="number">193</span> <span class="string">&quot;/Applications/Xcode13.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/System/Library/Frameworks/Foundation.framework/Headers/Foundation.h&quot;</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"># <span class="number">2</span> <span class="string">&quot;main.m&quot;</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line">int main(int argc, const char <span class="operator">*</span> argv[]) &#123;</span><br><span class="line"> <span class="type">NSLog</span>(@<span class="string">&quot;Hello, %s&quot;</span>, <span class="string">&quot;梧雨北辰&quot;</span>);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果分析：</p>
<ol>
<li>预处理后的文件中，注释已经被清理，宏定义也已经被替换；</li>
<li>预处理后的文件有很多行，因为该过程中导入了头文件(<code>Foundation.h</code>)，而且这个过程是递归的；</li>
</ol>
<h4 id="六、编译-Compilation"><a href="#六、编译-Compilation" class="headerlink" title="六、编译(Compilation)"></a>六、编译(Compilation)</h4><h5 id="1-词法分析-Lexical-Analysis"><a href="#1-词法分析-Lexical-Analysis" class="headerlink" title="1. 词法分析(Lexical Analysis)"></a>1. 词法分析(Lexical Analysis)</h5><p>主要功能：通过扫描器，分割识别源代码符号(如大小括号、<code>=</code>、字符串)；</p>
<p>使用<code>xcrun</code>命令，在终端执行词法分析操作：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun clang <span class="operator">-</span>fmodules <span class="operator">-</span>fsyntax<span class="operator">-</span>only <span class="operator">-</span><span class="type">Xclang</span> <span class="operator">-</span>dump<span class="operator">-</span>tokens main.m</span><br></pre></td></tr></table></figure>

<p>终端显示效果如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">annot_module_include &#x27;#<span class="keyword">import</span> &lt;Foundation/Foundation.h&gt;</span><br><span class="line"><span class="operator">/</span>&#x27;     <span class="type">Loc</span><span class="operator">=&lt;</span>main.m:<span class="number">1</span>:<span class="number">1</span><span class="operator">&gt;</span></span><br><span class="line">int &#x27;int&#x27;  [<span class="type">StartOfLine</span>]  <span class="type">Loc</span><span class="operator">=&lt;</span>main.m:<span class="number">4</span>:<span class="number">1</span><span class="operator">&gt;</span></span><br><span class="line">identifier &#x27;main&#x27;  [<span class="type">LeadingSpace</span>]</span><br><span class="line"></span><br><span class="line"><span class="operator">......</span></span><br><span class="line"></span><br><span class="line">r_brace &#x27;&#125;&#x27;    [<span class="type">StartOfLine</span>]  <span class="type">Loc</span><span class="operator">=&lt;</span>main.m:<span class="number">7</span>:<span class="number">1</span><span class="operator">&gt;</span></span><br><span class="line">eof &#x27;&#x27;        <span class="type">Loc</span><span class="operator">=&lt;</span>main.m:<span class="number">10</span>:<span class="number">1</span><span class="operator">&gt;</span></span><br></pre></td></tr></table></figure>

<p>结果分析：</p>
<ol>
<li>每个被分割的源代码符号都被记录了位置，方便后续定位错误；</li>
<li>比如<code>Loc=&lt;main.m:4:1&gt;</code> 就表示：<code>&#39;int&#39;</code>这个符号是从源文件<code>main.m</code>的第<code>4</code>行的第<code>1</code>个字符开始的；</li>
</ol>
<h5 id="2-语法分析-Semantic-Analysis"><a href="#2-语法分析-Semantic-Analysis" class="headerlink" title="2.语法分析(Semantic Analysis)"></a>2.语法分析(Semantic Analysis)</h5><p>主要功能：对源代码符号进行分析，验证语法是否正确，最后生成<code>AST</code>语法树；</p>
<p>使用<code>xcrun</code>命令，查看语法分析结果：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun clang <span class="operator">-</span>fsyntax<span class="operator">-</span>only <span class="operator">-</span><span class="type">Xclang</span> <span class="operator">-</span>ast<span class="operator">-</span>dump main.c  <span class="keyword">open</span> <span class="operator">-</span>f</span><br></pre></td></tr></table></figure>

<p><code>AST</code>语法树：</p>
<ol>
<li>是抽象语法树，结构上比代码更精简，遍历速度更快；</li>
<li>能够更快的进行静态检查，同时生成<code>IR</code>(中间代码)；</li>
</ol>
<h5 id="3-静态分析-Static-Analysis"><a href="#3-静态分析-Static-Analysis" class="headerlink" title="3.静态分析(Static Analysis)"></a>3.静态分析(Static Analysis)</h5><p>主要功能：对<code>AST</code>树进行遍历分析，包括<code>类型检查</code>、<code>方法实现检查</code>，会及时提示错误；</p>
<h5 id="4-生成中间代码-Code-Generation"><a href="#4-生成中间代码-Code-Generation" class="headerlink" title="4.生成中间代码(Code Generation)"></a>4.生成中间代码(Code Generation)</h5><p>主要功能：<code>CodeGen</code>负责将<code>AST</code>语法树自顶向下遍历，逐步翻译成<code>IR</code>中间代码；</p>
<p><code>IR</code>中间代码：</p>
<ol>
<li>这是一种更接近于机器码的语言，使得编译器被分为前端和后端，不同的平台可以利用各自的编译器将中间代码，转化为适合不同平台的机器码；</li>
<li>对于<code>iOS</code>系统来说，<code>IR</code>中间代码生成的就是<code>Mach-O</code>可执行文件;</li>
<li><code>IR</code>是前端的输出，后端的输入；</li>
</ol>
<h4 id="七、汇编-Assembly"><a href="#七、汇编-Assembly" class="headerlink" title="七、汇编(Assembly)"></a>七、汇编(Assembly)</h4><p>输出<code>中间代码</code>标志着前端工作的完成，接下来将进入后端的处理流程。</p>
<h5 id="1-LLVM优化中间代码"><a href="#1-LLVM优化中间代码" class="headerlink" title="1.LLVM优化中间代码"></a>1.LLVM优化中间代码</h5><p>中间代码<code>IR</code>进入后端，<code>LLVM</code>会对其进行优化：</p>
<ol>
<li><code>Optimization Level</code></li>
<li><code>bitcode</code></li>
</ol>
<h5 id="2-生成汇编代码"><a href="#2-生成汇编代码" class="headerlink" title="2.生成汇编代码"></a>2.生成汇编代码</h5><p><code>LLVM</code>对<code>IR</code>进行优化后，会针对不同架构生成不同汇编代码；</p>
<p>汇编阶段的目的：</p>
<ol>
<li>将代码汇编化，并将符号进行归类；</li>
<li>将外部导入符号，放到重定位符号表；</li>
<li>最后生成一个或多个<code>.o</code>目标文件；</li>
</ol>
<p>使用<code>xcrun</code>命令，生成汇编文件：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun clang <span class="operator">-</span><span class="type">S</span> main.m <span class="operator">-</span>o main.s</span><br></pre></td></tr></table></figure>

<p>打开<code>.s</code>文件，摘取内容如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    .section    __TEXT,__text,regular,pure_instructions</span><br><span class="line">    .build_version macos, <span class="number">11</span>, <span class="number">0</span> sdk_version <span class="number">11</span>, <span class="number">3</span></span><br><span class="line">    .globl  _main                           ## <span class="operator">--</span> <span class="type">Begin</span> function main</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    callq   _NSLog</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">.subsections_via_symbols</span><br></pre></td></tr></table></figure>

<p>可以看到，汇编文件中的<code>NSLog</code>操作已经被转化为汇编命令形式的调用，即<code>callq _NSLog</code>；</p>
<h5 id="3-生成目标文件"><a href="#3-生成目标文件" class="headerlink" title="3.生成目标文件"></a>3.生成目标文件</h5><p>该阶段是<code>汇编器</code>将<code>汇编代码</code>转换为<code>机器代码</code>，并输出<code>目标文件</code>，即<code>.o</code>文件；</p>
<p>使用<code>xcrun</code>命令，生成目标文件:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun clang <span class="operator">-</span>fmodules <span class="operator">-</span>c main.m <span class="operator">-</span>o main.o</span><br></pre></td></tr></table></figure>

<p>使用<code>file</code>命令，查看目标文件类型:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">%</span> file main.o</span><br><span class="line">main.o: <span class="type">Mach</span><span class="operator">-</span><span class="type">O</span> <span class="number">64</span><span class="operator">-</span>bit object x86_64</span><br></pre></td></tr></table></figure>

<p>可以看到，汇编器生成<code>Mach-O</code>格式的文件，而且是<code>object</code>类型，即目标文件类型：</p>
<ol>
<li><code>Mach-O</code>文件是用于<code>iOS</code>和<code>OS</code>平台上的文件类型；</li>
<li><code>Mach-O</code>作为<code>a.out</code>格式的替代，提供了更强的扩展性，也提升了符号表中信息的访问速度；</li>
</ol>
<p>使用<code>xcrun</code>命令，查看下<code>main.o</code>中的符号：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun nm <span class="operator">-</span>nm main.o</span><br></pre></td></tr></table></figure>

<p>终端显示效果如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">                 (undefined) external _NSLog</span><br><span class="line">                 (undefined) external ___CFConstantStringClassReference</span><br><span class="line"><span class="number">0000000000000000</span> (__TEXT,__text) external _main</span><br></pre></td></tr></table></figure>

<p>可以看到，此时我们使用的<code>NSLog</code>函数，对应着<code>_NSLog</code>符号：</p>
<ol>
<li><code>undefined</code>：表示在当前文件暂时找不到符号<code>_NSLog</code>；</li>
<li><code>external</code>：表示这个符号是外部可以访问的，对应表示文件私有的符号是<code>non-external</code>；</li>
</ol>
<h4 id="八、链接-Linking"><a href="#八、链接-Linking" class="headerlink" title="八、链接(Linking)"></a>八、链接(Linking)</h4><p>主要功能：符号解析、重定位、合并目标文件，最终生成可执行文件；</p>
<h5 id="1-使用xcrun命令执行链接，得到可执行文件"><a href="#1-使用xcrun命令执行链接，得到可执行文件" class="headerlink" title="1.使用xcrun命令执行链接，得到可执行文件"></a>1.使用xcrun命令执行链接，得到可执行文件</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun clang main.o <span class="operator">-</span>o main</span><br></pre></td></tr></table></figure>

<h5 id="2-使用file命令，查看文件类型"><a href="#2-使用file命令，查看文件类型" class="headerlink" title="2.使用file命令，查看文件类型"></a>2.使用file命令，查看文件类型</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">%</span> file main</span><br><span class="line">main: <span class="type">Mach</span><span class="operator">-</span><span class="type">O</span> <span class="number">64</span><span class="operator">-</span>bit executable x86_64</span><br><span class="line"><span class="operator">%</span> <span class="operator">./</span>main</span><br><span class="line"><span class="number">2021</span><span class="operator">-</span><span class="number">10</span><span class="operator">-</span><span class="number">01</span> <span class="number">19</span>:<span class="number">06</span>:<span class="number">41.846</span> main[<span class="number">5663</span>:<span class="number">660299</span>] <span class="type">Hello</span>, 梧雨北辰</span><br></pre></td></tr></table></figure>

<p>结果分析：虽然还是<code>Mach-O</code>格式，但此时已经是<code>executable</code>类型了，即可执行文件。而且运行该文件后也打印出了预期的结果；</p>
<h5 id="3-再次使用xcrun命令，查看可执行文件的符号表"><a href="#3-再次使用xcrun命令，查看可执行文件的符号表" class="headerlink" title="3.再次使用xcrun命令，查看可执行文件的符号表"></a>3.再次使用xcrun命令，查看可执行文件的符号表</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">%</span> xcrun nm <span class="operator">-</span>nm main</span><br><span class="line">                 (undefined) external _NSLog (from <span class="type">Foundation</span>)</span><br><span class="line">                 (undefined) external ___CFConstantStringClassReference (from <span class="type">CoreFoundation</span>)</span><br><span class="line">                 (undefined) external dyld_stub_binder (from libSystem)</span><br><span class="line"><span class="number">0000000100000000</span> (__TEXT,__text) [referenced dynamically] external __mh_execute_header</span><br><span class="line">0000000100003f40 (__TEXT,__text) external _main</span><br><span class="line"><span class="number">0000000100008008</span> (__DATA,__data) non<span class="operator">-</span>external __dyld_private</span><br></pre></td></tr></table></figure>

<p>结果分析：<code>_NSLog</code>符号依然是<code>undefined</code>，不过此时多了一些信息，即<code>from Foundation</code>，表示这个符号来自于<code>Foundation</code>，会在运行时动态绑定；</p>
<h5 id="4-链接阶段的主要任务"><a href="#4-链接阶段的主要任务" class="headerlink" title="4.链接阶段的主要任务"></a>4.链接阶段的主要任务</h5><p>1.符号解析</p>
<p>将每个符号引用和对应的符号定义关联起来；</p>
<ul>
<li>链接器链接多文件时会创建符号表，用于记录所有已经定义和未定义的符号；<ol>
<li>出现相同符号，会报错：<code>&quot;ld:dumplicate symbols&quot;</code>；</li>
<li>在其他目标文件里没有找到到符号，会报错：<code>&quot;Undefined symbols&quot;</code>；</li>
</ol>
</li>
<li>另外，链接器在整理函数的符号调用关系时，可以帮助我们理清那些函数没有被调用，并自动去除掉；</li>
</ul>
<p>2.重定位</p>
<p>将变量名、函数名这些符号定义与一个内存位置关联起来；</p>
<ul>
<li>因为只有通过了绑定，机器才知道需要操作什么内存地址；</li>
<li>否则，我们就需要在写代码时给每个指令设置好内存地址，不仅操作繁琐，而且容易引起出错；</li>
</ul>
<p>3.合并目标文件</p>
<p>将多个<code>.m文件</code>编译产生的<code>.o</code>目标文件与其他<code>Mach-O</code>文件(如<code>dylib</code>、<code>a</code>、<code>tbd</code>），合成一个<code>Mach-O</code>格式的可执行文件；</p>
<ul>
<li>通常项目都会包含多个文件，不同文件之间的<code>变量</code>和<code>接口函数</code>就会产生相互依赖关系；</li>
<li>程序运行前，需要使用链接器将多个文件里的符号和地址绑定起来，才能保证整个程序里的变量、接口的正常调用；</li>
</ul>
<h5 id="5-理解静态链接与动态链接"><a href="#5-理解静态链接与动态链接" class="headerlink" title="5.理解静态链接与动态链接"></a>5.理解静态链接与动态链接</h5><p>静态链接：作用于编译期，链接后的文件依然可能会存在一些<code>&quot;undefined&quot;</code>的符号。但是这些符号都会被记录下来，在运行时再通过<code>dlopen</code>和<code>dlsym</code>动态链接绑定；</p>
<p>动态链接：作用于运行时，这样的优势在于：诸多类似<code>UIKit</code>这样的共享库将不必包含在每一个<code>App</code>包里。比如：我们使用到的<code>UIKit</code>系统库，等到点击<code>App</code>真正开始运行之前，才会去链接依赖的<code>UIKit</code>，链接完成再运行<code>App</code>；</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wuyubeichen.github.io/2021/11/01/iOS%E9%AB%98%E7%BA%A7-Xcode%E5%A4%9A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Author">
      <meta itemprop="description" content="iOS Developer, Beijing China">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="梧雨北辰的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/01/iOS%E9%AB%98%E7%BA%A7-Xcode%E5%A4%9A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/" class="post-title-link" itemprop="url">iOS高级-Xcode多环境配置</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-11-01 22:54:10" itemprop="dateCreated datePublished" datetime="2021-11-01T22:54:10+08:00">2021-11-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-29 09:39:32" itemprop="dateModified" datetime="2022-08-29T09:39:32+08:00">2022-08-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS%E9%AB%98%E7%BA%A7/" itemprop="url" rel="index"><span itemprop="name">iOS高级</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>主要内容：</strong></p>
<ol>
<li>区分<code>Project</code>、<code>Target</code>、<code>Scheme</code></li>
<li>多<code>Target</code> 配置</li>
<li><code>Scheme</code>配置</li>
<li><code>xcconfig</code>文件配置</li>
</ol>
<h4 id="一、区分Project、Target、Scheme"><a href="#一、区分Project、Target、Scheme" class="headerlink" title="一、区分Project、Target、Scheme"></a>一、区分Project、Target、Scheme</h4><ul>
<li><code>Project</code>：是一个项目的整体，相当于一个仓库，包括了所有的代码和资源文件；</li>
<li><code>Target</code>：相当于一个具体的产品，包含了对于代码，资源文件的具体使用规则和配置；</li>
<li><code>Scheme</code>: 对指定<code>Target</code>的环境进行配置；</li>
</ul>
<p>总结：一个<code>Project</code>可以包含多个<code>Target</code>，也就是说通过不同<code>Target</code>我们可以生成不同的<code>APP</code>；</p>
<p>多环境配置的三种方法：</p>
<ol>
<li>多<code>target</code>配置;</li>
<li><code>Scheme</code>配置;</li>
<li><code>xcconfig</code>文件配置;</li>
</ol>
<h4 id="二、多Target-配置"><a href="#二、多Target-配置" class="headerlink" title="二、多Target 配置"></a>二、多Target 配置</h4><h5 id="1-总结特点"><a href="#1-总结特点" class="headerlink" title="1.总结特点"></a>1.总结特点</h5><ul>
<li>优点：方便管理代码，资源文件，比如在<code>Compile Sources</code>、<code>Copy Bundle Resources</code>里根据需要增加或者删除需要编译的代码和资源；</li>
<li>缺点：配置繁琐，涉及多个<code>info.plist</code>文件、宏定义等，大量的修改人容易错乱；</li>
</ul>
<h5 id="2-基本步骤"><a href="#2-基本步骤" class="headerlink" title="2.基本步骤"></a>2.基本步骤</h5><p>1.创建新<code>target</code></p>
<p>选中已有<code>target</code>，右键选择<code>Duplicate</code>，会拷贝创建出与原<code>Target</code>相同配置的新<code>Target</code>；</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c065c372995d416693dc6ccef0508622~tplv-k3u1fbpfcp-watermark.image" alt="Target配置-Duplicate.png"></p>
<p>2.修改新<code>target</code>的配置</p>
<p>由于拷贝得到的<code>target</code>仍使用旧的配置，为了使用新<code>target</code>，所以我们还需要一些额外设置：</p>
<ol>
<li><p>修改新<code>Target</code>名字；</p>
</li>
<li><p>修改新<code>info.plist</code>名字；</p>
</li>
<li><p>修改<code>Build Settings</code> -&gt; <code>Packaging</code> -&gt; <code>info.plist File</code> 与 <code>Product Bundle identifier</code>；</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/928bf7525e524884a4ede350865c0536~tplv-k3u1fbpfcp-watermark.image" alt="Target配置-修改名字.png"></p>
</li>
</ol>
<p>3.修改<code>Scheme</code>名字</p>
<p>进入<code>Scheme Manager</code>，修改<code>Scheme</code>的名字，这里并非必须，修改是为了更加方便识别;</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/89f60813eda548c6932e74d1b22a6083~tplv-k3u1fbpfcp-watermark.image" alt="Target配置-Scheme.png"></p>
<p>4.为了区别不同的<code>Target</code>，增加预定义宏</p>
<p>配置<code>OC</code>工程：<code>Build Settings</code> -&gt; <code>Preprocessor Macros</code></p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/21ec401d7c3a4fd7a806e38d861bf8da~tplv-k3u1fbpfcp-watermark.image" alt="Target配置-OC添加宏.png"></p>
<p>配置<code>Swift</code>工程：<code>Build Settings</code> -&gt; <code>Other Swift Flags</code></p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2fde31bff98e443fa485c6b368ff4842~tplv-k3u1fbpfcp-watermark.image" alt="Target配置-Swift添加宏.png"></p>
<p>理解<code>-D</code>用法：</p>
<ol>
<li><code>swiftc</code>编译器中，需要添加一个<code>-D</code>的<code>option</code>，代表将条件编译标志标记为<code>true</code>；</li>
<li>至于<code>-D</code>的说明，也可以使用控制台命令查看：<code>swiftc --help grep &#39;-D&#39;</code></li>
</ol>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">-</span><span class="type">D</span> <span class="operator">&lt;</span>value<span class="operator">&gt;</span>  <span class="type">Marks</span> a conditional compilation flag <span class="keyword">as</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>5.测试<code>target</code>多环境</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">#if</span> <span class="type">DEV</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Project DEV&quot;</span>)</span><br><span class="line"><span class="keyword">#else</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Project Normal&quot;</span>)</span><br><span class="line"><span class="keyword">#endif</span></span><br></pre></td></tr></table></figure>

<h4 id="三、Scheme配置"><a href="#三、Scheme配置" class="headerlink" title="三、Scheme配置"></a>三、Scheme配置</h4><p>配置<code>Scheme</code>实现多环境，其实是通过设置多种<code>configurations</code>的方式，具体步骤如下:</p>
<h5 id="1-增加新configration"><a href="#1-增加新configration" class="headerlink" title="1.增加新configration"></a>1.增加新configration</h5><p>进入<code>Project</code> -&gt; <code>Info</code> -&gt; <code>Configurations</code>，在这里可以看到已经存在的<code>Debug</code>、<code>Release</code>等配置。点击<code>“+”</code>，可以在这里增加新的<code>configuration</code>(以<code>Dev</code>为例);</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6aa48beefddf4ad9bd70c985a600f608~tplv-k3u1fbpfcp-watermark.image" alt="Scheme配置-增加configration.png"></p>
<h5 id="2-切换多环境"><a href="#2-切换多环境" class="headerlink" title="2.切换多环境"></a>2.切换多环境</h5><p>增加<code>configuration</code>后，在<code>Edit Scheme</code>时，也会多出一种<code>configration</code>。我们在<code>run</code>的时候，就可以手动切换<code>configration</code>使用不同的环境；</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0ef3d7a5ee5c48cf95c878f3b53e8451~tplv-k3u1fbpfcp-watermark.image" alt="Scheme配置-切换configration.png"></p>
<h5 id="3-多Scheme"><a href="#3-多Scheme" class="headerlink" title="3.多Scheme"></a>3.多Scheme</h5><p>每次手动切换<code>configration</code>较为繁琐，我们还可以使用不同的<code>Scheme</code>直接对应不同的配置；</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8579731f6eeb4f979f042ec456bec16f~tplv-k3u1fbpfcp-watermark.image" alt="Scheme配置-New-Scheme.png"></p>
<h5 id="4-测试Scheme多环境"><a href="#4-测试Scheme多环境" class="headerlink" title="4.测试Scheme多环境"></a>4.测试Scheme多环境</h5><p>1.<code>Build Setting</code> -&gt; <code>User-Defined</code>里自定义<code>Host_URL</code>，再对不同的<code>configration</code>配置不同的值；</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fdffb0e428024bf793cdc242ff491d41~tplv-k3u1fbpfcp-watermark.image" alt="Scheme配置-User-HOST_URL.png"></p>
<p>2.将<code>Host_URL</code>以变量的方式配置<code>到info.plist</code>文件中；</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/81de9bcb9a1241d9b280a363d5683c2e~tplv-k3u1fbpfcp-watermark.image" alt="Scheme配置-Info-HOST_URL.png"></p>
<p>3.读取<code>info.plist</code>，手动切换<code>configration</code>或者使用不同的<code>Scheme</code>运行，将得到不同的信息；</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> path <span class="operator">=</span> <span class="type">Bundle</span>.main.path(forResource: <span class="string">&quot;Info&quot;</span>, ofType: <span class="string">&quot;plist&quot;</span>) <span class="keyword">else</span> &#123; <span class="keyword">return</span>&#125;</span><br><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> infoDic <span class="operator">=</span> <span class="type">NSDictionary</span>(contentsOfFile: path) <span class="keyword">else</span> &#123;<span class="keyword">return</span>&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> host_url <span class="operator">=</span> infoDic[<span class="string">&quot;HOST_URL&quot;</span>] &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;HOST_URL:<span class="subst">\(host_url)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="四、xcconfig配置文件"><a href="#四、xcconfig配置文件" class="headerlink" title="四、xcconfig配置文件"></a>四、xcconfig配置文件</h4><p><code>xcconfig</code>配置文件：</p>
<ol>
<li><code>.xcconfig</code>配置文件，可以帮助我们以文件的形式配置<code>build settings</code>里的内容；</li>
<li><code>.xcconfig</code>的文件的内容，是以<code>key-value</code>形式构成的；</li>
<li>增加<code>.xcconfig</code>文件后，依然可以继续在<code>build settings</code>里增加配置项目，并不会覆盖；</li>
</ol>
<h5 id="1-查看配置文件"><a href="#1-查看配置文件" class="headerlink" title="1.查看配置文件"></a>1.查看配置文件</h5><p>其实，若使用<code>Cocoapods</code>管理第三方库，就已经自动生成了<code>Debug</code>和<code>Release</code>配置文件。</p>
<p>查看配置：<code>Xcode</code> -&gt; <code>PROJECT</code> -&gt; <code>info</code> -&gt; <code>Configurations</code></p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e6c883e12ae461788fa93e177c45c19~tplv-k3u1fbpfcp-watermark.image" alt="xxconfig-pods配置.png"></p>
<h5 id="2-自定义配置文件"><a href="#2-自定义配置文件" class="headerlink" title="2.自定义配置文件"></a>2.自定义配置文件</h5><ol>
<li><code>Commd +N</code> -&gt; 搜索<code>Configuration Setting File</code>，保存名称以”<code>目录名-App名.环境</code>“为格式， 如”<code>Config-TestProject.debug</code>“；</li>
<li>在<code>.xcconfig</code>文件里写入配置，而这里用到的<code>key</code>其实都是<code>build settings</code>配置选项的缩写，具体可查看网站<a target="_blank" rel="noopener" href="https://xcodebuildsettings.com/">Xcode Build Settings</a>；</li>
</ol>
<p>举例：在配置文件中写入以下配置：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SLASH</span> <span class="operator">=</span> <span class="operator">/</span></span><br><span class="line"><span class="type">HOST_URL</span> <span class="operator">=</span> http:$&#123;<span class="type">SLASH</span>&#125;<span class="operator">/</span><span class="number">1234</span></span><br><span class="line"><span class="type">OTHER_LDFLAGS</span> <span class="operator">=</span>  <span class="operator">-</span>framework <span class="string">&quot;AFNetworking&quot;</span></span><br><span class="line"><span class="type">HEADER_SEARCH_PATHS</span> <span class="operator">=</span> <span class="operator">/</span>abcd<span class="operator">/</span>efg</span><br></pre></td></tr></table></figure>

<p>此时执行编译后，在<code>build settings</code>里搜索查看<code>Other Linker Flags</code>、<code>Header Search Paths</code>，这些配置都已经被成功修改；</p>
<h5 id="3-特殊符号问题"><a href="#3-特殊符号问题" class="headerlink" title="3.特殊符号问题"></a>3.特殊符号问题</h5><p>在写入配置信息时，其中<code>url</code>的<code>//</code>会被认为是注释。此时，我们可以先定义一个变量<code>SLASH = /</code>， 如下代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SLASH</span> <span class="operator">=</span> <span class="operator">/</span></span><br><span class="line"><span class="type">HOST_URL</span> <span class="operator">=</span> http:$&#123;<span class="type">SLASH</span>&#125;<span class="operator">/</span><span class="number">5678</span></span><br></pre></td></tr></table></figure>

<h5 id="4-增加约束条件"><a href="#4-增加约束条件" class="headerlink" title="4.增加约束条件"></a>4.增加约束条件</h5><p>某些情况下，我们需要为配置增加约束条件，如只在<code>Debug</code>环境下、<code>SDK</code>是模拟器，且架构是<code>x86_64</code>的情况下才会<code>link</code>这个<code>frameworkName</code>，则需要如下配置：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">OTHER_LDFLAGS</span>[config<span class="operator">=</span><span class="type">Debug</span>][sdk<span class="operator">=</span>iphonesimulator<span class="operator">*</span>][arch<span class="operator">=</span>x86_64] <span class="operator">=</span> <span class="operator">-</span>framework <span class="string">&quot;frameworkName&quot;</span></span><br></pre></td></tr></table></figure>

<h5 id="5-xcconfig文件冲突问题"><a href="#5-xcconfig文件冲突问题" class="headerlink" title="5.xcconfig文件冲突问题"></a>5.xcconfig文件冲突问题</h5><p>我们习惯于使用<code>cocoapods</code>管理第三方，由其生成的配置文件和我们自定义的配置文件就会冲突，因为一个环境只能配置一个<code>.xcconfig</code>文件：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1717a5a897ba4feeb8c4da0550330622~tplv-k3u1fbpfcp-watermark.image" alt="xxconfig-pods冲突.png"></p>
<p>而且，此时更新<code>Pods</code>也会警告：已经存在其他的配置文件，<code>Pods</code>设置的.<code>xcconfig</code>文件不会生效；</p>
<p>解决方案：在自定义配置文件中使用关键<code>include</code>命令，引入<code>pods</code>的配置文件，使其生效：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意：这里需要根据debug、release等不同的环境，分别设置</span></span><br><span class="line">#include <span class="string">&quot;Pods/Target Support Files/Pods-TestProject/Pods-TestProject.debug.xcconfig&quot;</span></span><br></pre></td></tr></table></figure>

<h5 id="6-xcconfig关键字冲突问题"><a href="#6-xcconfig关键字冲突问题" class="headerlink" title="6.xcconfig关键字冲突问题"></a>6.xcconfig关键字冲突问题</h5><p>将<code>Pods</code>生成的<code>.xcconfig</code>文件通过<code>include</code>导入自定义的配置文件中后，如果两者都对同一个<code>key</code>进行过配置，就会导致前者无效的问题。</p>
<p>比如，两者都对相同的<code>Other Link Flags</code>进行配置，查看<code>Build Setting</code>后，会发现<code>Pods</code>生成的<code>.xcconfig</code>没有生效；</p>
<p>解决方案：使用<code>inherited</code>进行继承，在自定义配置文件中配置如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">OTHER_LDFLAGS</span> <span class="operator">=</span> $(inherited) <span class="operator">-</span>framework <span class="string">&quot;AFNetworking&quot;</span></span><br></pre></td></tr></table></figure>

<h5 id="7-测试-xcconfig多环境"><a href="#7-测试-xcconfig多环境" class="headerlink" title="7.测试.xcconfig多环境"></a>7.测试.xcconfig多环境</h5><ol>
<li>在不同的<code>.xcconfig</code>定义不同的<code>HOST_URL</code>，并以类似上文的步骤在<code>info.plist</code>中增加配置；</li>
<li>切换到不同的<code>configration</code>下运行项目，将会得到不同的<code>HOST_URL</code>；</li>
</ol>
<h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><ol>
<li><a target="_blank" rel="noopener" href="https://github.com/DreamcoffeeZS/TestProjects/tree/main/01.MachO%E4%B8%8E%E7%AC%A6%E5%8F%B7">本文测试Demo地址</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/3508e9fff7cc">iOS多Target开发相似App</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wuyubeichen.github.io/2019/04/18/iOS%E5%BA%95%E5%B1%82-%E8%87%AA%E5%8A%A8%E9%87%8A%E6%94%BE%E6%B1%A0%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Author">
      <meta itemprop="description" content="iOS Developer, Beijing China">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="梧雨北辰的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/18/iOS%E5%BA%95%E5%B1%82-%E8%87%AA%E5%8A%A8%E9%87%8A%E6%94%BE%E6%B1%A0%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">iOS底层-自动释放池原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-18 18:18:44" itemprop="dateCreated datePublished" datetime="2019-04-18T18:18:44+08:00">2019-04-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-29 09:39:32" itemprop="dateModified" datetime="2022-08-29T09:39:32+08:00">2022-08-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS%E5%BA%95%E5%B1%82/" itemprop="url" rel="index"><span itemprop="name">iOS底层</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>主要内容：</strong></p>
<ol>
<li><code>AutoreleasePool</code>简介</li>
<li><code>AutoreleasePool</code>底层原理</li>
<li><code>Autorelease</code>与<code>NSThread</code>、<code>NSRunLoop</code>的关系</li>
<li><code>AutoreleasePool</code>在主线程上的释放时机</li>
<li><code>AutoreleasePool</code>在子线程上的释放时机</li>
<li><code>AutoreleasePool</code>需要手动添加的情况</li>
</ol>
<h4 id="一、Autorelease简介"><a href="#一、Autorelease简介" class="headerlink" title="一、Autorelease简介"></a>一、Autorelease简介</h4><p><code>iOS</code>开发中的<code>Autorelease</code>机制是为了延时释放对象。自动释放的概念看上去很像<code>ARC</code>，但实际上这更类似于<code>C</code>语言中自动变量的特性；</p>
<ul>
<li>自动变量：在超出变量作用域后将被废弃；</li>
<li>自动释放池：在超出释放池生命周期后，向其管理的对象实例的发送<code>release</code>消息；</li>
</ul>
<h5 id="1-1-MRC下使用自动释放池"><a href="#1-1-MRC下使用自动释放池" class="headerlink" title="1.1 MRC下使用自动释放池"></a>1.1 MRC下使用自动释放池</h5><p>在<code>MRC</code>环境中使用自动释放池需要用到<code>NSAutoreleasePool</code>对象，其生命周期就相当于<code>C</code>语言变量的作用域。对于所有调用过<code>autorelease</code>方法的对象，在废弃<code>NSAutoreleasePool</code>对象时，都将调用<code>release</code>实例方法。用源代码表示如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MRC环境下的测试：</span></span><br><span class="line"><span class="comment">//第一步：生成并持有释放池NSAutoreleasePool对象;</span></span><br><span class="line"><span class="type">NSAutoreleasePool</span> <span class="operator">*</span>pool <span class="operator">=</span> [[<span class="type">NSAutoreleasePool</span> alloc] <span class="keyword">init</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二步：调用对象的autorelease实例方法;</span></span><br><span class="line">id obj <span class="operator">=</span> [[<span class="type">NSObject</span> alloc] <span class="keyword">init</span>];</span><br><span class="line">[obj autorelease];</span><br><span class="line"></span><br><span class="line"><span class="comment">//第三步：废弃NSAutoreleasePool对象;</span></span><br><span class="line">[pool drain];   <span class="comment">//向pool管理的所有对象发送消息，相当于[obj release]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//obi已经释放，再次调用会崩溃(Thread 1: EXC_BAD_ACCESS (code=EXC_I386_GPFLT))</span></span><br><span class="line"><span class="type">NSLog</span>(@<span class="string">&quot;打印obj：%@&quot;</span>, obj); </span><br></pre></td></tr></table></figure>

<p>理解<code>NSAutoreleasePool</code>对象的生命周期，如下图所示：</p>
<img src="http://182.92.228.41/wp-content/uploads/autoreleasepool_NSAutoreleasePool_lifecycle.png" width="500" hegiht="313" align=center/>

<p><code>MRC</code>向一个对象发送一条<code>autorelease</code>消息，这个对象并不会立即销毁，而是将这个对象放入了自动释放池，待池子释放时，它会向池中每一个对象发送一条<code>release</code>消息，以此来释放对象<br>向一个对象发送<code>release</code>消息，并不意味着这个对象被销毁了，而是当这个对象的引用计数为<code>0</code>时，系统才会调用<code>dealloc</code>方法释放该对象和对象本身所拥有的实例。</p>
<h5 id="1-2-ARC下使用自动释放池"><a href="#1-2-ARC下使用自动释放池" class="headerlink" title="1.2 ARC下使用自动释放池"></a>1.2 ARC下使用自动释放池</h5><p><code>ARC</code>环境不能使用<code>NSAutoreleasePool</code>类也不能调用<code>autorelease</code>方法，代替它们实现对象自动释放的是<code>@autoreleasepool</code>块和<code>__autoreleasing</code>修饰符。比较两种环境下的代码差异如下图：<br><img src="http://182.92.228.41/wp-content/uploads/autoreleasepool_mrc_and_arc.png" width="500" hegiht="313" align=center/></p>
<p>如图所示，<code>@autoreleasepool</code>块替换了<code>NSAutoreleasePoool</code>类对象的生成、持有及废弃这一过程。而附有<code>__autoreleasing</code>修饰符的变量替代了<code>autorelease</code>方法，将对象注册到了<code>Autoreleasepool</code>；由于<code>ARC</code>的优化，<code>__autorelease</code>是可以被省略的，所以简化后的<code>ARC</code>代码如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ARC环境下的测试：</span></span><br><span class="line"><span class="meta">@autoreleasepool</span> &#123;</span><br><span class="line">    id obj <span class="operator">=</span> [[<span class="type">NSObject</span> alloc] <span class="keyword">init</span>];</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;打印obj：%@&quot;</span>, obj); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显式使用<code>__autoreleasing</code>修饰符的情况非常少见，这是因为<code>ARC</code>的很多情况下，即使是不显式的使用<code>__autoreleasing</code>，也能实现对象被注册到释放池中。主要包括以下几种情况：</p>
<ol>
<li>编译器会进行优化，检查方法名是否以<code>alloc/new/copy/mutableCopy</code>开始，如果不是则自动将返回对象注册到<code>Autoreleasepool</code>;</li>
<li>访问附有<code>__weak</code>修饰符的变量时，实际上必定要访问注册到<code>Autoreleasepool</code>的对象，即会自动加入<code>Autoreleasepool</code>;</li>
<li><code>id</code>的指针或对象的指针(<code>id*</code>，<code>NSError**</code>)，在没有显式地指定修饰符时候，会被默认附加上<code>__autoreleasing</code>修饰符，加入<code>Autoreleasepool</code></li>
</ol>
<p><strong>注意：</strong>如果编译器版本为<code>LLVM.3.0</code>以上，即使<code>ARC</code>无效<code>@autoreleasepool</code>块也能够使用；如下源码所示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MRC环境下的测试：</span></span><br><span class="line"><span class="meta">@autoreleasepool</span>&#123;</span><br><span class="line">    id obj <span class="operator">=</span> [[<span class="type">NSObject</span> alloc] <span class="keyword">init</span>];</span><br><span class="line">    [obj autorelease];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-NSAutoreleasePool与-autoreleasepool的区别"><a href="#3-NSAutoreleasePool与-autoreleasepool的区别" class="headerlink" title="3.NSAutoreleasePool与@autoreleasepool的区别"></a>3.NSAutoreleasePool与@autoreleasepool的区别</h5><ol>
<li><code>MRC</code>中使用<code>NSAutoreleasePool</code>，<code>ARC</code>中使用<code>@autoreleasepool</code>;</li>
<li><code>NSAutoreleasePool</code>对象作用于进行时，<code>@autoreleasepool</code>作用于编译阶段；</li>
</ol>
<h4 id="二、AutoRelease原理"><a href="#二、AutoRelease原理" class="headerlink" title="二、AutoRelease原理"></a>二、AutoRelease原理</h4><h5 id="2-1-使用-autoreleasepool"><a href="#2-1-使用-autoreleasepool" class="headerlink" title="2.1 使用@autoreleasepool{}"></a>2.1 使用@autoreleasepool{}</h5><p>我们在<code>main</code>函数中写入自动释放池相关的测试代码如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char <span class="operator">*</span> argv[]) &#123;</span><br><span class="line">    <span class="meta">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="type">NSLog</span>(@<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了探究释放池的底层实现，我们在终端使用<code>clang -rewrite-objc + 文件名</code>命令将上述<code>OC</code>代码转化为<code>C++</code>源码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* @autoreleasepool */</span></span><br><span class="line">    &#123;</span><br><span class="line">        __AtAutoreleasePool __autoreleasepool;</span><br><span class="line">        <span class="built_in">NSLog</span>((NSString *)&amp;__NSConstantStringImpl__var_folders_3f_crl5bnj956d806cp7d3ctqhm0000gn_T_main_d37e0d_mi_0);</span><br><span class="line">     &#125;<span class="comment">//大括号对应释放池的作用域</span></span><br><span class="line">     </span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在经过编译器<code>clang</code>命令转化后，我们看到的所谓的<code>@autoreleasePool</code>块，其实对应着<code>__AtAutoreleasePool</code>的结构体。</p>
<h5 id="2-2-分析结构体-AtAutoreleasePool的具体实现"><a href="#2-2-分析结构体-AtAutoreleasePool的具体实现" class="headerlink" title="2.2 分析结构体__AtAutoreleasePool的具体实现"></a>2.2 分析结构体__AtAutoreleasePool的具体实现</h5><p>在源码中找到<code>__AtAutoreleasePool</code>结构体的实现代码，具体如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> __declspec(dllimport) <span class="function"><span class="type">void</span> * <span class="title">objc_autoreleasePoolPush</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> __declspec(dllimport) <span class="function"><span class="type">void</span> <span class="title">objc_autoreleasePoolPop</span><span class="params">(<span class="type">void</span> *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__AtAutoreleasePool</span> &#123;</span><br><span class="line">  __AtAutoreleasePool() &#123;atautoreleasepoolobj = <span class="built_in">objc_autoreleasePoolPush</span>();&#125;</span><br><span class="line">  ~__AtAutoreleasePool() &#123;<span class="built_in">objc_autoreleasePoolPop</span>(atautoreleasepoolobj);&#125;</span><br><span class="line">  <span class="type">void</span> * atautoreleasepoolobj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>__AtAutoreleasePool</code>结构体包含了：构造函数、析构函数和一个边界对象；</p>
<ol>
<li>构造函数内部调用：<code>objc_autoreleasePoolPush()</code>方法，返回边界对象<code>atautoreleasepoolobj</code></li>
<li>析构函数内部调用：<code>objc_autoreleasePoolPop()</code>方法，传入边界对象<code>atautoreleasepoolobj</code></li>
</ol>
<p>分析<code>main</code>函数中<code>__autoreleasepool</code>结构体实例的生命周期是这样的：</p>
<ol>
<li><code>__autoreleasepool</code>是一个自动变量，其构造函数是在程序执行到声明这个对象的位置时调用的，</li>
<li>而其析构函数则是在程序执行到离开这个对象的作用域时调用。</li>
</ol>
<p>所以，我们可以将上面<code>main</code>函数的代码简化如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char <span class="operator">*</span> argv[]) &#123;</span><br><span class="line">    <span class="comment">/* @autoreleasepool */</span> &#123;</span><br><span class="line">        void <span class="operator">*</span>atautoreleasepoolobj <span class="operator">=</span> objc_autoreleasePoolPush();</span><br><span class="line">        <span class="type">NSLog</span>((<span class="type">NSString</span> <span class="operator">*</span>)<span class="operator">&amp;</span>__NSConstantStringImpl__var_folders_kb_06b822gn59df4d1zt99361xw0000gn_T_main_d39a79_mi_0);</span><br><span class="line">        objc_autoreleasePoolPop(atautoreleasepoolobj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-3-objc-autoreleasePoolPush与objc-autoreleasePoolPop"><a href="#2-3-objc-autoreleasePoolPush与objc-autoreleasePoolPop" class="headerlink" title="2.3 objc_autoreleasePoolPush与objc_autoreleasePoolPop"></a>2.3 objc_autoreleasePoolPush与objc_autoreleasePoolPop</h5><p>进一步观察自动释放池构造函数与析构函数的实现，其实它们都只是对<code>AutoreleasePoolPage</code>对应静态方法<code>push</code>和<code>pop</code>的封装</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *<span class="title">objc_autoreleasePoolPush</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> AutoreleasePoolPage::<span class="built_in">push</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">objc_autoreleasePoolPop</span><span class="params">(<span class="type">void</span> *ctxt)</span> </span>&#123;</span><br><span class="line">    AutoreleasePoolPage::<span class="built_in">pop</span>(ctxt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-4-理解AutoreleasePoolPage"><a href="#2-4-理解AutoreleasePoolPage" class="headerlink" title="2.4 理解AutoreleasePoolPage"></a>2.4 理解AutoreleasePoolPage</h5><p><code>AutoreleasePoolPage</code>是一个<code>C++</code>中的类，打开<code>Runtime</code>的源码工程，在<code>NSObject.mm</code>文件中可以找到它的定义，摘取其中的关键代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//大致在641行代码开始</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AutoreleasePoolPage</span> &#123;</span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> EMPTY_POOL_PLACEHOLDER ((id*)1)  <span class="comment">//空池占位</span></span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> POOL_BOUNDARY nil                <span class="comment">//边界对象(即哨兵对象）</span></span></span><br><span class="line">    <span class="type">static</span> <span class="type">pthread_key_t</span> <span class="type">const</span> key = AUTORELEASE_POOL_KEY;</span><br><span class="line">    <span class="type">static</span> <span class="type">uint8_t</span> <span class="type">const</span> SCRIBBLE = <span class="number">0xA3</span>;  <span class="comment">// 0xA3A3A3A3 after releasing</span></span><br><span class="line">    <span class="type">static</span> <span class="type">size_t</span> <span class="type">const</span> SIZE = </span><br><span class="line"><span class="meta">#<span class="keyword">if</span> PROTECT_AUTORELEASEPOOL</span></span><br><span class="line">        PAGE_MAX_SIZE;  <span class="comment">// must be multiple of vm page size</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        PAGE_MAX_SIZE;  <span class="comment">// size and alignment, power of 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">static</span> <span class="type">size_t</span> <span class="type">const</span> COUNT = SIZE / <span class="built_in">sizeof</span>(id);</span><br><span class="line">    <span class="type">magic_t</span> <span class="type">const</span> magic;                  <span class="comment">//校验AutoreleasePagePoolPage结构是否完整</span></span><br><span class="line">    id *next;                             <span class="comment">//指向新加入的autorelease对象的下一个位置，初始化时指向begin()</span></span><br><span class="line">    <span class="type">pthread_t</span> <span class="type">const</span> thread;               <span class="comment">//当前所在线程，AutoreleasePool是和线程一一对应的</span></span><br><span class="line">    AutoreleasePoolPage * <span class="type">const</span> parent;   <span class="comment">//指向父节点page，第一个结点的parent值为nil</span></span><br><span class="line">    AutoreleasePoolPage *child;           <span class="comment">//指向子节点page，最后一个结点的child值为nil</span></span><br><span class="line">    <span class="type">uint32_t</span> <span class="type">const</span> depth;                 <span class="comment">//链表深度，节点个数</span></span><br><span class="line">    <span class="type">uint32_t</span> hiwat;                       <span class="comment">//数据容纳的一个上限</span></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其实，<strong>每个自动释放池都是是由若干个<code>AutoreleasePoolPage</code>组成的双向链表结构</strong>，如下图所示:<br><img src="http://182.92.228.41/wp-content/uploads/autoreleasepool_autoreleasepoolpage_struct.png" width="1000" hegiht="313" align=center/></p>
<p><code>AutoreleasePoolPage</code>中拥有<code>parent</code>和<code>child</code>指针，分别指向上一个和下一个<code>page</code>；当前一个<code>page</code>的空间被占满(每个<code>AutorelePoolPage</code>的大小为4096字节)时，就会新建一个<code>AutorelePoolPage</code>对象并连接到链表中，后来的  Autorelease对象也会添加到新的<code>page</code>中；</p>
<p>另外，当<code>next== begin()</code>时，表示<code>AutoreleasePoolPage</code>为空；当<code>next == end()</code>，表示<code>AutoreleasePoolPage</code>已满。</p>
<h5 id="2-5-理解哨兵对象-x2F-边界对象-POOL-BOUNDARY-的作用"><a href="#2-5-理解哨兵对象-x2F-边界对象-POOL-BOUNDARY-的作用" class="headerlink" title="2.5 理解哨兵对象&#x2F;边界对象(POOL_BOUNDARY)的作用"></a>2.5 理解哨兵对象&#x2F;边界对象(POOL_BOUNDARY)的作用</h5><p>在<code>AutoreleasePoolPage</code>的源码中，我们很容易找到边界对象(哨兵对象)的定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> POOL_BOUNDARY nil</span></span><br></pre></td></tr></table></figure>
<p>边界对象其实就是<code>nil</code>的别名，而它的作用事实上也就是为了起到一个标识的作用。</p>
<p>每当自动释放池初始化调用<code>objc_autoreleasePoolPush</code>方法时，总会通过<code>AutoreleasePoolPage</code>的<code>push</code>方法，将<code>POOL_BOUNDARY</code>放到当前<code>page</code>的栈顶，并且返回这个边界对象；</p>
<p>而在自动释放池释放调用<code>objc_autoreleasePoolPop</code>方法时，又会将边界对象以参数传入，这样自动释放池就会向释放池中对象发送<code>release</code>消息，直至找到第一个边界对象为止。</p>
<h5 id="2-6-理解objc-autoreleasePoolPush方法"><a href="#2-6-理解objc-autoreleasePoolPush方法" class="headerlink" title="2.6 理解objc_autoreleasePoolPush方法"></a>2.6 理解objc_autoreleasePoolPush方法</h5><p>经过前面的分析，<code>objc_autoreleasePoolPush</code>最终调用的是    <code>AutoreleasePoolPage</code>的<code>push</code>方法，该方法的具体实现如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> inline void <span class="operator">*</span>push() &#123;</span><br><span class="line">   <span class="keyword">return</span> autoreleaseFast(<span class="type">POOL_BOUNDARY</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> inline id <span class="operator">*</span>autoreleaseFast(id obj)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">AutoreleasePoolPage</span> <span class="operator">*</span>page <span class="operator">=</span> hotPage();</span><br><span class="line">   <span class="keyword">if</span> (page <span class="operator">&amp;&amp;</span> <span class="operator">!</span>page-&gt;full()) &#123;</span><br><span class="line">       <span class="keyword">return</span> page-&gt;add(obj);</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (page) &#123;</span><br><span class="line">       <span class="keyword">return</span> autoreleaseFullPage(obj, page);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="number">1</span>.        <span class="keyword">return</span> autoreleaseNoPage(obj);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//压栈操作：将对象加入AutoreleaseNoPage并移动栈顶的指针</span></span><br><span class="line">id <span class="operator">*</span>add(id obj) &#123;</span><br><span class="line">    id <span class="operator">*</span>ret <span class="operator">=</span> next;</span><br><span class="line">    <span class="operator">*</span>next <span class="operator">=</span> obj;</span><br><span class="line">    next<span class="operator">++</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当前hotPage已满时调用</span></span><br><span class="line"><span class="keyword">static</span> id <span class="operator">*</span>autoreleaseFullPage(id obj, <span class="type">AutoreleasePoolPage</span> <span class="operator">*</span>page) &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (page-&gt;child) page <span class="operator">=</span> page-&gt;child;</span><br><span class="line">        <span class="keyword">else</span> page <span class="operator">=</span> new <span class="type">AutoreleasePoolPage</span>(page);</span><br><span class="line">    &#125; <span class="keyword">while</span> (page-&gt;full());</span><br><span class="line"></span><br><span class="line">    setHotPage(page);</span><br><span class="line">    <span class="keyword">return</span> page-&gt;add(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当前hotpage不存在时调用</span></span><br><span class="line"><span class="keyword">static</span> id <span class="operator">*</span>autoreleaseNoPage(id obj) &#123;</span><br><span class="line">    <span class="type">AutoreleasePoolPage</span> <span class="operator">*</span>page <span class="operator">=</span> new <span class="type">AutoreleasePoolPage</span>(<span class="literal">nil</span>);</span><br><span class="line">    setHotPage(page);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (obj <span class="operator">!=</span> <span class="type">POOL_SENTINEL</span>) &#123;</span><br><span class="line">        page-&gt;add(<span class="type">POOL_SENTINEL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> page-&gt;add(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>观察上述代码，每次调用<code>push</code>其实就是创建一个新的AutoreleasePool，在对应的<code>AutoreleasePoolPage</code>中插入一个<code>POOL_BOUNDARY</code> ，并且返回插入的<code>POOL_BOUNDARY</code> 的内存地址。<code>push</code>方法内部调用的是<code>autoreleaseFast</code>方法，并传入边界对象(<code>POOL_BOUNDARY</code>)；</p>
<p><code>hotPage</code>可以理解为当前正在使用的<code>AutoreleasePoolPage</code>；</p>
<p>自动释放池最终都会通过<code>page-&gt;add(obj)</code>方法将边界对象添加到释放池中，而这一过程在<code>autoreleaseFast</code>方法中被分为三种情况：</p>
<ol>
<li>当前<code>page</code>存在且不满，调用<code>page-&gt;add(obj)</code>方法将对象添加至<code>page</code>的栈中，即<code>next</code>指向的位置</li>
<li>当前<code>page</code>存在但是已满，调用<code>autoreleaseFullPage</code>初始化一个新的<code>page</code>，调用<code>page-&gt;add(obj)</code>方法将对象添加至<code>page</code>的栈中</li>
<li>当前<code>page</code>不存在时，调用<code>autoreleaseNoPage</code>创建一个<code>hotPage</code>，再调用<code>page-&gt;add(obj)</code> 方法将对象添加至<code>page</code>的栈中</li>
</ol>
<h5 id="2-7-objc-autoreleasePoolPop方法"><a href="#2-7-objc-autoreleasePoolPop方法" class="headerlink" title="2.7 objc_autoreleasePoolPop方法"></a>2.7 objc_autoreleasePoolPop方法</h5><p><code>AutoreleasePool</code>的释放调用的是<code>objc_autoreleasePoolPop</code>方法，此时需要传入边界对象作为参数。这个边界对象正是每次执行<code>objc_autoreleasePoolPush</code>方法返回的对象<code>atautoreleasepoolobj</code>；</p>
<p>同理，我们找到<code>objc_autoreleasePoolPop</code>最终调用的方法，即<code>AutoreleasePoolPage</code>的<code>pop</code>方法，该方法的具体实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title">pop</span><span class="params">(<span class="type">void</span> *token)</span>   <span class="comment">//POOL_BOUNDARY的地址</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AutoreleasePoolPage *page;</span><br><span class="line">    id *stop;</span><br><span class="line"></span><br><span class="line">    page = <span class="built_in">pageForPointer</span>(token);   <span class="comment">//通过POOL_BOUNDARY找到对应的page</span></span><br><span class="line">    stop = (id *)token;</span><br><span class="line">    <span class="keyword">if</span> (DebugPoolAllocation  &amp;&amp;  *stop != POOL_SENTINEL) &#123;</span><br><span class="line">        <span class="comment">// This check is not valid with DebugPoolAllocation off</span></span><br><span class="line">        <span class="comment">// after an autorelease with a pool page but no pool in place.</span></span><br><span class="line">        _objc_fatal(<span class="string">&quot;invalid or prematurely-freed autorelease pool %p; &quot;</span>, </span><br><span class="line">                    token);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (PrintPoolHiwat) <span class="built_in">printHiwat</span>();   <span class="comment">// 记录最高水位标记</span></span><br><span class="line"></span><br><span class="line">    page-&gt;<span class="built_in">releaseUntil</span>(stop);   <span class="comment">//向栈中的对象发送release消息，直到遇到第一个哨兵对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// memory: delete empty children</span></span><br><span class="line">    <span class="comment">// 删除空掉的节点</span></span><br><span class="line">    <span class="keyword">if</span> (DebugPoolAllocation  &amp;&amp;  page-&gt;<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="comment">// special case: delete everything during page-per-pool debugging</span></span><br><span class="line">        AutoreleasePoolPage *parent = page-&gt;parent;</span><br><span class="line">        page-&gt;<span class="built_in">kill</span>();</span><br><span class="line">        <span class="built_in">setHotPage</span>(parent);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (DebugMissingPools  &amp;&amp;  page-&gt;<span class="built_in">empty</span>()  &amp;&amp;  !page-&gt;parent) &#123;</span><br><span class="line">        <span class="comment">// special case: delete everything for pop(top) </span></span><br><span class="line">        <span class="comment">// when debugging missing autorelease pools</span></span><br><span class="line">        page-&gt;<span class="built_in">kill</span>();</span><br><span class="line">        <span class="built_in">setHotPage</span>(nil);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (page-&gt;child) &#123;</span><br><span class="line">        <span class="comment">// hysteresis: keep one empty child if page is more than half full</span></span><br><span class="line">        <span class="keyword">if</span> (page-&gt;<span class="built_in">lessThanHalfFull</span>()) &#123;</span><br><span class="line">            page-&gt;child-&gt;<span class="built_in">kill</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (page-&gt;child-&gt;child) &#123;</span><br><span class="line">            page-&gt;child-&gt;child-&gt;<span class="built_in">kill</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码中，首先根据传入的边界对象地址找到边界对象所处的<code>page</code>；然后选择当前<code>page</code>中最新加入的对象一直向前清理，可以向前跨越若干个<code>page</code>，直到边界所在的位置；清理的方式是向这些对象发送一次<code>release</code>消息，使其引用计数减一；</p>
<p>另外，清空<code>page</code>对象还会遵循一些原则：</p>
<ol>
<li>如果当前的<code>page</code>中存放的对象少于一半，则子<code>page</code>全部删除；</li>
<li>如果当前当前的<code>page</code>存放的多余一半（意味着马上将要满），则保留一个子<code>page</code>，节省创建新<code>page</code>的开销;</li>
</ol>
<h5 id="2-8-autorelease方法"><a href="#2-8-autorelease方法" class="headerlink" title="2.8 autorelease方法"></a>2.8 autorelease方法</h5><p>上述是对自动释放池整个生命周期的分析，现在我们来理解延时释放对象<code>autorelease</code>方法的实现，首先查看该方法的调用栈：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- [NSObject autorelease]</span><br><span class="line">└── <span class="function">id <span class="title">objc_object::rootAutorelease</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    └── id <span class="title">objc_object::rootAutorelease2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        └── <span class="type">static</span> id <span class="title">AutoreleasePoolPage::autorelease</span><span class="params">(id obj)</span></span></span><br><span class="line"><span class="function">            └── <span class="type">static</span> id <span class="title">AutoreleasePoolPage::autoreleaseFast</span><span class="params">(id obj)</span></span></span><br><span class="line"><span class="function">                ├── id *<span class="title">add</span><span class="params">(id obj)</span></span></span><br><span class="line"><span class="function">                ├── <span class="type">static</span> id *<span class="title">autoreleaseFullPage</span><span class="params">(id obj, AutoreleasePoolPage *page)</span></span></span><br><span class="line"><span class="function">                │   ├── <span class="title">AutoreleasePoolPage</span><span class="params">(AutoreleasePoolPage *newParent)</span></span></span><br><span class="line"><span class="function">                │   └── id *<span class="title">add</span><span class="params">(id obj)</span></span></span><br><span class="line"><span class="function">                └── <span class="type">static</span> id *<span class="title">autoreleaseNoPage</span><span class="params">(id obj)</span></span></span><br><span class="line"><span class="function">                    ├── <span class="title">AutoreleasePoolPage</span><span class="params">(AutoreleasePoolPage *newParent)</span></span></span><br><span class="line"><span class="function">                    └── id *<span class="title">add</span><span class="params">(id obj)</span></span></span><br></pre></td></tr></table></figure>
<p>如上所示，<code>autorelease</code>方法最终也会调用上面提到的 <code>autoreleaseFast</code>方法，将当前对象加到<code>AutoreleasePoolPage</code>中。关于<code>autoreleaseFast</code>的分析这里不再累述，我们主要来考虑一下两次调用的区别：</p>
<p><code>autorelease</code>函数和<code>push</code>函数一样，关键代码都是调用<code>autoreleaseFast</code>函数向自动释放池的链表栈中添加一个对象，不过<code>push</code>函数入栈的是一个边界对象，而<code>autorelease</code>函数入栈的是一个具体的Autorelease的对象。</p>
<h4 id="三、AutoreleasePool与NSThread、NSRunLoop的关系"><a href="#三、AutoreleasePool与NSThread、NSRunLoop的关系" class="headerlink" title="三、AutoreleasePool与NSThread、NSRunLoop的关系"></a>三、AutoreleasePool与NSThread、NSRunLoop的关系</h4><p>由于<code>AppKit</code>和<code>UIKit</code>框架的优化，我们很少需要显式的创建一个自动释放池块。这其中就涉及到<code>AutoreleasePool</code>与<code>NSThread</code>、<code>NSRunLoop</code>的关系。</p>
<h5 id="3-1-RunLoop和NSThread的关系"><a href="#3-1-RunLoop和NSThread的关系" class="headerlink" title="3.1 RunLoop和NSThread的关系"></a>3.1 RunLoop和NSThread的关系</h5><p><code>RunLoop</code>是用于控制线程生命周期并接收事件进行处理的机制，其实质是一个<code>do-While</code>循环。在苹果文档找到关于<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsrunloop#//apple_ref/doc/constant_group/Run_Loop_Modes">NSRunLoop</a>的介绍如下：</p>
<blockquote>
<p>Your application neither creates or explicitly manages NSRunLoop objects. Each NSThread object—including the application’s main thread—has an NSRunLoop object automatically created for it as needed. If you need to access the current thread’s run loop, you do so with the class method currentRunLoop.</p>
</blockquote>
<p>总结<code>RunLoop</code>与<code>NSThread</code>(线程)之间的关系如下：</p>
<ol>
<li><code>RunLoop</code>与线程是一一对应关系，每个线程(包括主线程)都有一个对应的<code>RunLoop</code>对象；其对应关系保存在一个全局的<code>Dictionary</code>里；</li>
<li>主线程的<code>RunLoop</code>默认由系统自动创建并启动；而其他线程在创建时并没有<code>RunLoop</code>，若该线程一直不主动获取，就一直不会有<code>RunLoop</code>；</li>
<li>苹果不提供直接创建<code>RunLoop</code>的方法；所谓其他线程<code>Runloop</code>的创建其实是发生在第一次获取的时候，系统判断当前线程没有<code>RunLoop</code>就会自动创建；</li>
<li>当前线程结束时，其对应的<code>Runloop</code>也被销毁；</li>
</ol>
<h5 id="3-2-RunLoop和AutoreleasePool的关系"><a href="#3-2-RunLoop和AutoreleasePool的关系" class="headerlink" title="3.2 RunLoop和AutoreleasePool的关系"></a>3.2 RunLoop和AutoreleasePool的关系</h5><p>在<a target="_blank" rel="noopener" href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSAutoreleasePool_Class/index.html#//apple_ref/doc/uid/TP40003623">苹果文档</a>中找到两者关系的介绍如下：</p>
<blockquote>
<p>The Application Kit creates an autorelease pool on the main thread at the beginning of every cycle of the event loop, and drains it at the end, thereby releasing any autoreleased objects generated while processing an event.</p>
</blockquote>
<p>如上所述，主线程的<code>NSRunLoop</code>在监测到事件响应开启每一次<code>event loop</code>之前，会自动创建一个<code>autorelease pool</code>，并且会在<code>event loop</code>结束的时候执行<code>drain</code>操作，释放其中的对象。</p>
<h5 id="3-3-Thread和AutoreleasePool的关系"><a href="#3-3-Thread和AutoreleasePool的关系" class="headerlink" title="3.3 Thread和AutoreleasePool的关系"></a>3.3 Thread和AutoreleasePool的关系</h5><p>在<a target="_blank" rel="noopener" href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSAutoreleasePool_Class/index.html#//apple_ref/doc/uid/TP40003623">苹果文档</a>中找到两者关系的介绍如下：</p>
<blockquote>
<p>Each thread (including the main thread) maintains its own stack of NSAutoreleasePool objects (see Threads). As new pools are created, they get added to the top of the stack. When pools are deallocated, they are removed from the stack. Autoreleased objects are placed into the top autorelease pool for the current thread. When a thread terminates, it automatically drains all of the autorelease pools associated with itself.</p>
</blockquote>
<p>如上所述， 包括主线程在内的所有线程都维护有它自己的自动释放池的堆栈结构。新的自动释放池被创建的时候，它们会被添加到栈的顶部，而当池子销毁的时候，会从栈移除。对于当前线程来说，Autoreleased对象会被放到栈顶的自动释放池中。当一个线程线程停止，它会自动释放掉与其关联的所有自动释放池。</p>
<h4 id="四、AutoreleasePool在主线程上的释放时机"><a href="#四、AutoreleasePool在主线程上的释放时机" class="headerlink" title="四、AutoreleasePool在主线程上的释放时机"></a>四、AutoreleasePool在主线程上的释放时机</h4><h5 id="4-1-理解主线程上的自动释放过程"><a href="#4-1-理解主线程上的自动释放过程" class="headerlink" title="4.1 理解主线程上的自动释放过程"></a>4.1 理解主线程上的自动释放过程</h5><p>分析主线程<code>RunLoop</code>管理自动释放池并释放对象的详细过程，我们在如下<code>Demo</code>中的主线程中设置断点，并执行<code>lldb</code>命令：<code>po [NSRunLoop currentRunLoop]</code>，具体效果如下：<br><img src="http://182.92.228.41/wp-content/uploads/autoreleasepool_mian_thread_release_time.png" width="1000" hegiht="313" align=center/></p>
<p>我们看到主线程<code>RunLoop</code>中有两个与自动释放池相关的<code>Observer</code>，它们的 <code>activities</code>分别为<code>0x1</code>和<code>0xa0</code>这两个十六进制的数，转为二进制分别为<code>1</code>和<code>10100000</code>，对应<code>CFRunLoopActivity</code>的类型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Run Loop Observer Activities */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">CF_OPTIONS</span><span class="params">(CFOptionFlags, CFRunLoopActivity)</span> &#123;</span><br><span class="line">    kCFRunLoopEntry = (<span class="number">1UL</span> &lt;&lt; <span class="number">0</span>),          <span class="comment">//0x1，启动Runloop循环</span></span><br><span class="line">    kCFRunLoopBeforeTimers = (<span class="number">1UL</span> &lt;&lt; <span class="number">1</span>),            </span><br><span class="line">    kCFRunLoopBeforeSources = (<span class="number">1UL</span> &lt;&lt; <span class="number">2</span>),        </span><br><span class="line">    kCFRunLoopBeforeWaiting = (<span class="number">1UL</span> &lt;&lt; <span class="number">5</span>),  <span class="comment">//0xa0，即将进入休眠     </span></span><br><span class="line">    kCFRunLoopAfterWaiting = (<span class="number">1UL</span> &lt;&lt; <span class="number">6</span>),   </span><br><span class="line">    kCFRunLoopExit = (<span class="number">1UL</span> &lt;&lt; <span class="number">7</span>),           <span class="comment">//0xa0，退出RunLoop循环  </span></span><br><span class="line">    kCFRunLoopAllActivities = <span class="number">0x0FFFFFFF</span>U</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<p>结合<code>RunLoop</code>监听的事件类型，分析主线程上自动释放池的使用过程如下：</p>
<ol>
<li><code>App</code>启动后，苹果在主线程<code>RunLoop</code>里注册了两个<code>Observer</code>，其回调都是 <code>_wrapRunLoopWithAutoreleasePoolHandler()</code>;</li>
<li>第一个<code>Observer</code>监视的事件是<code>Entry</code>(即将进入<code>Loop</code>)，其回调内会调用 <code>_objc_autoreleasePoolPush()</code>创建自动释放池。<code>order = -2147483647</code>(即<code>32</code>位整数最小值)表示其优先级最高，可以保证创建释放池发生在其他所有回调之前;</li>
<li>第二个<code>Observer</code>监视了两个事件：<ol>
<li><code>BeforeWaiting</code>(准备进入休眠)时，调用<code>_objc_autoreleasePoolPop()</code>和<code>_objc_autoreleasePoolPush()</code>释放旧的池并创建新池；</li>
<li><code>Exit</code>(即将退出<code>Loop</code>) 时，调用 <code>_objc_autoreleasePoolPop()</code>来释放自动释放池。<code>order =  2147483647</code>(即<code>32</code>位整数的最大值)表示其优先级最低，保证其释放池子发生在其他所有回调之后;</li>
</ol>
</li>
<li>在主线程执行的代码，通常是写在诸如事件回调、<code>Timer</code>回调内的。这些回调会被 <code>RunLoop</code>创建好的<code>AutoreleasePool</code>环绕着，所以不会出现内存泄漏，开发者也不必显示创建<code>AutoreleasePool</code>了;</li>
</ol>
<p>最后，也可以结合图示理解主线程上自动释放对象的具体流程：<br><img src="http://182.92.228.41/wp-content/uploads/autoreleasepool_system_release_rules.png" width="500" hegiht="313" align=center/></p>
<ol>
<li>程序启动到加载完成后，主线程对应的<code>RunLoop</code>会停下来等待用户交互</li>
<li>用户的每一次交互都会启动一次运行循环，来处理用户所有的点击事件、触摸事件。</li>
<li><code>RunLoop</code>检测到事件后，就会创建自动释放池;</li>
<li>所有的延迟释放对象都会被添加到这个池子中;</li>
<li>在一次完整的运行循环结束之前，会向池中所有对象发送<code>release</code>消息，然后自动释放池被销毁;</li>
</ol>
<h5 id="4-2-测试主线程上的对象自动释放过程"><a href="#4-2-测试主线程上的对象自动释放过程" class="headerlink" title="4.2 测试主线程上的对象自动释放过程"></a>4.2 测试主线程上的对象自动释放过程</h5><p>下面的代码创建了一个<code>Autorelease</code>对象<code>string</code>，并且通过<code>weakString</code>进行弱引用(不增加引用计数，所以不会影响对象的生命周期)，具体如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@interface</span> <span class="type">TestMemoryVC</span> ()</span><br><span class="line"><span class="meta">@property</span> (nonatomic,<span class="keyword">weak</span>)<span class="type">NSString</span> <span class="operator">*</span>weakString;</span><br><span class="line"><span class="meta">@end</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@implementation</span> <span class="type">TestMemoryVC</span></span><br><span class="line"><span class="operator">-</span> (void)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="type">NSString</span> <span class="operator">*</span>string <span class="operator">=</span> [<span class="type">NSString</span> stringWithFormat:@<span class="string">&quot;%@&quot;</span>,@<span class="string">&quot;WUYUBEICHEN&quot;</span>];</span><br><span class="line">    <span class="keyword">self</span>.weakString <span class="operator">=</span> string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> (void)viewWillAppear:(<span class="type">BOOL</span>)animated &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewWillAppear:animated];</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;viewWillAppear:%@&quot;</span>, <span class="keyword">self</span>.weakString);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> (void)viewDidAppear:(<span class="type">BOOL</span>)animated &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidAppear:animated];</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;viewDidAppear:%@&quot;</span>, <span class="keyword">self</span>.weakString);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//打印结果：</span></span><br><span class="line"><span class="comment">//viewWillAppear:WUYUBEICHEN</span></span><br><span class="line"><span class="comment">//viewDidAppear:(null)</span></span><br></pre></td></tr></table></figure>
<p><strong>代码分析：</strong></p>
<ol>
<li><code>viewDidLoad</code>和<code>viewWillAppear</code>是在同一个 <code>runloop</code> 调用的，因此在 <code>viewWillAppear</code>中，这个<code>autorelease</code>的变量依然有值；</li>
<li>自动变量<code>string</code>在离开<code>viewDidLoad</code>作用域后，会依靠当前主线程上的<code>RunLoop</code>迭代自动释放；</li>
<li>最终<code>string</code>对象在<code>viewDidAppear</code>方法执行前被释放(即<code>RunLoop</code>完成此次迭代)。</li>
</ol>
<h4 id="五、AutoreleasePool子线程上的释放时机"><a href="#五、AutoreleasePool子线程上的释放时机" class="headerlink" title="五、AutoreleasePool子线程上的释放时机"></a>五、AutoreleasePool子线程上的释放时机</h4><p>子线程默认不开启<code>RunLoo</code>，那么其中的延时对象该如何释放呢？其实这依然要从<code>Thread</code>和<code>AutoreleasePool</code>的关系来考虑：</p>
<blockquote>
<p>Each thread (including the main thread) maintains its own stack of NSAutoreleasePool objects.  </p>
</blockquote>
<p>也就是说，每一个线程都会维护自己的 <code>Autoreleasepool</code>栈，所以子线程虽然默认没有开启<code>RunLoop</code>，但是依然存在<code>AutoreleasePool</code>，在子线程退出的时候会去释放<code>autorelease</code>对象。</p>
<p>前面讲到过，<code>ARC</code>会根据一些情况进行优化，添加<code>__autoreleasing</code>修饰符，其实这就相当于对需要延时释放的对象调用了<code>autorelease</code>方法。从源码分析的角度来看，如果子线程中没有创建<code>AutoreleasePool</code> ，而一旦产生了<code>Autorelease</code>对象，就会调用<code>autoreleaseNoPage</code>方法自动创建<code>hotpage</code>，并将对象加入到其栈中。所以，一般情况下，子线程中即使我们不手动添加自动释放池，也不会产生内存泄漏。</p>
<h4 id="六、AutoreleasePool需要手动添加的情况"><a href="#六、AutoreleasePool需要手动添加的情况" class="headerlink" title="六、AutoreleasePool需要手动添加的情况"></a>六、AutoreleasePool需要手动添加的情况</h4><p>尽管<code>ARC</code>已经做了诸多优化，但是有些情况我们必须手动创建<code>AutoreleasePool</code>，而其中的延时对象将在当前释放池的作用域结束时释放。<a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmAutoreleasePools.html#//apple_ref/doc/uid/20000047">苹果文档</a>中说明了三种情况，我们可能会需要手动添加自动释放池：</p>
<ol>
<li>编写的不是基于UI框架的程序，例如命令行工具；</li>
<li>通过循环方式创建大量临时对象；</li>
<li>使用非<code>Cocoa</code>程序创建的子线程；</li>
</ol>
<p>而在<code>ARC</code>环境下的实际开发中，我们最常遇到的也是第二种情况，以下面的代码为例：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">-</span> (void)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="keyword">for</span> (int i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> <span class="number">1000000</span>; i<span class="operator">++</span>) &#123;</span><br><span class="line">        <span class="type">NSObject</span> <span class="operator">*</span>obj <span class="operator">=</span> [[<span class="type">NSObject</span> alloc] <span class="keyword">init</span>];</span><br><span class="line">        <span class="type">NSLog</span>(@<span class="string">&quot;打印obj：%@&quot;</span>, obj);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>代码分析：</p>
<ol>
<li>上述代码中，<code>obj</code>因为离开作用域所以会被加入最近一次创建的自动释放池中，而这个释放池就是主线程上的<code>RunLoop</code>管理的；</li>
<li>因为<code>for</code>循环在当前线程没有执行完毕，<code>Runloop</code>也就没有完成当前这一次的迭代，所以导致大量对象被延时释放。</li>
<li>释放池中的对象将会在<code>viewDidAppear</code>方法执行前就被销毁。</li>
<li>在此情况下，我们就有必要通过手动干预的方式及时释放不需要的对象，减少内存消耗；优化的代码如下：</li>
</ol>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">-</span> (void)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="keyword">for</span> (int i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> <span class="number">1000000</span>; i<span class="operator">++</span>) &#123;</span><br><span class="line">        <span class="meta">@autoreleasepool</span>&#123;</span><br><span class="line">             <span class="type">NSObject</span> <span class="operator">*</span>obj <span class="operator">=</span> [[<span class="type">NSObject</span> alloc] <span class="keyword">init</span>];</span><br><span class="line">             <span class="type">NSLog</span>(@<span class="string">&quot;打印obj：%@&quot;</span>, obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>




<h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><ol>
<li><a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsautoreleasepool?language=occ">苹果文档NSAutoreleasePool</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsrunloop#//apple_ref/doc/constant_group/Run_Loop_Modes">苹果文档NSRunLoop</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmAutoreleasePools.html#//apple_ref/doc/uid/20000047-CJBFBEDI">苹果文档Using Autorelease Pool Blocks</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wuyubeichen.github.io/2019/04/16/iOS%E5%BA%95%E5%B1%82-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Author">
      <meta itemprop="description" content="iOS Developer, Beijing China">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="梧雨北辰的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/16/iOS%E5%BA%95%E5%B1%82-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/" class="post-title-link" itemprop="url">iOS底层-内存管理基本概念</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-16 18:06:36" itemprop="dateCreated datePublished" datetime="2019-04-16T18:06:36+08:00">2019-04-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-29 09:39:32" itemprop="dateModified" datetime="2022-08-29T09:39:32+08:00">2022-08-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS%E5%BA%95%E5%B1%82/" itemprop="url" rel="index"><span itemprop="name">iOS底层</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>主要内容：</strong></p>
<ol>
<li>内存区域划分</li>
<li>内存管理&#x2F;引用计数</li>
<li><code>MRC</code>手动管理引用计数</li>
<li><code>ARC</code>自动引用计数</li>
<li><code>MRC</code>与<code>ARC</code>的切换</li>
<li>内存泄漏问题</li>
<li>野指针问题</li>
</ol>
<h4 id="一、内存区域划分"><a href="#一、内存区域划分" class="headerlink" title="一、内存区域划分"></a>一、内存区域划分</h4><p>程序在分配内存的时，主要分为：栈区、堆区、静态区、常量区、代码区；</p>
<table>
<thead>
<tr>
<th>内存区域</th>
<th>具体说明</th>
</tr>
</thead>
<tbody><tr>
<td>栈区</td>
<td>存放局部变量的值，系统自动分配和释放;<br>特点：容量小，速度快，有序</td>
</tr>
<tr>
<td>堆区</td>
<td>存放通过<code>malloc</code>系列函数或<code>new</code>操作符分配的内存，如对象；<br>一般由程序员分配和释放，如果不释放，则出现内存泄露;<br>特点：容量大，速度慢，无序；</td>
</tr>
<tr>
<td>静态区</td>
<td>存放全局变量和静态变量(包括静态局部变量和静态全局变量)；<br>当程序结束时，系统回收；</td>
</tr>
<tr>
<td>常量区</td>
<td>存放常量的内存区域；<br>程序结束时，系统回收；</td>
</tr>
<tr>
<td>代码区</td>
<td>存放二进制代码的区域</td>
</tr>
</tbody></table>
<p>从上述分类上看，我们在开发过程中主要涉及的是堆上内存的管理。通常，我们创建一个对象的代码如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NSObject</span> <span class="operator">*</span>obj <span class="operator">=</span> [[<span class="type">NSObject</span> alloc] <span class="keyword">init</span>]; </span><br></pre></td></tr></table></figure>
<p>上述代码创建了一个<code>NSObject</code>类型的指针<code>obj</code>和一个<code>NSObject</code>类型的对象。<code>obj</code>指针存在栈上，而其指向的对象则是在堆上。这种对象也称之为<strong>堆对象</strong>。</p>
<h4 id="二、内存管理-x2F-引用计数"><a href="#二、内存管理-x2F-引用计数" class="headerlink" title="二、内存管理&#x2F;引用计数"></a>二、内存管理&#x2F;引用计数</h4><h5 id="1-OC使用引用计数机制管理内存"><a href="#1-OC使用引用计数机制管理内存" class="headerlink" title="1.OC使用引用计数机制管理内存"></a>1.OC使用引用计数机制管理内存</h5><ol>
<li>无论是<code>MRC</code>还是<code>ARC</code>环境，<code>OC</code>都采用引用计数来管理内存；每个对象都有一个引用计数器，任何时候指向对象的指针个数和对象的引用计数相等；</li>
<li>每次<code>RunLoop</code>完成一次迭代循环，都会检查对象的引用计数，如果引用计数为<code>0</code>，说明这个对象没有地方在使用，将会被释放；</li>
<li><code>OC</code>管理内存涉及到对象的<code>&quot;生成&quot;</code>、<code>&quot;持有&quot;</code>、<code>&quot;释放&quot;</code>，<code>MRC</code>需要调用对应的方法来管理引用计数，而<code>ARC</code>则是自动管理引用计数，无需再调用这些内存管理的方法。</li>
</ol>
<p>虽然<code>MRC</code>和<code>ARC</code>两者管理内存的形式不同，但是它们都遵循相同的内存管理规律，内容如下：</p>
<ol>
<li>自己生成的对象，自己所持有;</li>
<li>非自己生成的对象，自己也能持有;</li>
<li>不再需要自己持有对象时，释放；</li>
<li>非自己持有的对象，无法释放；</li>
</ol>
<h4 id="三、MRC手动管理引用计数"><a href="#三、MRC手动管理引用计数" class="headerlink" title="三、MRC手动管理引用计数"></a>三、MRC手动管理引用计数</h4><ol>
<li><code>MRC</code>，即手动管理引用计数。当我们通过<code>alloc</code>、<code>retain</code>等方法持有对象后，也必须有相应的<code>release</code>或者<code>autorelease</code>将其释放。</li>
<li>即：在<code>MRC</code>模式下必须遵守：<code>谁创建谁释放</code>，<code>谁引用谁管理</code>；</li>
</ol>
<p>总结对象操作与<code>Objective-C</code>内存方法对应关系如下：</p>
<table>
<thead>
<tr>
<th>对象操作</th>
<th>OC方法</th>
</tr>
</thead>
<tbody><tr>
<td>生成并持有对象</td>
<td>以<code>alloc</code>&#x2F;<code>new</code>&#x2F;<code>copy</code>&#x2F;<code>mutableCopy</code>等名称开头方法</td>
</tr>
<tr>
<td>持有对象</td>
<td><code>retain</code>方法</td>
</tr>
<tr>
<td>释放对象</td>
<td><code>release</code>方法</td>
</tr>
<tr>
<td>废弃对象</td>
<td><code>dealloc</code>方法</td>
</tr>
</tbody></table>
<h5 id="1-自己生成的对象，自己所持有-x2F-非自己生成对象，不持有"><a href="#1-自己生成的对象，自己所持有-x2F-非自己生成对象，不持有" class="headerlink" title="1.自己生成的对象，自己所持有&#x2F;非自己生成对象，不持有"></a>1.自己生成的对象，自己所持有&#x2F;非自己生成对象，不持有</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">id obj <span class="operator">=</span> [[<span class="type">NSObject</span> alloc] <span class="keyword">init</span>];  <span class="comment">//自己生成并持有对象</span></span><br><span class="line">id obj1 <span class="operator">=</span> [<span class="type">NSMutableArray</span> array];  <span class="comment">//取得非自己生成的对象，但不持有对象</span></span><br></pre></td></tr></table></figure>
<p><code>OC</code>中使用<code>alloc</code>、<code>new</code>、<code>copy</code>、<code>mutableCopy</code>这些名称开头的方法意味着自己生成对象并持有，否则就是非自己生成的对象不持有。如上源码，使用<code>NSObject</code>类的<code>alloc</code>类方法就能自己生成并持有对象，指向生成并持有对象的指针被赋值给了<code>obj</code>。</p>
<p>通过自定义方法来理解这两种创建对象方法的区别(系统方法也是类似的实现)，测试代码如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以alloc开头的方法</span></span><br><span class="line"><span class="operator">-</span> (id)allocObject &#123;</span><br><span class="line">    id obj <span class="operator">=</span> [[<span class="type">NSObject</span> alloc] <span class="keyword">init</span>];</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> (id)object &#123;</span><br><span class="line">    id obj <span class="operator">=</span> [[<span class="type">NSObject</span> alloc] <span class="keyword">init</span>];</span><br><span class="line">    [obj autorelease];  <span class="comment">//用该方法，可以使取得的对象存在，但是自己不持有对象</span></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>autorelease</code>即自动释放，对象已经加入自动释放池，所以获取对象并不持有；涉及到的自动释放池的内容会在后续详细总结。</p>
<p><strong>注意：</strong>生成并持有对象的的方法一定是驼峰拼写来命名的方法，如<code>alloc</code>、<code>allocMyObject</code>等方法；相反<code>allocate</code>、<code>mutableCopyed</code>就不属于这类方法；</p>
<h5 id="2-非自己生成的对象，自己也能持有"><a href="#2-非自己生成的对象，自己也能持有" class="headerlink" title="2.非自己生成的对象，自己也能持有"></a>2.非自己生成的对象，自己也能持有</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">id obj1 <span class="operator">=</span> [<span class="type">NSMutableArray</span> array];  <span class="comment">//取得非自己生成的对象，但不持有对象</span></span><br><span class="line">[obj retain];                      <span class="comment">//通过retain方法，持有了对象</span></span><br></pre></td></tr></table></figure>
<p>源代码中，<code>NSMutableArray</code>类对象被赋值给变量<code>obj</code>，但是变量<code>obj</code>自己不持有该对象。使用<code>retain</code>方法后可以持有对象。</p>
<h5 id="3-不再需要自己持有对象时释放"><a href="#3-不再需要自己持有对象时释放" class="headerlink" title="3.不再需要自己持有对象时释放"></a>3.不再需要自己持有对象时释放</h5><p>自己持有的对象，一旦不需要，持有者有义务释放该对象，释放对象使用<code>release</code>方法。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">id obj <span class="operator">=</span> [[<span class="type">NSObject</span> alloc] <span class="keyword">init</span>]; <span class="comment">//自己生成并持有对象</span></span><br><span class="line">[obj release];                    <span class="comment">//释放自己持有的对象</span></span><br><span class="line"><span class="type">NSLog</span>(@<span class="string">&quot;%@&quot;</span>,obj);                 <span class="comment">//已经释放，再次使用会崩溃</span></span><br></pre></td></tr></table></figure>
<p>虽然指向对象的指针依然保留在变量<code>obj</code>中，看似可以访问，但对象一经释放就绝不可再访问。</p>
<h5 id="4-非自己持有的对象无法释放"><a href="#4-非自己持有的对象无法释放" class="headerlink" title="4.非自己持有的对象无法释放"></a>4.非自己持有的对象无法释放</h5><p>在应用程序中释放非自己持有的对象就会造成崩溃，使用代码演示如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//情况1：释放完不再需要的对象后再次释放，访问了已经废弃的对象而崩溃！</span></span><br><span class="line">id obj <span class="operator">=</span> [[<span class="type">NSObject</span> alloc] <span class="keyword">init</span>];</span><br><span class="line">[obj release];</span><br><span class="line">[obj release];</span><br><span class="line"></span><br><span class="line"><span class="comment">//情况2：取得自己并不持有的对象对其释放，释放了非自己持有的对象而崩溃！</span></span><br><span class="line">id obj <span class="operator">=</span> [[<span class="type">NSMutableArray</span> array];</span><br><span class="line">[obj release];</span><br></pre></td></tr></table></figure>


<h4 id="四、ARC自动引用计数"><a href="#四、ARC自动引用计数" class="headerlink" title="四、ARC自动引用计数"></a>四、ARC自动引用计数</h4><ol>
<li><code>ARC(Automic Reference Counting)</code>，即自动引用计数；</li>
<li>这是<code>iOS5</code>推出的新特性，<code>iOS4.3</code>也支持<code>ARC</code>，只是不能使用<code>weak</code>。</li>
<li><code>ARC</code>不再需要使用类似<code>retain</code>、<code>release</code>的操作来持有或者释放对象，从而大大提高了开发效率；</li>
</ol>
<h5 id="1-ARC使用条件"><a href="#1-ARC使用条件" class="headerlink" title="1.ARC使用条件"></a>1.ARC使用条件</h5><ol>
<li><code>Xcode4.2</code>或以上版本</li>
<li>使用<code>LLVM</code>编辑器<code>3.0</code>或以上版本</li>
<li><code>Xcode</code>编译器选项中设置<code>ARC</code>有效</li>
</ol>
<h5 id="2-ARC基本原理"><a href="#2-ARC基本原理" class="headerlink" title="2.ARC基本原理"></a>2.ARC基本原理</h5><ol>
<li><code>ARC</code>下的编译器会在代码编译阶段合适的位置，自动加入<code>retain/release/autorelease</code>的操作;</li>
<li><code>ARC</code>的规则：只要还有一个强引用指针指向对象，对象就会保存在内存中；</li>
<li><code>ARC</code>中使用<code>strong</code>和<code>weak</code>关键字来修饰对象；<code>strong</code>表示强引用，对应<code>MRC</code>下的<code>retain</code>；<code>weak</code>表示弱引用，对应原来的<code>assign</code>，不同的是当对象被释放的时候，对象<code>weak</code>指针自动赋值为<code>nil</code>，从而不会引发野指针错误；</li>
</ol>
<h5 id="3-ARC所有权修饰符"><a href="#3-ARC所有权修饰符" class="headerlink" title="3.ARC所有权修饰符"></a>3.ARC所有权修饰符</h5><p><code>ARC</code>有效时，<code>OC</code>处理<code>id</code>类型和对象类型必须附加所有权修饰符。所有权修饰符一共有四种：</p>
<ul>
<li><code>__strong</code></li>
<li><code>__weak</code></li>
<li><code>__unsafe_unretained</code></li>
<li><code>__autoreleasing</code></li>
</ul>
<p><strong>__strong修饰符:</strong><br><code>__strong</code>是<code>id</code>类型和对象类型默认的所有权修饰，表示对对象的”强引用”；当对象没有任何一个强引用指向它的时候，对象将被释放；</p>
<p><strong>__weak修饰符:</strong></p>
<ol>
<li><code>__weak</code>与<code>__strong</code>修饰符的作用相反，表示弱引用，不会增加引用计数；</li>
<li>当对象被释放后，所有指向它的弱引用都会被置为<code>nil</code>，这样避免了野指针问题。</li>
<li><code>__weak</code>修饰符常用于解决循环引用问题；</li>
<li><code>__weak</code>只能用于<code>iOS5</code>以上版本，更早的版本只能使用<code>__unsafe_unretained</code>修饰符。</li>
</ol>
<p><strong>__unsafe_unretained修饰符</strong></p>
<ol>
<li><code>__unsafe_unretained</code>提供弱引用，与<code>__weak</code>作用类似；</li>
<li><code>__unsafe_unretained</code>不能在对象释放后自动置为<code>nil</code>，易产生野指针问题；</li>
<li><code>__unsafe_unretained</code>可用于<code>iOS5</code>之前版本，为兼容<code>ARC</code>弱引用而引入；</li>
</ol>
<p><strong>__autoreleasing修饰符</strong><br>将对象赋值给附有<code>__autoreleasing</code>修饰符的变量，<br>等同于在<code>MRC</code>下调用对象的<code>autorelease</code>方法，即对象被注册到<code>autoreleasepool</code></p>
<p><code>ARC</code>环境不能使用<code>NSAutoreleasePool</code>类也不能调用<code>autorelease</code>方法，代替它们实现对象自动释放的是<code>@autoreleasepool块</code>和<code>__autoreleasing</code>修饰符；两种环境下的使用情况类比如下图：<br><img src="http://182.92.228.41/wp-content/uploads/autoreleasepool_mrc_and_arc.png" width="500" hegiht="313" align=center/></p>
<p>如图所示，<code>@autoreleasepool</code>块替换了<code>NSAutoreleasePoool</code>类对象的生成、持有及废弃这一过程。而附有<code>__autoreleasing</code>修饰符的变量替代了<code>autorelease</code>方法，将对象注册到了<code>autoreleasepool</code>;</p>
<p>但事实上，显式使用<code>__autoreleasing</code>修饰符的情况非常少见，这主要是因为<code>ARC</code>的很多情况下，即使是不显式的使用<code>__autoreleasing</code>，也能实现对象被注册到释放池中。换句话来说，<code>ARC</code>环境下对象会被自动加入释放池的情况包括以下几种情况：</p>
<ol>
<li>编译器会进行优化，检查方法名是否以<code>alloc/new/copy/mutableCopy</code>开始，如果不是则自动将返回对象注册到<code>Autoreleasepool</code>;</li>
<li>访问附有<code>__weak</code>修饰符的变量时，实际上必定要访问注册到<code>Autoreleasepool</code>的对象，即会自动加入<code>Autoreleasepool</code>;</li>
<li>id的指针或对象的指针(<code>id*</code>，<code>NSError**</code>)，在没有显式地指定修饰符时候，会被默认附加上<code>__autoreleasing</code>修饰符，加入<code>Autoreleasepool</code>；</li>
</ol>
<h5 id="4-ARC属性修饰符"><a href="#4-ARC属性修饰符" class="headerlink" title="4.ARC属性修饰符"></a>4.ARC属性修饰符</h5><p><code>ARC</code>中的所有权修饰与属性修饰符存在着对应关系，如果不一致还会引起编译错误。总结两者的对应关系如下：</p>
<table>
<thead>
<tr>
<th>属性修饰符</th>
<th>所有权修饰符</th>
</tr>
</thead>
<tbody><tr>
<td><code>assign</code></td>
<td><code>__unsafe_unretained</code></td>
</tr>
<tr>
<td><code>copy</code></td>
<td><code>__strong</code>(但是赋值的是被复制的对象)</td>
</tr>
<tr>
<td><code>retain</code></td>
<td><code>__strong</code></td>
</tr>
<tr>
<td><code>strong</code></td>
<td><code>__strong</code></td>
</tr>
<tr>
<td><code>unsafe_unretained</code></td>
<td><code>__unsafe_unretained</code></td>
</tr>
<tr>
<td><code>weak</code></td>
<td><code>__weak</code></td>
</tr>
</tbody></table>
<p>以上各种属性只有<code>copy</code>不是简单的赋值，它赋值的是通过<code>NSCopying</code>接口的<code>copyWithZone:</code>方法复制赋值源生成的对象。</p>
<h5 id="5-ARC管理内存的规则"><a href="#5-ARC管理内存的规则" class="headerlink" title="5.ARC管理内存的规则"></a>5.ARC管理内存的规则</h5><ol>
<li>不能使用<code>retain/release/retainCount/autorelease</code>内存管理方法;</li>
<li>不能使用<code>NSAllocateObject/NSDeallocateObject</code>方法;</li>
<li>必须遵守内存管理的方法命名规则;</li>
<li>不能显式调用<code>dealloc</code>方法，如<code>[super dealloc]</code>;</li>
<li>使用<code>@autoreleasepool</code>块代替<code>NSAutoreleasePool</code>;</li>
<li>不能使用区域(<code>NSZone</code>);</li>
<li><strong>对象类型变量不能作为C语言结构体(struct&#x2F;union)的成员；</strong></li>
<li>显式转换<code>id</code>和<code>void *</code></li>
</ol>
<h5 id="6-必须遵守内存管理的方法命名规则"><a href="#6-必须遵守内存管理的方法命名规则" class="headerlink" title="6.必须遵守内存管理的方法命名规则"></a>6.必须遵守内存管理的方法命名规则</h5><p><code>MRC</code>下，用于对象生成&#x2F;持有的方法必须遵守<code>alloc、new、copy、mutableCopy</code>的命名规则。以这些名称开始的方法在返回对象时，必须返回给调用方所应当持有的对象。这在<code>ARC</code>环境下的规则一样。只是<code>ARC</code>下关于<code>init</code>开发的方法规则要更加严格了:</p>
<ol>
<li>必须是实例方法，且返回对象;</li>
<li>返回对象应该是<code>id</code>类型或该方法声明类的对象，抑或该类的超类或子类;</li>
<li>该返回类型不注册到<code>autoreleasepool</code>上;</li>
<li>基本上，<code>init</code>方法只是对<code>alloc</code>方法返回值的对象进行初始化处理并返回对象;</li>
</ol>
<h5 id="7-显式转换id和void"><a href="#7-显式转换id和void" class="headerlink" title="7.显式转换id和void *"></a>7.显式转换id和void *</h5><p>这里说到的其实就是<code>Core Foundation</code>和<code>Foundation</code>两者之间的转换。<br><code>Core Foundation</code>是由C语言实现的，而<code>Foundation</code>由<code>Objective-C</code>实现，两者可以相互转换。</p>
<p><code>MRC</code>不存在显式转换的问题，因为本来就是手动管理内存。但是为了在<code>ARC</code>也能实现对<code>Core Foundation</code>对象的自动内存管理，我们就必须将其与<code>Objective-C</code>对象的转换。<code>Objective-C</code>中提供了三个关键字<code>__bridge</code>、<code>__bridge_retained</code>、<code>__bridge_transfer</code>来实现转换。</p>
<p><strong>情况1：__bridge转换</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">MRC代码下，将id变量直接强制转换void*正常，但ARC下报错</span></span><br><span class="line"><span class="comment">id obj = [[NSObject alloc] init];</span></span><br><span class="line"><span class="comment">void *p = obj;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//ARC下代码使用__bridge实现单纯的赋值转换</span></span><br><span class="line">id obj <span class="operator">=</span> [[<span class="type">NSObject</span> alloc] <span class="keyword">init</span>];</span><br><span class="line">void <span class="operator">*</span>p <span class="operator">=</span> (__bridge void <span class="operator">*</span>)(obj);</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ol>
<li><code>__bridge</code>只能实现<code>Objective-C</code>对象和<code>Core Foundation</code>对象的相互转换，但是不修改对象(内存)管理权；</li>
<li>所以，其安全性与赋值给<code>__unsafe_unretained</code>修饰符相近，甚至会更低。如果管理时不注意赋值对象的所有者，就容易产生野指针错误导致程序崩溃；</li>
</ol>
<p><strong>情况2：__bridge_retained转换</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">id obj <span class="operator">=</span> [[<span class="type">NSObject</span> alloc] <span class="keyword">init</span>];</span><br><span class="line">void <span class="operator">*</span>p <span class="operator">=</span> (__bridge_retained void <span class="operator">*</span>)(obj);</span><br><span class="line">    </span><br><span class="line"><span class="comment">/*相当于MRC代码：</span></span><br><span class="line"><span class="comment">id obj = [[NSObject alloc] init];</span></span><br><span class="line"><span class="comment">void *p = obj;</span></span><br><span class="line"><span class="comment">[(id)p retain];</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ol>
<li><code>__bridge_retained</code>转换可使要转换的变量也持有所赋值的对象，后续需要使用<code>CFRelease</code>或者相关方法来释放对象；</li>
<li>此操作类似于<code>retain</code>。上述代码中变量<code>obj</code>和变量<code>p</code>同时持有对象。</li>
</ol>
<p><strong>情况3：__bridge_transfer转换</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">id obj <span class="operator">=</span> (__bridge_transfer id)p;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/*相当于MRC代码：</span></span><br><span class="line"><span class="comment">id obj = id(p)</span></span><br><span class="line"><span class="comment">[obj retain];</span></span><br><span class="line"><span class="comment">[(id)p release];</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ol>
<li><code>__bridge_transfer</code>转换提供与<code>__bridge_retained</code>相反的动作，被转换的变量所持有的对象在该变量被赋值给转换的目标后随之释放。</li>
<li>此操作与<code>release</code>相似。</li>
</ol>
<h4 id="五、MRC和ARC的转换"><a href="#五、MRC和ARC的转换" class="headerlink" title="五、MRC和ARC的转换"></a>五、MRC和ARC的转换</h4><p><code>iOS5.0</code>以后出现的<code>ARC</code>，即自动引用计数(<code>Automatic Refrence Counting</code>)，减少了代码，省去了对象释放的麻烦。</p>
<p><strong>ARC项目：加入MRC：</strong><br><code>target</code> -&gt;<code>build phrases</code> -&gt;<code>compbile sources</code> ，点击<code>mrc</code>的文件将其设置为 <code>-fno-objc-arc</code></p>
<p><strong>MRC项目：加入ARC：</strong><br><code>target</code> -&gt;<code>build phrases</code> -&gt;<code>compbile sources</code> ，点击<code>arc</code>的文件将其设置为 <code>-fobjc-arc</code></p>
<p><code>iOS</code>通过引用计数来记录对象的引用，每次<code>runloop</code>完成一次循环的时候，都会检查对象的<code>retainCount</code>，如果说对象的<code>retainCount</code>为<code>0</code>，说明该对象没有地方需要引用了，就可以释放掉了；</p>
<h4 id="六、内存泄漏问题"><a href="#六、内存泄漏问题" class="headerlink" title="六、内存泄漏问题"></a>六、内存泄漏问题</h4><ol>
<li>内存泄露就是本该废弃的对象在超出其生命周期后继续存在；</li>
<li>内存泄露可导致内存浪费、程序运行速度减慢甚至系统崩溃等严重后果；</li>
</ol>
<p>总结常见的内存泄露的异常情况如下：</p>
<ol>
<li><code>Block</code>、<code>delegate</code>、<code>NSTimer</code>使用不当，造成循环引用;</li>
<li>非<code>OC</code>对象不当使用，如<code>CoreFoundation</code>方式申请的内存，忘记释放，需要<code>free</code>、<code>release</code>方法；</li>
<li>第三方框架不当使用，如<code>AFNetworking</code>循环引用(未使用单例或者没有调用销毁<code>NSURLSession</code>的方法;</li>
<li>自定义长时间执行任务的线程，却没有添加自动释放池；</li>
<li>循环操作创建大量临时对象，导致内存导致内存暴涨；</li>
<li>地图框架使用完，要及时移除相关组件；</li>
</ol>
<p><code>ARC</code>只适用于<code>OC</code>对象，若我们使用了<code>Core Foundation</code>或者<code>malloc</code>，此时还是手动管理内存的，还有一些循环引用的情况同样造成内存泄露；</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define <span class="type">WS</span>(weakSelf)   __weak __typeof(<span class="operator">&amp;*</span><span class="keyword">self</span>)weakSelf <span class="operator">=</span> <span class="keyword">self</span>; <span class="comment">// 弱引用</span></span><br><span class="line"></span><br><span class="line">#define <span class="type">ST</span>(strongSelf)  __strong __typeof(<span class="operator">&amp;*</span><span class="keyword">self</span>)strongSelf <span class="operator">=</span> weakSelf; <span class="comment">//使用这个要先声明weakSelf</span></span><br></pre></td></tr></table></figure>


<h4 id="七、野指针问题"><a href="#七、野指针问题" class="headerlink" title="七、野指针问题"></a>七、野指针问题</h4><p>野指针指针就是指向一个已经删除对象或者访问受限内存区域的指针；</p>
<p><strong>注意：</strong>野指针不是<code>nil</code>指针，而是指向”垃圾”内存（不可用内存）的指针;</p>
<p>总结<code>ARC</code>下常见的野指针异常情况如下：<br><img src="http://182.92.228.41/wp-content/uploads/memory_wild_pointer_questions.png" width="500" hegiht="313" align=center/></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wuyubeichen.github.io/2019/04/15/iOS%E5%BA%95%E5%B1%82-Runtime%E5%9F%BA%E7%A1%80%E7%AF%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Author">
      <meta itemprop="description" content="iOS Developer, Beijing China">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="梧雨北辰的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/15/iOS%E5%BA%95%E5%B1%82-Runtime%E5%9F%BA%E7%A1%80%E7%AF%87/" class="post-title-link" itemprop="url">iOS底层-Runtime基础篇</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-15 16:16:49" itemprop="dateCreated datePublished" datetime="2019-04-15T16:16:49+08:00">2019-04-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-29 09:39:32" itemprop="dateModified" datetime="2022-08-29T09:39:32+08:00">2022-08-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS%E5%BA%95%E5%B1%82/" itemprop="url" rel="index"><span itemprop="name">iOS底层</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>主要内容：</strong></p>
<ol>
<li>理解<code>OC</code>是动态语言特性</li>
<li>理解消息机制的基本原理</li>
<li>与<code>Runtime</code>交互的三种方式</li>
<li>分析<code>Runtime</code>中的数据结构</li>
<li>深入理解Rutime消息发送原理</li>
<li>多继承的实现思路<code>Rutime</code></li>
<li>参考链接</li>
</ol>
<h4 id="一、理解OC是动态语言特性"><a href="#一、理解OC是动态语言特性" class="headerlink" title="一、理解OC是动态语言特性"></a>一、理解OC是动态语言特性</h4><h5 id="1-静态语言和动态语言"><a href="#1-静态语言和动态语言" class="headerlink" title="1.静态语言和动态语言"></a>1.静态语言和动态语言</h5><p><strong>静态语言</strong>：如<code>C</code>语言，编译阶段就要决定调用哪个函数，如果函数未实现就会编译报错。</p>
<p><strong>动态语言</strong>：如<code>OC</code>语言，编译阶段并不能决定真正调用哪个函数，只要函数声明过即使没有实现也不会报错。</p>
<p>我们常说<code>OC</code>是一门动态语言，就是因为它总是把一些决定性的工作从编译阶段推迟到运行时阶段。例如：</p>
<ol>
<li>多态特性，我们可以使用父类指针指向子类对象，并且调用子类方法；</li>
<li>我们利用运行时特性，动态的添加方法、替换方法；</li>
</ol>
<h5 id="2-理解Runtime"><a href="#2-理解Runtime" class="headerlink" title="2. 理解Runtime"></a>2. 理解Runtime</h5><ol>
<li><code>Runtime</code>是一套由<code>C</code>、<code>C++</code>、汇编编实现的一套<code>API</code>，为<code>OC</code>提供运行时机制；</li>
<li>运行时（<code>runtime</code>）将类型的确定由编译时推迟到了运行时；</li>
<li><code>OC</code>代码最终都会被编译器转化为运行时代码，再通过消息机制决定函数调用方式，这也是<code>OC</code>作为动态语言使用的基础。</li>
</ol>
<p><code>OC</code>代码的运行不仅需要编译器，还需要运行时系统<code>(Runtime Sytem</code>)来执行编译后的代码。</p>
<h4 id="二、理解消息机制的基本原理"><a href="#二、理解消息机制的基本原理" class="headerlink" title="二、理解消息机制的基本原理"></a>二、理解消息机制的基本原理</h4><p><code>OC</code>的方法调用都是类似<code>[receiver selector]</code>的形式，其实每次都是一个运行时消息发送过程；</p>
<h5 id="1-第一步：编译阶段"><a href="#1-第一步：编译阶段" class="headerlink" title="1.第一步：编译阶段"></a>1.第一步：编译阶段</h5><p><code>[receiver selector]</code>方法被编译器转化，分为两种情况：</p>
<ol>
<li>不带参数的方法被编译为：<code>objc_msgSend(receiver，selector)</code>；</li>
<li>带参数的方法被编译为：<code>objc_msgSend(recevier，selector，org1，org2，…)</code>；</li>
</ol>
<h5 id="2-第二步：运行时阶段"><a href="#2-第二步：运行时阶段" class="headerlink" title="2.第二步：运行时阶段"></a>2.第二步：运行时阶段</h5><p>消息接收者<code>recever</code>寻找对应的<code>selector</code>，也分为两种情况：</p>
<ol>
<li>接收者能找到对应的<code>selector</code>，直接执行接收<code>receiver</code>对象的<code>selector</code>方法；</li>
<li>接收者找不到对应的<code>selector</code>，消息被转发或者临时向接收者添加这个<code>selector</code>对应的实现内容，否则崩溃；</li>
</ol>
<p><strong>说明：OC调用方法[receiver selector]，编译阶段确定了要向哪个接收者发送message消息，但是接收者如何响应决定于运行时的判断;</strong></p>
<h4 id="三、与Runtime的交互"><a href="#三、与Runtime的交互" class="headerlink" title="三、与Runtime的交互"></a>三、与Runtime的交互</h4><p><code>Runtime</code>的官方文档中将<code>OC</code>与<code>Runtime</code>的交互划分三种层次：</p>
<ol>
<li><code>OC</code>源代码</li>
<li><code>NSObject</code>方法</li>
<li><code>Runtime</code> 函数</li>
</ol>
<p>这其实也是按照与<code>Runtime</code>交互程度从低到高排序的三种方式;</p>
<h5 id="1-OC源代码-Objec-C-Source-Code"><a href="#1-OC源代码-Objec-C-Source-Code" class="headerlink" title="1.OC源代码(Objec-C Source Code)"></a>1.OC源代码(Objec-C Source Code)</h5><p>我们已经说过，<code>OC</code>代码会在编译阶段被编译器转化。<code>OC</code>中的类、方法和协议等在<code>Runtime</code>中都由一些数据结构来定义。所以，我们平时直接使用<code>OC</code>编写代码，其实这已经是在和<code>Runtime</code>进行交互了，只不过这个过程对于我们来说是无感的;</p>
<h5 id="2-NSObject方法-NSObject-Methods"><a href="#2-NSObject方法-NSObject-Methods" class="headerlink" title="2.NSObject方法(NSObject Methods)"></a>2.NSObject方法(NSObject Methods)</h5><p><code>Runtime</code>的最大特征就是实现了<code>OC</code>语言的动态特性。作为大部分<code>Objective-C</code>类继承体系的根类的<code>NSObject</code>，其本身就具有了一些非常具有运行时动态特性的方法，比如<code>respondsToSelector:</code>方法可以检查在代码运行阶段当前对象是否能响应指定的消息，所以使用这些方法也算是一种与<code>Runtme</code>的交互方式，类似的方法还有如下：</p>
<ul>
<li><code>-description</code>：返回当前类的描述信息</li>
<li><code>-class</code>：方法返回对象的类；</li>
<li><code>-isKindOfClass</code>和 <code>-isMemberOfClass</code>：检查对象是否存在于指定的类的继承体系中；</li>
<li><code>-respondsToSelector</code>：检查对象能否响应指定的消息；</li>
<li><code>-conformsToProtocol </code>：检查对象是否实现了指定协议类的方法；</li>
<li><code>-methodForSelector </code>：返回指定方法实现的地址；</li>
</ul>
<h5 id="3-使用Runtime函数-Runtime-Functions"><a href="#3-使用Runtime函数-Runtime-Functions" class="headerlink" title="3.使用Runtime函数(Runtime Functions)"></a>3.使用Runtime函数(Runtime Functions)</h5><p><code>Runtime</code>系统是一个由一系列函数和数据结构组成，具有公共接口的动态共享库。头文件存放于<code>/usr/include/objc</code>目录下。在我们工程代码里引用<code>Runtime</code>的头文件，同样能够实现类似<code>OC</code>代码的效果，一些代码示例如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//相当于：Class class = [UIView class];</span></span><br><span class="line"><span class="type">Class</span> viewClass <span class="operator">=</span> objc_getClass(<span class="string">&quot;UIView&quot;</span>);</span><br><span class="line">    </span><br><span class="line"><span class="comment">//相当于：UIView *view = [UIView alloc];</span></span><br><span class="line"><span class="type">UIView</span> <span class="operator">*</span>view <span class="operator">=</span> ((id (<span class="operator">*</span>)(id, <span class="type">SEL</span>))(void <span class="operator">*</span>)objc_msgSend)((id)viewClass, sel_registerName(<span class="string">&quot;alloc&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//相当于：UIView *view = [view init];</span></span><br><span class="line">((id (<span class="operator">*</span>)(id, <span class="type">SEL</span>))(void <span class="operator">*</span>)objc_msgSend)((id)view, sel_registerName(<span class="string">&quot;init&quot;</span>));</span><br></pre></td></tr></table></figure>

<h4 id="三、分析Runtime中数据结构"><a href="#三、分析Runtime中数据结构" class="headerlink" title="三、分析Runtime中数据结构"></a>三、分析Runtime中数据结构</h4><p><code>OC</code>代码被编译器转化为<code>C</code>语言，然后再通过运行时执行，最终实现了动态调用。这其中的<code>OC</code>类、对象和方法等都对应了<code>C</code>中的结构体，而且我们都可以在<code>Rutime</code>源码中找到它们的定义。</p>
<p>那么，我们如何来查看<code>Runtime</code>的代码呢？其实很简单，只需要我们在当前代码文件中引用头文件：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#<span class="keyword">import</span> &lt;objc/runtime.h&gt;</span><br><span class="line">#<span class="keyword">import</span> &lt;objc/message.h&gt;</span><br></pre></td></tr></table></figure>

<p>然后，我们需要使用组合键<code>&quot;Command +鼠标点击&quot;</code>，即可进入<code>Runtime</code>的源码文件，下面我们继续来一一分析<code>OC</code>代码在<code>C</code>中对应的结构。</p>
<h5 id="1-id—-gt-objc-object"><a href="#1-id—-gt-objc-object" class="headerlink" title="1.id—&gt;objc_object"></a>1.id—&gt;objc_object</h5><p><code>id</code>是一个指向<code>objc_object</code>结构体的指针，即在<code>Runtime</code>中：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///A pointer to an instance of a class.</span></span><br><span class="line">typedef <span class="keyword">struct</span> <span class="title class_">objc_object</span> *<span class="title class_">id</span>;</span><br></pre></td></tr></table></figure>
<p>下面是<code>Runtime</code>中对<code>objc_object</code>结构体的具体定义：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///Represents an instance of a class.</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">objc_object</span> &#123;</span><br><span class="line">    <span class="type">Class</span> _Nonnull isa  <span class="type">OBJC_ISA_AVAILABILITY</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们都知道<code>id</code>在<code>OC</code>中是表示一个任意类型的类实例，从这里也可以看出，<code>OC</code>中的对象虽然没有明显的使用指针，但是在<code>OC</code>代码被编译转化为<code>C</code>之后，每个<code>OC</code>对象其实都是拥有一个<code>isa</code>的指针的；</p>
<h5 id="2-Class-gt-objc-classs"><a href="#2-Class-gt-objc-classs" class="headerlink" title="2.Class - &gt;objc_classs"></a>2.Class - &gt;objc_classs</h5><p><code>class</code>是一个指向<code>objc_class</code>结构体的指针，即在<code>Runtime</code>中：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef <span class="keyword">struct</span> <span class="title class_">objc_class</span> *<span class="title class_">Class</span>; </span><br></pre></td></tr></table></figure>
<p>下面是<code>Runtime</code>中对<code>objc_class</code>结构体的具体定义：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//usr/include/objc/runtime.h</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">objc_class</span> &#123;</span><br><span class="line">    <span class="type">Class</span> _Nonnull isa  <span class="type">OBJC_ISA_AVAILABILITY</span>;</span><br><span class="line"><span class="keyword">#if</span> <span class="operator">!</span><span class="type">OBJC2</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Class</span> <span class="type">Nullable</span> super_class                              <span class="type">OBJC2UNAVAILABLE</span>;</span><br><span class="line">    const char <span class="operator">*</span> <span class="type">Nonnull</span> name                               <span class="type">OBJC2UNAVAILABLE</span>;</span><br><span class="line">    long version                                             <span class="type">OBJC2_UNAVAILABLE</span>;</span><br><span class="line">    long info                                                <span class="type">OBJC2_UNAVAILABLE</span>;</span><br><span class="line">    long instance_size                                       <span class="type">OBJC2_UNAVAILABLE</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">objc_ivar_list</span> * <span class="title class_">Nullable</span> <span class="title class_">ivars</span>                  <span class="title class_">OBJC2UNAVAILABLE</span>;</span><br><span class="line">    <span class="title class_">struct</span> <span class="title class_">objc_method_list</span> * <span class="title class_">Nullable</span> * <span class="title class_">_Nullable</span> <span class="title class_">methodLists</span>                    <span class="title class_">OBJC2UNAVAILABLE</span>;</span><br><span class="line">    <span class="title class_">struct</span> <span class="title class_">objc_cache</span> * <span class="title class_">Nonnull</span> <span class="title class_">cache</span>                       <span class="title class_">OBJC2UNAVAILABLE</span>;</span><br><span class="line">    <span class="title class_">struct</span> <span class="title class_">objc_protocol_list</span> * <span class="title class_">Nullable</span> <span class="title class_">protocols</span>          <span class="title class_">OBJC2UNAVAILABLE</span>;</span><br><span class="line">#<span class="title class_">endif</span></span><br><span class="line">&#125; <span class="title class_">OBJC2_UNAVAILABLE</span>;</span><br></pre></td></tr></table></figure>

<p>理解<code>objc_class</code>定义中的参数：</p>
<p><strong>isa指针：</strong><br>我们会发现<code>objc_class</code>和<code>objc_object</code>同样是结构体，而且都拥有一个<code>isa</code>指针。我们很容易理解<code>objc_object</code>的<code>isa</code>指针指向对象的定义，那么<code>objc_class</code>的指针是怎么回事呢？</p>
<p>其实，在<code>Runtime</code>中<code>Objc</code>类本身同时也是一个对象。<code>Runtime</code>把类对象所属类型就叫做元类，用于描述类对象本身所具有的特征，最常见的类方法就被定义于此，所以<code>objc_class</code>中的<code>isa</code>指针指向的是元类，每个类仅有一个类对象，而每个类对象仅有一个与之相关的元类。</p>
<p><strong>super_class指针</strong>：指向<code>objc_class</code>类所继承的父类，但是如果当前类已经是最顶层的类(如<code>NSProxy</code>),则<code>super_class</code>指针为<code>NULL</code></p>
<p><strong>cache</strong>：为了优化性能，<code>objc_class</code>中的<code>cache</code>结构体用于记录每次使用类或者实例对象调用的方法。这样每次响应消息的时候，<code>Runtime</code>系统会优先在<code>cache</code>中寻找响应方法，相比直接在类的方法列表中遍历查找，效率更高;</p>
<p><strong>ivars</strong>：用于存放所有的成员变量和属性信息，属性的存取方法都存放在<code>methodLists</code>中。</p>
<p><strong>methodLists</strong>：用于存放对象的所有成员方法;</p>
<h5 id="3-SEL"><a href="#3-SEL" class="headerlink" title="3.SEL"></a>3.SEL</h5><p><code>SEL</code>是一个指向<code>objc_selector</code>结构体的指针，即在<code>Runtime</code>中：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// An opaque type that represents a method selector.</span></span><br><span class="line">typedef <span class="keyword">struct</span> <span class="title class_">objc_selector</span> *<span class="title class_">SEL</span>;</span><br></pre></td></tr></table></figure>
<p><code>SEL</code>在<code>OC</code>中称作方法选择器，用于表示运行时方法的名字，然而我们并不能在<code>Runtime</code>中找到它的结构体的详细定义。<code>Objective-C</code>在编译时，会依据每一个方法的名字、参数序列，生成一个唯一的整型标识(Int类型的地址)，这个标识就是<code>SEL</code>；</p>
<p><strong>注意</strong>：</p>
<ol>
<li>不同类中相同名字的方法对应的方法选择器是相同的；</li>
<li>即使是同一个类中，方法名相同而变量类型不同也会导致它们具有相同的方法选择器；</li>
</ol>
<p>通常我们获取SEL有三种方法：</p>
<ol>
<li><code>OC</code>中，使用<code>@selector</code>(“方法名字符串”)；</li>
<li><code>OC</code>中，使用<code>NSSelectorFromString</code>(“方法名字符串”)；</li>
<li><code>Runtime</code>方法，使用<code>sel_registerName</code>(“方法名字符串”)；</li>
</ol>
<h5 id="4-Ivar"><a href="#4-Ivar" class="headerlink" title="4.Ivar"></a>4.Ivar</h5><p><code>Ivar</code>代表类中实例变量的类型，是一个指向<code>ojbcet_ivar</code>的结构体的指针，即在<code>Runtime</code>中：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// An opaque type that represents an instance variable.</span></span><br><span class="line">typedef <span class="keyword">struct</span> <span class="title class_">objc_ivar</span> *<span class="title class_">Ivar</span>;</span><br></pre></td></tr></table></figure>

<p>下面是<code>Runtime</code>中对<code>objc_ivar</code>结构体的具体定义：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">objc_ivar</span> &#123;</span><br><span class="line">    char <span class="operator">*</span> <span class="type">Nullable</span> ivar_name                               <span class="type">OBJC2UNAVAILABLE</span>;</span><br><span class="line">    char <span class="operator">*</span> <span class="type">Nullable</span> ivar_type                               <span class="type">OBJC2UNAVAILABLE</span>;</span><br><span class="line">    int ivar_offset                                          <span class="type">OBJC2_UNAVAILABLE</span>;</span><br><span class="line">#ifdef <span class="type">LP64</span></span><br><span class="line">    int space                                                <span class="type">OBJC2_UNAVAILABLE</span>;</span><br><span class="line"><span class="keyword">#endif</span></span><br><span class="line">&#125;          </span><br></pre></td></tr></table></figure>

<p>我们在<code>objc_class</code>中看到的<code>ivars</code>成员列表,其中的元素就是<code>Ivar</code>，我可以通过实例查找其在类中的名字，这个过程被称为反射，下面的<code>class_copyIvarList</code>获取的不仅有实例变量还有属性：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   <span class="type">Ivar</span> <span class="operator">*</span>ivarList <span class="operator">=</span> class_copyIvarList([<span class="keyword">self</span> <span class="keyword">class</span>], <span class="operator">&amp;</span>count);</span><br><span class="line">    <span class="keyword">for</span> (int i<span class="operator">=</span> <span class="number">0</span>; i<span class="operator">&lt;</span>count; i<span class="operator">++</span>) &#123;</span><br><span class="line">        <span class="type">Ivar</span> ivar <span class="operator">=</span> ivarList[i];</span><br><span class="line">        const char <span class="operator">*</span>ivarName <span class="operator">=</span> ivar_getName(ivar);</span><br><span class="line">        <span class="type">NSLog</span>(@<span class="string">&quot;Ivar(%d): %@&quot;</span>, i, [<span class="type">NSString</span> stringWithUTF8String:ivarName]);</span><br><span class="line">    &#125;</span><br><span class="line">    free(ivarList)；</span><br></pre></td></tr></table></figure>

<h5 id="5-Method"><a href="#5-Method" class="headerlink" title="5.Method"></a>5.Method</h5><p><code>Method</code>表示某个方法的类型，即在<code>Runtime</code>中：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// An opaque type that represents a method in a class definition.</span></span><br><span class="line">typedef <span class="keyword">struct</span> <span class="title class_">objc_method</span> *<span class="title class_">Method</span>;</span><br></pre></td></tr></table></figure>
<p>我们可以在<code>objct_class</code>定义中看到<code>methodLists</code>，其中的元素就是<code>Method</code>，下面是<code>Runtime</code>中<code>objc_method</code>结构体的具体定义：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">objc_method</span> &#123;</span><br><span class="line">    <span class="type">SEL</span> <span class="type">Nonnull</span> method_name                                 <span class="type">OBJC2UNAVAILABLE</span>;</span><br><span class="line">    char <span class="operator">*</span> <span class="type">Nullable</span> method_types                            <span class="type">OBJC2UNAVAILABLE</span>;</span><br><span class="line">    <span class="type">IMP</span> <span class="type">Nonnull</span> method_imp                                  <span class="type">OBJC2UNAVAILABLE</span>;</span><br><span class="line">&#125;                                                           <span class="type">OBJC2_UNAVAILABLE</span>;</span><br></pre></td></tr></table></figure>

<p>理解<code>objc_method</code>定义中的参数：</p>
<ul>
<li><code>method_name</code>:方法名类型<code>SEL</code>；</li>
<li><code>method_types</code>: 一个<code>char</code>指针，指向存储方法的参数类型和返回值类型；</li>
<li><code>method_imp</code>：本质上是一个指针，指向方法的实现；</li>
</ul>
<p>这里其实就是<code>SEL(method_name)</code>与<code>IMP(method_name)</code>形成了一个映射，通过<code>SEL</code>，我们可以很方便的找到方法实现<code>IMP</code>；</p>
<h5 id="6-IMP"><a href="#6-IMP" class="headerlink" title="6.IMP"></a>6.IMP</h5><p><code>IMP</code>是一个函数指针，它在<code>Runtime</code>中的定义如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// A pointer to the function of a method implementation.</span></span><br><span class="line">typedef void (<span class="type">IMP</span>)(void <span class="operator">/</span> id, <span class="type">SEL</span>, <span class="operator">...</span> <span class="operator">*/</span> ); </span><br></pre></td></tr></table></figure>

<p><code>IMP</code>这个函数指针指向了方法实现的首地址，当<code>OC</code>发起消息后，最终执行的代码是由<code>IMP</code>指针决定的。利用这个特性，我们可以对代码进行优化：当需要大量重复调用方法的时候，我们可以绕开消息绑定而直接利用IMP指针调起方法，这样的执行将会更加高效，相关的代码示例如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void (<span class="operator">*</span>setter)(id, <span class="type">SEL</span>, <span class="type">BOOL</span>);</span><br><span class="line">int i;</span><br><span class="line">setter <span class="operator">=</span> (void (<span class="operator">*</span>)(id, <span class="type">SEL</span>, <span class="type">BOOL</span>))[target methodForSelector:<span class="meta">@selector</span>(setFilled:)];</span><br><span class="line"><span class="keyword">for</span> ( i <span class="operator">=</span> <span class="number">0</span> ; i <span class="operator">&lt;</span> <span class="number">1000</span> ; i<span class="operator">++</span> )</span><br><span class="line">    setter(targetList[i], <span class="meta">@selector</span>(setFilled:), <span class="type">YES</span>);</span><br></pre></td></tr></table></figure>
<p>注意：这里需要注意的就是函数指针的前两个参数必须是<code>id</code>和<code>SEL</code>；</p>
<h4 id="四、深入理解Rutime消息发送"><a href="#四、深入理解Rutime消息发送" class="headerlink" title="四、深入理解Rutime消息发送"></a>四、深入理解Rutime消息发送</h4><p>我们在分析了<code>OC</code>语言对应的底层<code>C</code>结构之后，现在可以进一步理解运行时的消息发送机制。先前讲到，<code>OC</code>调用方法被编译转化为如下的形式：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id _Nullable objc_msgSend(id _Nullable <span class="keyword">self</span>, <span class="type">SEL</span> _Nonnull op, <span class="operator">...</span>)</span><br></pre></td></tr></table></figure>

<p>其实，除了常见的objc_msgSend，消息发送的方法还有<code>objc_msgSend_stret</code>、<code>objc_msgSendSuper</code>、<code>objc_msgSendSuper_stret</code>等，如果消息传递给超类就使用带有<code>super</code>的方法，如果返回值是结构体而不是简单值就使用带有<code>stret</code>的值。</p>
<p><strong>运行时阶段的消息发送的详细步骤如下</strong>：</p>
<ol>
<li>检测<code>selector</code>是不是要忽略的。比如 <code>Mac OS X </code>开发，有了垃圾回收就不理会<code>retain</code>，<code>release</code> 这些函数了；</li>
<li>检测<code>target</code> 是不是<code>nil</code> 对象。<code>ObjC</code> 的特性是允许对一个 <code>nil</code>对象执行任何一个方法不会 <code>Crash</code>，因为会被忽略掉；</li>
<li>如果上面两个都过了，那就开始查找这个类的 <code>IMP</code>，先从 <code>cache</code> 里面找，若可以找得到就跳到对应的函数去执行；</li>
<li>如果在<code>cache</code>里找不到就找一下方法列表<code>methodLists</code>；</li>
<li>如果<code>methodLists</code>找不到就到超类的方法列表里寻找，一直找，直到找到<code>NSObject</code>类为止。 </li>
<li>如果还找不到，<code>Runtime</code>就提供了如下三种方法来处理：<code>动态方法解析</code>、<code>消息接受者重定向</code>、<code>消息重定向</code>，这三种方法的调用关系如下图：</li>
</ol>
<img src="http://182.92.228.41/wp-content/uploads/Runtime_message_forward.png" width="500" align=center/>

<h5 id="1-动态方法解析-Dynamic-Method-Resolution"><a href="#1-动态方法解析-Dynamic-Method-Resolution" class="headerlink" title="1.动态方法解析(Dynamic Method Resolution)"></a>1.动态方法解析(Dynamic Method Resolution)</h5><p>所谓动态解析，我们可以理解为通过<code>cache</code>和方法列表没有找到方法时，<code>Runtime</code>为我们提供一次动态添加方法实现的机会，主要用到的方法如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//OC方法：</span></span><br><span class="line"><span class="comment">//类方法未找到时调起，可于此添加类方法实现</span></span><br><span class="line"><span class="operator">+</span> (<span class="type">BOOL</span>)resolveClassMethod:(<span class="type">SEL</span>)sel</span><br><span class="line"><span class="comment">//实例方法未找到时调起，可于此添加实例方法实现</span></span><br><span class="line"><span class="operator">+</span> (<span class="type">BOOL</span>)resolveInstanceMethod:(<span class="type">SEL</span>)sel</span><br><span class="line"></span><br><span class="line"><span class="comment">//Runtime方法：</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 运行时方法：向指定类中添加特定方法实现的操作</span></span><br><span class="line"><span class="comment"> @param cls 被添加方法的类</span></span><br><span class="line"><span class="comment"> @param name selector方法名</span></span><br><span class="line"><span class="comment"> @param imp 指向实现方法的函数指针</span></span><br><span class="line"><span class="comment"> @param types imp函数实现的返回值与参数类型</span></span><br><span class="line"><span class="comment"> @return 添加方法是否成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">BOOL</span> class_addMethod(<span class="type">Class</span> _Nullable cls,</span><br><span class="line">                     <span class="type">SEL</span> _Nonnull name,</span><br><span class="line">                     <span class="type">IMP</span> _Nonnull imp,</span><br><span class="line">                     const char <span class="operator">*</span> _Nullable types)</span><br></pre></td></tr></table></figure>

<p>下面使用一个示例来说明动态解析：<code>Perosn</code>类中声明方法却未添加实现，我们通过<code>Runtime</code>动态方法解析的操作为其他添加方法实现，具体代码如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Person.h文件</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@interface</span> <span class="type">Person</span> : <span class="type">NSObject</span></span><br><span class="line"><span class="comment">//声明类方法，但未实现</span></span><br><span class="line"><span class="operator">+</span> (void)haveMeal:(<span class="type">NSString</span> <span class="operator">*</span>)food;</span><br><span class="line"><span class="comment">//声明实例方法，但未实现</span></span><br><span class="line"><span class="operator">-</span> (void)singSong:(<span class="type">NSString</span> <span class="operator">*</span>)name;</span><br><span class="line"><span class="meta">@end</span></span><br></pre></td></tr></table></figure>

<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Person.m文件</span></span><br><span class="line"></span><br><span class="line">#<span class="keyword">import</span> &quot;Person.h&quot;</span><br><span class="line">#<span class="keyword">import</span> &lt;objc/runtime.h&gt;</span><br><span class="line"><span class="meta">@implementation</span> <span class="type">Person</span></span><br><span class="line"><span class="comment">//重写父类方法：处理类方法</span></span><br><span class="line"><span class="operator">+</span> (<span class="type">BOOL</span>)resolveClassMethod:(<span class="type">SEL</span>)sel&#123;</span><br><span class="line">    <span class="keyword">if</span>(sel <span class="operator">==</span> <span class="meta">@selector</span>(haveMeal:))&#123;</span><br><span class="line">        class_addMethod(object_getClass(<span class="keyword">self</span>), sel, class_getMethodImplementation(object_getClass(<span class="keyword">self</span>), <span class="meta">@selector</span>(zs_haveMeal:)), <span class="string">&quot;v@&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="type">YES</span>;   <span class="comment">//添加函数实现，返回YES</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [class_getSuperclass(<span class="keyword">self</span>) resolveClassMethod:sel];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重写父类方法：处理实例方法</span></span><br><span class="line"><span class="operator">+</span> (<span class="type">BOOL</span>)resolveInstanceMethod:(<span class="type">SEL</span>)sel&#123;</span><br><span class="line">    <span class="keyword">if</span>(sel <span class="operator">==</span> <span class="meta">@selector</span>(singSong:))&#123;</span><br><span class="line">        class_addMethod([<span class="keyword">self</span> <span class="keyword">class</span>], sel, class_getMethodImplementation([<span class="keyword">self</span> <span class="keyword">class</span>], <span class="meta">@selector</span>(zs_singSong:)), <span class="string">&quot;v@&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="type">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="operator">+</span> (void)zs_haveMeal:(<span class="type">NSString</span> <span class="operator">*</span>)food&#123;</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;%s&quot;</span>,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> (void)zs_singSong:(<span class="type">NSString</span> <span class="operator">*</span>)name&#123;</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;%s&quot;</span>,__func__);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TestViewController.m文件</span></span><br><span class="line"><span class="comment">//测试：Peson调用并未实现的类方法、实例方法，并没有崩溃</span></span><br><span class="line"><span class="type">Person</span> <span class="operator">*</span>ps <span class="operator">=</span> [[<span class="type">Person</span> alloc] <span class="keyword">init</span>];</span><br><span class="line">[<span class="type">Person</span> haveMeal:@<span class="string">&quot;Apple&quot;</span>]; <span class="comment">//打印：+[Person zs_haveMeal:]</span></span><br><span class="line">[ps singSong:@<span class="string">&quot;纸短情长&quot;</span>];   <span class="comment">//打印：-[Person zs_singSong:]</span></span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ol>
<li>我们注意到<code>class_addMethod</code>方法中的特殊参数<code>“v@”</code>，具体可参考<a target="_blank" rel="noopener" href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100">这里</a>；</li>
<li>成功使用动态方法解析还有个前提，那就是我们必须存在可以处理消息的方法，比如上述代码中的<code>zs_haveMeal:</code>与<code>zs_singSong:</code>;</li>
</ol>
<h5 id="2-消息接收者重定向"><a href="#2-消息接收者重定向" class="headerlink" title="2.消息接收者重定向"></a>2.消息接收者重定向</h5><p>我们注意到动态方法解析过程中的两个<code>resolve</code>方法都返回了布尔值，当它们返回<code>YES</code>时方法即可正常执行，但是若它们返回<code>NO</code>，消息发送机制就进入了消息转发(<code>Forwarding</code>)的阶段了，我们可以使用<code>Runtime</code>通过下面的方法替换消息接收者的为其他对象，从而保证程序的继续执行。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重定向类方法的消息接收者，返回一个类</span></span><br><span class="line"><span class="operator">-</span> (id)forwardingTargetForSelector:(<span class="type">SEL</span>)aSelector</span><br><span class="line"></span><br><span class="line"><span class="comment">//重定向实例方法的消息接受者，返回一个实例对象</span></span><br><span class="line"><span class="operator">-</span> (id)forwardingTargetForSelector:(<span class="type">SEL</span>)aSelector</span><br></pre></td></tr></table></figure>

<p>下面使用一个示例来说明消息接收者的重定向：</p>
<p>我们创建一个<code>Student</code>类，声明并实现<code>takeExam</code>、<code>learnKnowledge</code>两个方法，然后在视图控制器<code>TestViewController</code>(一个继承了<code>UIViewController</code>的自定义类)里测试，关键代码如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Student.h文件</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@interface</span> <span class="type">Student</span> : <span class="type">NSObject</span></span><br><span class="line"><span class="comment">//类方法：参加考试</span></span><br><span class="line"><span class="operator">+</span> (void)takeExam:(<span class="type">NSString</span> <span class="operator">*</span>)exam;</span><br><span class="line"><span class="comment">//实例方法：学习知识</span></span><br><span class="line"><span class="operator">-</span> (void)learnKnowledge:(<span class="type">NSString</span> <span class="operator">*</span>)course;</span><br><span class="line"><span class="meta">@end</span></span><br></pre></td></tr></table></figure>

<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  Student.m文件</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@implementation</span> <span class="type">Student</span></span><br><span class="line"><span class="operator">+</span> (void)takeExam:(<span class="type">NSString</span> <span class="operator">*</span>)exam&#123;</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;%s&quot;</span>,__func__);</span><br><span class="line">&#125;</span><br><span class="line"><span class="operator">-</span> (void)learnKnowledge:(<span class="type">NSString</span> <span class="operator">*</span>)course&#123;</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;%s&quot;</span>,__func__);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@end</span></span><br></pre></td></tr></table></figure>

<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TestViewConroller.m文件</span></span><br><span class="line"><span class="comment">//重定向类方法：返回一个类对象</span></span><br><span class="line"><span class="operator">+</span> (id)forwardingTargetForSelector:(<span class="type">SEL</span>)aSelector&#123;</span><br><span class="line">    <span class="keyword">if</span> (aSelector <span class="operator">==</span> <span class="meta">@selector</span>(takeExam:)) &#123;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">return</span> [<span class="type">Student</span> <span class="keyword">class</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title class_">return</span> [<span class="title class_">super</span> <span class="title class_">forwardingTargetForSelector</span>:<span class="title class_">aSelector</span>];</span><br><span class="line">&#125;</span><br><span class="line">//重定向实例方法：返回类的实例</span><br><span class="line">- (<span class="title class_">id</span>)<span class="title class_">forwardingTargetForSelector</span>:(<span class="title class_">SEL</span>)<span class="title class_">aSelector</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (aSelector <span class="operator">==</span> <span class="meta">@selector</span>(learnKnowledge:)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.student;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//在TestViewConroller的viewDidLoad中测试：</span></span><br><span class="line"><span class="comment">//调用并未声明和实现的类方法</span></span><br><span class="line">[<span class="type">TestViewController</span> performSelector:<span class="meta">@selector</span>(takeExam:) withObject:@<span class="string">&quot;语文&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用并未声明和实现的类方法</span></span><br><span class="line"><span class="keyword">self</span>.student <span class="operator">=</span> [[<span class="type">Student</span> alloc] <span class="keyword">init</span>];</span><br><span class="line">[<span class="keyword">self</span> performSelector:<span class="meta">@selector</span>(learnKnowledge:) withObject:@<span class="string">&quot;天文学知识&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//正常打印:</span></span><br><span class="line"><span class="comment">// +[Student takeExam:]</span></span><br><span class="line"><span class="comment">// -[Student learnKnowledge:]</span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：动态方法解析阶段返回<code>NO</code>时，我们可以通过<code>forwardingTargetForSelector</code>可以修改消息的接收者，该方法返回参数是一个对象，如果这个对象是非<code>nil</code>，非<code>self</code>，系统会将运行的消息转发给这个对象执行。否则，继续查找其他流程。</p>
<h5 id="3-消息重定向"><a href="#3-消息重定向" class="headerlink" title="3.消息重定向"></a>3.消息重定向</h5><p>当以上两种方法无法生效，那么这个对象会因为找不到相应的方法实现而无法响应消息，此时<code>Runtime</code>系统会通过<code>forwardInvocation:</code>消息通知该对象，给予此次消息发送最后一次寻找<code>IMP</code>的机会：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">-</span> (void)forwardInvocation:(<span class="type">NSInvocation</span> <span class="operator">*</span>)anInvocation；</span><br></pre></td></tr></table></figure>

<p>其实每个对象都从<code>NSObject</code>类中继承了<code>forwardInvocation</code>：方法，但是<code>NSObject</code>中的这个方法只是简单的调用了<code>doesNotRecongnizeSelector:</code>方法，提示我们错误。所以我们可以重写这个方法：对不能处理的消息做一些默认处理，也可以将消息转发给其他对象来处理，而不抛出错误。</p>
<p>我们注意到<code>anInvocation</code>是<code>forwardInvocation</code>唯一参数，它封装了原始的消息和消息参数。正是因为它，我们还不得不重写另一个函数：<code>methodSignatureForSelector</code>。这是因为在<code>forwardInvocation:</code> 消息发送前，<code>Runtime</code>系统会向对象发送<code>methodSignatureForSelector</code>消息，并取到返回的方法签名用于生成<code>NSInvocation</code>对象。</p>
<p>下面使用一个示例来重新定义转发逻辑：在上面的<code>TestViewController</code>添加如下代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">-</span>(void)forwardInvocation:(<span class="type">NSInvocation</span> <span class="operator">*</span>)anInvocation&#123;</span><br><span class="line">    <span class="comment">//1.从anInvocation中获取消息</span></span><br><span class="line">    <span class="type">SEL</span> sel <span class="operator">=</span> anInvocation.selector;</span><br><span class="line">    <span class="comment">//2.判断Student方法是否可以响应应sel</span></span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span>.student respondsToSelector:sel]) &#123;</span><br><span class="line">        <span class="comment">//2.1若可以响应，则将消息转发给其他对象处理</span></span><br><span class="line">        [anInvocation invokeWithTarget:<span class="keyword">self</span>.student];</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//2.2若仍然无法响应，则报错：找不到响应方法</span></span><br><span class="line">        [<span class="keyword">self</span> doesNotRecognizeSelector:sel];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//需要从这个方法中获取的信息来创建NSInvocation对象，因此我们必须重写这个方法，为给定的selector提供一个合适的方法签名。</span></span><br><span class="line"><span class="operator">-</span> (<span class="type">NSMethodSignature</span><span class="operator">*</span>)methodSignatureForSelector:(<span class="type">SEL</span>)aSelector&#123;</span><br><span class="line">    <span class="type">NSMethodSignature</span> <span class="operator">*</span>methodSignature <span class="operator">=</span> [<span class="keyword">super</span> methodSignatureForSelector:aSelector];</span><br><span class="line">    <span class="keyword">if</span> (<span class="operator">!</span>methodSignature) &#123;</span><br><span class="line">        methodSignature <span class="operator">=</span> [<span class="type">NSMethodSignature</span> signatureWithObjCTypes:<span class="string">&quot;v@:*&quot;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> methodSignature;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 然后再在视图控制器里直接调用<code>Student</code>的方法如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//self是当前的TestViewController,调用了自己并不存在的learnKonwledge:方法</span></span><br><span class="line">[<span class="keyword">self</span> performSelector:<span class="meta">@selector</span>(learnKnowledge:) withObject:@<span class="string">&quot;天文学”];</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//正常打印:</span></span><br><span class="line"><span class="string">//-[Student learnKnowledge:]</span></span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ol>
<li><p>从以上的代码中就可以看出，<code>forwardingTargetForSelector</code>仅支持一个对象的返回，也就是说消息只能被转发给一个对象，而<code>forwardInvocation</code>可以将消息同时转发给任意多个对象，这就是两者的最大区别。</p>
</li>
<li><p>虽然理论上可以重载<code>doesNotRecognizeSelector</code>函数实现保证不抛出异常（不调用<code>super</code>实现），但是苹果文档着重提出“一定不能让这个函数就这么结束掉，必须抛出异常”。(If you override this method, you must call super or raise an <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsexceptionname/1415426-invalidargumentexception">invalidArgumentException</a> exception at the end of your implementation. In other words, this method must not return normally; it must always result in an exception being thrown.)</p>
</li>
<li><p><code>forwardInvocation</code>甚至能够修改消息的内容，用于实现更加强大的功能;</p>
</li>
</ol>
<h4 id="六、多继承的实现思路：Runtime"><a href="#六、多继承的实现思路：Runtime" class="headerlink" title="六、多继承的实现思路：Runtime"></a>六、多继承的实现思路：Runtime</h4><p>我们会发现<code>Runtime</code>消息转发的一个特点：一个对象可以调起它本身不具备的方法。这个过程与<code>OC</code>中的继承特性很相似，其实官方文档中图示也很好的说明了这个问题：</p>
<img src="http://182.92.228.41/wp-content/uploads/Runtime_multiple_inheritance.png" width="500" align=center/>

<p>图中的<code>Warrior</code>通过<code>forwardInvocation</code>：将<code>negotiate</code>消息转发给了<code>Diplomat</code>，这就好像是<code>Warrior</code>使用了超类<code>Diplomat</code>的方法一样。所以从这个思路，我们可以在实际开发需求中模拟多继承的操作;</p>
<h4 id="七、参考链接"><a href="#七、参考链接" class="headerlink" title="七、参考链接"></a>七、参考链接</h4><ol>
<li><a target="_blank" rel="noopener" href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008048">Objective-C Runtime Programming Guide</a></li>
<li><a target="_blank" rel="noopener" href="https://opensource.apple.com/tarballs/objc4/">Runtime官方源码下载</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/d2f589e3e1ef">objc4-781 源码编译以及调试</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wuyubeichen.github.io/2019/04/15/iOS%E5%BA%95%E5%B1%82-Runtime%E5%BA%94%E7%94%A8%E7%AF%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Author">
      <meta itemprop="description" content="iOS Developer, Beijing China">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="梧雨北辰的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/15/iOS%E5%BA%95%E5%B1%82-Runtime%E5%BA%94%E7%94%A8%E7%AF%87/" class="post-title-link" itemprop="url">iOS底层-Runtime应用篇</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-15 16:16:49" itemprop="dateCreated datePublished" datetime="2019-04-15T16:16:49+08:00">2019-04-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-29 09:39:32" itemprop="dateModified" datetime="2022-08-29T09:39:32+08:00">2022-08-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS%E5%BA%95%E5%B1%82/" itemprop="url" rel="index"><span itemprop="name">iOS底层</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>主要内容：</strong></p>
<ol>
<li><code>Runtime</code>应用场景</li>
<li>动态方法交换：<code>Method Swizzling </code></li>
<li>实现分类添加新属性</li>
<li>获取类的详细信息</li>
<li>解决同一方法高频率调用的效率问题</li>
<li>方法动态解析与消息转发</li>
<li>动态修改属性变量</li>
<li>优化自动归档和解档</li>
<li>实现字典与模型的转换</li>
</ol>
<h4 id="一、Runtime应用场景"><a href="#一、Runtime应用场景" class="headerlink" title="一、Runtime应用场景"></a>一、Runtime应用场景</h4><p>上篇讲述了<code>iOS</code>运行时<code>Runtime</code>基础，本篇将会总结<code>Rutime</code>的具体应用实例。</p>
<p>&#96;结合Runtime动态特性，其在开发中的应用大致分为以下几个方面：</p>
<img src="http://182.92.228.41/wp-content/uploads/Runtime_use_conditions.png" width="600" hegiht="300" align=center>

<h4 id="二、动态方法交换：Method-Swizzling"><a href="#二、动态方法交换：Method-Swizzling" class="headerlink" title="二、动态方法交换：Method Swizzling"></a>二、动态方法交换：Method Swizzling</h4><p>实现动态方法交换(<code>Method Swizzling</code>)是<code>Runtime</code>中最常见的应用场景，其原理是：通过<code>Runtime</code>获取到方法实现的地址，进而动态交换两个方法的功能。使用到关键方法如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取类方法的Mthod</span></span><br><span class="line"><span class="type">Method</span> _Nullable class_getClassMethod(<span class="type">Class</span> _Nullable cls, <span class="type">SEL</span> _Nonnull name)</span><br><span class="line"><span class="comment">//获取实例对象方法的Mthod</span></span><br><span class="line"><span class="type">Method</span> _Nullable class_getInstanceMethod(<span class="type">Class</span> _Nullable cls, <span class="type">SEL</span> _Nonnull name)</span><br><span class="line"><span class="comment">//交换两个方法的实现</span></span><br><span class="line">void method_exchangeImplementations(<span class="type">Method</span> _Nonnull m1, <span class="type">Method</span> _Nonnull m2)</span><br></pre></td></tr></table></figure>

<h5 id="1-动态方法交换示例"><a href="#1-动态方法交换示例" class="headerlink" title="1.动态方法交换示例"></a>1.动态方法交换示例</h5><p>现在演示一个代码示例：在视图控制中，定义两个实例方法<code>printA</code>与<code>printB</code>，然后执行交换</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">-</span> (void)printA&#123;</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;打印A......&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> (void)printB&#123;</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;打印B......&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//交换两个实例方法的实现，并测试打印</span></span><br><span class="line"><span class="type">Method</span> methodA <span class="operator">=</span> class_getInstanceMethod([<span class="keyword">self</span> <span class="keyword">class</span>], <span class="meta">@selector</span>(printA));</span><br><span class="line"><span class="type">Method</span> methodB <span class="operator">=</span> class_getInstanceMethod([<span class="keyword">self</span> <span class="keyword">class</span>], <span class="meta">@selector</span>(printB));</span><br><span class="line">method_exchangeImplementations(methodA, methodB);</span><br><span class="line"></span><br><span class="line">[<span class="keyword">self</span> printA];  <span class="comment">//打印B......</span></span><br><span class="line">[<span class="keyword">self</span> printB];  <span class="comment">//打印A......</span></span><br></pre></td></tr></table></figure>

<h5 id="2-拦截并替换系统方法"><a href="#2-拦截并替换系统方法" class="headerlink" title="2.拦截并替换系统方法"></a>2.拦截并替换系统方法</h5><p><code>Runtime</code>动态方法交换更多的是应用于<code>系统类库</code>和<code>第三方框架</code>的方法替换。在不可见源码的情况下，我们可以借助<code>Rutime</code>交换方法实现，为原有方法添加额外功能，这在实际开发中具有十分重要的意义。</p>
<p>下面将展示一个拦截并替换系统方法的示例：为了实现不同机型上的字体都按照比例适配，我们可以拦截系统<code>UIFont</code>的<code>systemFontOfSize</code>方法，具体操作如下：</p>
<p>步骤1：在当前工程中添加<code>UIFont</code>的分类：<code>UIFont+Adapt</code>,并在其中添用以替换的方法。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">+</span> (<span class="type">UIFont</span> <span class="operator">*</span>)zs_systemFontOfSize:(<span class="type">CGFloat</span>)fontSize&#123;</span><br><span class="line">    <span class="comment">//获取设备屏幕宽度，并计算出比例scale</span></span><br><span class="line">    <span class="type">CGFloat</span> width <span class="operator">=</span> [[<span class="type">UIScreen</span> mainScreen] bounds].size.width;</span><br><span class="line">    <span class="type">CGFloat</span> scale  <span class="operator">=</span> width<span class="operator">/</span><span class="number">375.0</span>;</span><br><span class="line">    <span class="comment">//注意：由于方法交换，系统的方法名已变成了自定义的方法名，所以这里使用了</span></span><br><span class="line">    <span class="comment">//自定义的方法名来获取UIFont</span></span><br><span class="line">    <span class="keyword">return</span> [<span class="type">UIFont</span> zs_systemFontOfSize:fontSize <span class="operator">*</span> scale];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>步骤2：在<code>UIFont</code>的分类中拦截系统方法，将其替换为我们自定义的方法，代码如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//load方法不需要手动调用，iOS会在应用程序启动的时候自动调起load方法，</span></span><br><span class="line"><span class="comment">//而且load执行时间较早，所以在此方法中执行交换操作比较合适。</span></span><br><span class="line"><span class="operator">+</span> (void)load&#123;</span><br><span class="line">    <span class="comment">//获取系统方法地址</span></span><br><span class="line">    <span class="type">Method</span> sytemMethod <span class="operator">=</span> class_getClassMethod([<span class="type">UIFont</span> <span class="keyword">class</span>], <span class="meta">@selector</span>(systemFontOfSize:));</span><br><span class="line">    <span class="comment">//获取自定义方法地址</span></span><br><span class="line">    <span class="type">Method</span> customMethod <span class="operator">=</span> class_getClassMethod([<span class="type">UIFont</span> <span class="keyword">class</span>], <span class="meta">@selector</span>(zs_systemFontOfSize:));</span><br><span class="line">    <span class="comment">//交换两个方法的实现</span></span><br><span class="line">    method_exchangeImplementations(sytemMethod, customMethod);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加一段测试代码，切换不同的模拟器，观察在不同机型上文字的大小：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UILabel</span> <span class="operator">*</span>label <span class="operator">=</span> [[<span class="type">UILabel</span> alloc] initWithFrame:<span class="type">CGRectMake</span>(<span class="number">0</span>, <span class="number">100</span>, <span class="number">300</span>, <span class="number">50</span>)];</span><br><span class="line">label.text <span class="operator">=</span> @<span class="string">&quot;测试Runtime拦截方法&quot;</span>;</span><br><span class="line">label.font <span class="operator">=</span> [<span class="type">UIFont</span> systemFontOfSize:<span class="number">20</span>];</span><br><span class="line">[<span class="keyword">self</span>.view addSubview:label];</span><br></pre></td></tr></table></figure>
<p>这里只是一个简单的示例，详细的用法可参考：</p>
<h4 id="三、实现分类添加新属性"><a href="#三、实现分类添加新属性" class="headerlink" title="三、实现分类添加新属性"></a>三、实现分类添加新属性</h4><p>我们在开发中常常使用类目<code>Category</code>为一些已有的类扩展功能。虽然继承也能够为已有类增加新的方法，而且相比类目更是具有增加属性的优势，但是继承毕竟是一个重量级的操作，添加不必要的继承关系无疑增加了代码的复杂度。</p>
<p>遗憾的是，<code>OC</code>的类目并不支持直接添加属性，如果我们直接在分类的声明中写入<code>Property</code>属性，那么只能为其生成<code>set</code>与<code>get</code>方法声明，却不能生成成员变量，直接调用这些属性还会造成崩溃。</p>
<p>所以为了实现给分类添加属性，我们还需借助<code>Runtime</code>的关联对象(<code>Associated Objects</code>)特性，它能够帮助我们在运行阶段将任意的属性关联到一个对象上，下面是相关的三个方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 1.给对象设置关联属性</span></span><br><span class="line"><span class="comment"> @param object 需要设置关联属性的对象，即给哪个对象关联属性</span></span><br><span class="line"><span class="comment"> @param key 关联属性对应的key，可通过key获取这个属性，</span></span><br><span class="line"><span class="comment"> @param value 给关联属性设置的值</span></span><br><span class="line"><span class="comment"> @param policy 关联属性的存储策略(对应Property属性中的assign,copy，retain等)</span></span><br><span class="line"><span class="comment"> OBJC_ASSOCIATION_ASSIGN             @property(assign)。</span></span><br><span class="line"><span class="comment"> OBJC_ASSOCIATION_RETAIN_NONATOMIC   @property(strong, nonatomic)。</span></span><br><span class="line"><span class="comment"> OBJC_ASSOCIATION_COPY_NONATOMIC     @property(copy, nonatomic)。</span></span><br><span class="line"><span class="comment"> OBJC_ASSOCIATION_RETAIN             @property(strong,atomic)。</span></span><br><span class="line"><span class="comment"> OBJC_ASSOCIATION_COPY               @property(copy, atomic)。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">void objc_setAssociatedObject(id _Nonnull object,</span><br><span class="line">                              const void <span class="operator">*</span> _Nonnull key,</span><br><span class="line">                              id _Nullable value,</span><br><span class="line">                              objc_AssociationPolicy policy)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 2.通过key获取关联的属性</span></span><br><span class="line"><span class="comment"> @param object 从哪个对象中获取关联属性</span></span><br><span class="line"><span class="comment"> @param key 关联属性对应的key</span></span><br><span class="line"><span class="comment"> @return 返回关联属性的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">id _Nullable objc_getAssociatedObject(id _Nonnull object,</span><br><span class="line">                                      const void <span class="operator">*</span> _Nonnull key)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 3.移除对象所关联的属性</span></span><br><span class="line"><span class="comment"> @param object 移除某个对象的所有关联属性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">void objc_removeAssociatedObjects(id _Nonnull object)</span><br></pre></td></tr></table></figure>

<p>注意：<code>key</code>与关联属性一一对应，我们必须确保其全局唯一性；</p>
<p>现在演示一个代码示例：为<code>*UIImage*</code>增加一个分类：<code>UIImage+Tools</code>，并为其设置关联属性<code>urlString</code>(图片网络链接属性），相关代码如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//UIImage+Tools.h文件中</span></span><br><span class="line"><span class="type">UIImage</span><span class="operator">+</span><span class="type">Tools</span>.m</span><br><span class="line"><span class="meta">@interface</span> <span class="type">UIImage</span> (<span class="type">Tools</span>)</span><br><span class="line"><span class="comment">//添加一个新属性：图片网络链接</span></span><br><span class="line"><span class="meta">@property</span>(nonatomic,copy)<span class="type">NSString</span> <span class="operator">*</span>urlString;</span><br><span class="line"><span class="meta">@end</span></span><br></pre></td></tr></table></figure>

<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//UIImage+Tools.m文件中</span></span><br><span class="line">#<span class="keyword">import</span> &quot;UIImage+Tools.h&quot;</span><br><span class="line">#<span class="keyword">import</span> &lt;objc/runtime.h&gt;</span><br><span class="line"><span class="meta">@implementation</span> <span class="type">UIImage</span> (<span class="type">Tools</span>)</span><br><span class="line"><span class="comment">//set方法</span></span><br><span class="line"><span class="operator">-</span> (void)setUrlString:(<span class="type">NSString</span> <span class="operator">*</span>)urlString&#123;</span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>,</span><br><span class="line">                             <span class="meta">@selector</span>(urlString),</span><br><span class="line">                             urlString,</span><br><span class="line">                             <span class="type">OBJC_ASSOCIATION_RETAIN_NONATOMIC</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//get方法</span></span><br><span class="line"><span class="operator">-</span> (<span class="type">NSString</span> <span class="operator">*</span>)urlString&#123;</span><br><span class="line">    <span class="keyword">return</span> objc_getAssociatedObject(<span class="keyword">self</span>,</span><br><span class="line">                                    <span class="meta">@selector</span>(urlString));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//添加一个自定义方法，用于清除所有关联属性</span></span><br><span class="line"><span class="operator">-</span> (void)clearAssociatedObjcet&#123;</span><br><span class="line">    objc_removeAssociatedObjects(<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@end</span></span><br></pre></td></tr></table></figure>

<p> 测试文件中:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UIImage</span> <span class="operator">*</span>image <span class="operator">=</span> [[<span class="type">UIImage</span> alloc] <span class="keyword">init</span>];</span><br><span class="line">image.urlString <span class="operator">=</span> @<span class="string">&quot;http://www.image.png&quot;</span>;</span><br><span class="line"><span class="type">NSLog</span>(@<span class="string">&quot;获取关联属性：%@&quot;</span>,image.urlString);</span><br><span class="line">    </span><br><span class="line">[image clearAssociatedObjcet];</span><br><span class="line"><span class="type">NSLog</span>(@<span class="string">&quot;获取关联属性：%@&quot;</span>,image.urlString);</span><br><span class="line"><span class="comment">//打印：</span></span><br><span class="line"><span class="comment">//获取关联属性：http://www.image.png</span></span><br><span class="line"><span class="comment">//获取关联属性：(null)</span></span><br></pre></td></tr></table></figure>



<h4 id="四、获取类的详细信息"><a href="#四、获取类的详细信息" class="headerlink" title="四、获取类的详细信息"></a>四、获取类的详细信息</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#<span class="keyword">import</span> &lt;Foundation/Foundation.h&gt;</span><br><span class="line">#<span class="keyword">import</span> &lt;objc/runtime.h&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">@interface</span> <span class="type">ClassA</span> : <span class="type">NSObject</span> &#123;</span><br><span class="line"> int _a;</span><br><span class="line"> int _b;</span><br><span class="line"> int _c;</span><br><span class="line"> <span class="type">CGFloat</span> d; <span class="comment">//不推荐这样写</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@property</span> (nonatomic, strong) <span class="type">NSArray</span>          <span class="operator">*</span>arrayA;</span><br><span class="line"><span class="meta">@property</span> (nonatomic, copy  ) <span class="type">NSString</span>         <span class="operator">*</span>stringA;</span><br><span class="line"><span class="meta">@property</span> (nonatomic, assign) dispatch_queue_t testQueue;</span><br><span class="line"></span><br><span class="line"><span class="meta">@end</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@implementation</span> <span class="type">ClassA</span></span><br><span class="line"><span class="meta">@end</span></span><br></pre></td></tr></table></figure>

<h5 id="1-获取所有成员变量"><a href="#1-获取所有成员变量" class="headerlink" title="1.获取所有成员变量"></a>1.获取所有成员变量</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Ivar</span> <span class="operator">*</span>ivarList <span class="operator">=</span> class_copyIvarList([<span class="keyword">self</span> <span class="keyword">class</span>], <span class="operator">&amp;</span>count);</span><br><span class="line"><span class="keyword">for</span> (int i<span class="operator">=</span> <span class="number">0</span>; i<span class="operator">&lt;</span>count; i<span class="operator">++</span>) &#123;</span><br><span class="line">    <span class="type">Ivar</span> ivar <span class="operator">=</span> ivarList[i];</span><br><span class="line">    const char <span class="operator">*</span>ivarName <span class="operator">=</span> ivar_getName(ivar);</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;Ivar(%d): %@&quot;</span>, i, [<span class="type">NSString</span> stringWithUTF8String:ivarName]);</span><br><span class="line">&#125;</span><br><span class="line">free(ivarList);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">打印结果：</span></span><br><span class="line"><span class="comment">_a</span></span><br><span class="line"><span class="comment">_b</span></span><br><span class="line"><span class="comment">_c</span></span><br><span class="line"><span class="comment">d</span></span><br><span class="line"><span class="comment">_arrayA</span></span><br><span class="line"><span class="comment">_stringA</span></span><br><span class="line"><span class="comment">_testQueue</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h5 id="2-获取属性列表"><a href="#2-获取属性列表" class="headerlink" title="2.获取属性列表"></a>2.获取属性列表</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">unsigned int count;</span><br><span class="line">objc_property_t <span class="operator">*</span>propertyList <span class="operator">=</span> class_copyPropertyList([<span class="keyword">self</span> <span class="keyword">class</span>], <span class="operator">&amp;</span>count);</span><br><span class="line"><span class="keyword">for</span> (unsigned int i <span class="operator">=</span> <span class="number">0</span>; i<span class="operator">&lt;</span>count; i<span class="operator">++</span>) &#123;</span><br><span class="line">    const char <span class="operator">*</span>propertyName <span class="operator">=</span> property_getName(propertyList[i]);</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;PropertyName(%d): %@&quot;</span>,i,[<span class="type">NSString</span> stringWithUTF8String:propertyName]);</span><br><span class="line">&#125;</span><br><span class="line">free(propertyList);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">打印结果：</span></span><br><span class="line"><span class="comment">arrayA</span></span><br><span class="line"><span class="comment">stringA</span></span><br><span class="line"><span class="comment">testQueue</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h5 id="3-获取所有方法"><a href="#3-获取所有方法" class="headerlink" title="3.获取所有方法"></a>3.获取所有方法</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Method</span> <span class="operator">*</span>methodList <span class="operator">=</span> class_copyMethodList([<span class="keyword">self</span> <span class="keyword">class</span>], <span class="operator">&amp;</span>count);</span><br><span class="line"><span class="keyword">for</span> (unsigned int i <span class="operator">=</span> <span class="number">0</span>; i<span class="operator">&lt;</span>count; i<span class="operator">++</span>) &#123;</span><br><span class="line">    <span class="type">Method</span> method <span class="operator">=</span> methodList[i];</span><br><span class="line">    <span class="type">SEL</span> mthodName <span class="operator">=</span> method_getName(method);</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;MethodName(%d): %@&quot;</span>,i,<span class="type">NSStringFromSelector</span>(mthodName));</span><br><span class="line">&#125;</span><br><span class="line">free(methodList);</span><br></pre></td></tr></table></figure>

<h5 id="4-获取当前遵循的所有协议"><a href="#4-获取当前遵循的所有协议" class="headerlink" title="4.获取当前遵循的所有协议"></a>4.获取当前遵循的所有协议</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__unsafe_unretained <span class="type">Protocol</span> <span class="operator">**</span>protocolList <span class="operator">=</span> class_copyProtocolList([<span class="keyword">self</span> <span class="keyword">class</span>], <span class="operator">&amp;</span>count);</span><br><span class="line"><span class="keyword">for</span> (int i<span class="operator">=</span><span class="number">0</span>; i<span class="operator">&lt;</span>count; i<span class="operator">++</span>) &#123;</span><br><span class="line">    <span class="type">Protocol</span> <span class="operator">*</span>protocal <span class="operator">=</span> protocolList[i];</span><br><span class="line">    const char <span class="operator">*</span>protocolName <span class="operator">=</span> protocol_getName(protocal);</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;protocol(%d): %@&quot;</span>,i, [<span class="type">NSString</span> stringWithUTF8String:protocolName]);</span><br><span class="line">&#125;</span><br><span class="line">free(propertyList);</span><br></pre></td></tr></table></figure>

<p><strong>注意：C语言中使用Copy操作的方法，要注意释放指针，防止内存泄漏</strong></p>
<h4 id="五、解决同一方法高频率调用的效率问题"><a href="#五、解决同一方法高频率调用的效率问题" class="headerlink" title="五、解决同一方法高频率调用的效率问题"></a>五、解决同一方法高频率调用的效率问题</h4><p><code>Runtime</code>源码中的<code>IMP</code>作为函数指针，指向方法的实现。通过它，我们可以绕开发送消息的过程来提高函数调用的效率。当我们需要持续大量重复调用某个方法的时候，会十分有用，具体代码示例如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void (<span class="operator">*</span>setter)(id, <span class="type">SEL</span>, <span class="type">BOOL</span>);</span><br><span class="line">int i;</span><br><span class="line"></span><br><span class="line">setter <span class="operator">=</span> (void (<span class="operator">*</span>)(id, <span class="type">SEL</span>, <span class="type">BOOL</span>))[target methodForSelector:<span class="meta">@selector</span>(setFilled:)];</span><br><span class="line"><span class="keyword">for</span> ( i <span class="operator">=</span> <span class="number">0</span> ; i <span class="operator">&lt;</span> <span class="number">1000</span> ; i<span class="operator">++</span> )</span><br><span class="line">    setter(targetList[i], <span class="meta">@selector</span>(setFilled:), <span class="type">YES</span>);</span><br></pre></td></tr></table></figure>



<h4 id="六、方法动态解析与消息转发"><a href="#六、方法动态解析与消息转发" class="headerlink" title="六、方法动态解析与消息转发"></a>六、方法动态解析与消息转发</h4><p>其实该部分可以参考基础篇中内容，这里不再重复赘述，只是大概做出一些总结。</p>
<h5 id="1-动态方法解析：动态添加方法"><a href="#1-动态方法解析：动态添加方法" class="headerlink" title="1.动态方法解析：动态添加方法"></a>1.动态方法解析：动态添加方法</h5><p><code>Runtime</code>足够强大，能够让我们在运行时动态添加一个未实现的方法，这个功能主要有两个应用场景：</p>
<p>场景1：动态添加未实现方法，解决代码中因为方法未找到而报错的问题；</p>
<p>场景2：利用懒加载思路，若一个类有很多个方法，同时加载到内存中会耗费资源，可以使用动态解析添加方法。方法动态解析主要用到的方法如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//OC方法：</span></span><br><span class="line"><span class="comment">//类方法未找到时调起，可于此添加类方法实现</span></span><br><span class="line"><span class="operator">+</span> (<span class="type">BOOL</span>)resolveClassMethod:(<span class="type">SEL</span>)sel</span><br><span class="line"></span><br><span class="line"><span class="comment">//实例方法未找到时调起，可于此添加实例方法实现</span></span><br><span class="line"><span class="operator">+</span> (<span class="type">BOOL</span>)resolveInstanceMethod:(<span class="type">SEL</span>)sel</span><br><span class="line"></span><br><span class="line"><span class="comment">//Runtime方法：</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 运行时方法：向指定类中添加特定方法实现的操作</span></span><br><span class="line"><span class="comment"> @param cls 被添加方法的类</span></span><br><span class="line"><span class="comment"> @param name selector方法名</span></span><br><span class="line"><span class="comment"> @param imp 指向实现方法的函数指针</span></span><br><span class="line"><span class="comment"> @param types imp函数实现的返回值与参数类型</span></span><br><span class="line"><span class="comment"> @return 添加方法是否成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">BOOL</span> class_addMethod(<span class="type">Class</span> _Nullable cls,</span><br><span class="line">                     <span class="type">SEL</span> _Nonnull name,</span><br><span class="line">                     <span class="type">IMP</span> _Nonnull imp,</span><br><span class="line">                     const char <span class="operator">*</span> _Nullable types)</span><br></pre></td></tr></table></figure>

<h5 id="2-解决方法无响应崩溃问题"><a href="#2-解决方法无响应崩溃问题" class="headerlink" title="2.解决方法无响应崩溃问题"></a>2.解决方法无响应崩溃问题</h5><p>执行<code>OC</code>方法其实就是一个发送消息的过程，若方法未实现，我们可以利用方法动态解析与消息转发来避免程序崩溃，这主要涉及下面一个处理未实现消息的过程：</p>
<img src="http://182.92.228.41/wp-content/uploads/Runtime_message_forward.png" width="600" align=center>

<p>除了上述的方法动态解析，还使用到的相关方法如下：</p>
<p>消息接收者重定向</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重定向类方法的消息接收者，返回一个类</span></span><br><span class="line"><span class="operator">-</span> (id)forwardingTargetForSelector:(<span class="type">SEL</span>)aSelector</span><br><span class="line"></span><br><span class="line"><span class="comment">//重定向实例方法的消息接受者，返回一个实例对象</span></span><br><span class="line"><span class="operator">-</span> (id)forwardingTargetForSelector:(<span class="type">SEL</span>)aSelector</span><br></pre></td></tr></table></figure>

<p>消息重定向</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">-</span> (void)forwardInvocation:(<span class="type">NSInvocation</span> <span class="operator">*</span>)anInvocation；</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> (<span class="type">NSMethodSignature</span><span class="operator">*</span>)methodSignatureForSelector:(<span class="type">SEL</span>)aSelector;</span><br></pre></td></tr></table></figure>



<h4 id="七、动态修改属性变量"><a href="#七、动态修改属性变量" class="headerlink" title="七、动态修改属性变量"></a>七、动态修改属性变量</h4><p>现在假设这样一个情况：我们使用第三方框架里的<code>Person</code>类，在特殊需求下想要更改其私有属性<code>nickName</code>，这样的操作我们就可以使用<code>Runtime</code>可以动态修改对象属性。</p>
<p>基本思路：首先使用<code>Runtime</code>获取<code>Peson</code>对象的所有属性，找到<code>nickName</code>，然后使用<code>ivar</code>的方法修改其值。具体的代码示例如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="operator">*</span>ps <span class="operator">=</span> [[<span class="type">Person</span> alloc] <span class="keyword">init</span>];</span><br><span class="line"><span class="type">NSLog</span>(@<span class="string">&quot;ps-nickName: %@&quot;</span>,[ps valueForKey:@<span class="string">&quot;nickName&quot;</span>]); <span class="comment">//null</span></span><br><span class="line"><span class="comment">//第一步：遍历对象的所有属性</span></span><br><span class="line">unsigned int count;</span><br><span class="line"><span class="type">Ivar</span> <span class="operator">*</span>ivarList <span class="operator">=</span> class_copyIvarList([ps <span class="keyword">class</span>], <span class="operator">&amp;</span>count);</span><br><span class="line"><span class="keyword">for</span> (int i<span class="operator">=</span> <span class="number">0</span>; i<span class="operator">&lt;</span>count; i<span class="operator">++</span>) &#123;</span><br><span class="line">    <span class="comment">//第二步：获取每个属性名</span></span><br><span class="line">    <span class="type">Ivar</span> ivar <span class="operator">=</span> ivarList[i];</span><br><span class="line">    const char <span class="operator">*</span>ivarName <span class="operator">=</span> ivar_getName(ivar);</span><br><span class="line">    <span class="type">NSString</span> <span class="operator">*</span>propertyName <span class="operator">=</span> [<span class="type">NSString</span> stringWithUTF8String:ivarName];</span><br><span class="line">    <span class="keyword">if</span> ([propertyName isEqualToString:@<span class="string">&quot;_nickName&quot;</span>]) &#123;</span><br><span class="line">        <span class="comment">//第三步：匹配到对应的属性，然后修改；注意属性带有下划线</span></span><br><span class="line">        object_setIvar(ps, ivar, @<span class="string">&quot;梧雨北辰&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">NSLog</span>(@<span class="string">&quot;ps-nickName: %@&quot;</span>,[ps valueForKey:@<span class="string">&quot;nickName&quot;</span>]); <span class="comment">//梧雨北辰</span></span><br></pre></td></tr></table></figure>

<p>总结：此过程类似<code>KVC</code>的取值和赋值</p>
<h4 id="八、优化自动归档和解档"><a href="#八、优化自动归档和解档" class="headerlink" title="八、优化自动归档和解档"></a>八、优化自动归档和解档</h4><p>归档是一种常用的轻量型文件存储方式，但是它有个弊端：在归档过程中，若一个<code>Model</code>有多个属性，我们不得不对每个属性进行处理，非常繁琐。</p>
<p>归档操作主要涉及两个方法：<code>encodeObject</code> 和 <code>decodeObjectForKey</code>，现在，我们可以利用<code>Runtime</code>来改进它们，关键的代码示例如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原理：使用Runtime动态获取所有属性</span></span><br><span class="line"><span class="comment">//解档操作</span></span><br><span class="line"><span class="operator">-</span> (instancetype)initWithCoder:(<span class="type">NSCoder</span> <span class="operator">*</span>)aDecoder&#123;</span><br><span class="line">    <span class="keyword">self</span> <span class="operator">=</span> [<span class="keyword">super</span> <span class="keyword">init</span>];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        unsigned int count <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">Ivar</span> <span class="operator">*</span>ivarList <span class="operator">=</span> class_copyIvarList([<span class="keyword">self</span> <span class="keyword">class</span>], <span class="operator">&amp;</span>count);</span><br><span class="line">        <span class="keyword">for</span> (int i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> count; i<span class="operator">++</span>) &#123;</span><br><span class="line">            <span class="type">Ivar</span> ivar <span class="operator">=</span> ivarList[i];</span><br><span class="line">            const char <span class="operator">*</span>ivarName <span class="operator">=</span> ivar_getName(ivar);</span><br><span class="line">            <span class="type">NSString</span> <span class="operator">*</span>key <span class="operator">=</span> [<span class="type">NSString</span> stringWithUTF8String:ivarName];</span><br><span class="line">            id value <span class="operator">=</span> [aDecoder decodeObjectForKey:key];</span><br><span class="line">            [<span class="keyword">self</span> setValue:value forKey:key];</span><br><span class="line">        &#125;</span><br><span class="line">        free(ivarList); <span class="comment">//释放指针</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//归档操作</span></span><br><span class="line"><span class="operator">-</span> (void)encodeWithCoder:(<span class="type">NSCoder</span> <span class="operator">*</span>)aCoder&#123;</span><br><span class="line">    unsigned int count <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">Ivar</span> <span class="operator">*</span>ivarList <span class="operator">=</span> class_copyIvarList([<span class="keyword">self</span> <span class="keyword">class</span>], <span class="operator">&amp;</span>count);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">NSInteger</span> i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> count; i<span class="operator">++</span>) &#123;</span><br><span class="line">        <span class="type">Ivar</span> ivar <span class="operator">=</span> ivarList[i];</span><br><span class="line">        <span class="type">NSString</span> <span class="operator">*</span>key <span class="operator">=</span> [<span class="type">NSString</span> stringWithUTF8String:ivar_getName(ivar)];</span><br><span class="line">        </span><br><span class="line">        id value <span class="operator">=</span> [<span class="keyword">self</span> valueForKey:key];</span><br><span class="line">        [aCoder encodeObject:value forKey:key];</span><br><span class="line">    &#125;</span><br><span class="line">    free(ivarList); <span class="comment">//释放指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是有关归档的测试代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//--测试归档</span></span><br><span class="line"><span class="type">Person</span> <span class="operator">*</span>ps <span class="operator">=</span> [[<span class="type">Person</span> alloc] <span class="keyword">init</span>];</span><br><span class="line">ps.name <span class="operator">=</span> @<span class="string">&quot;梧雨北辰&quot;</span>;</span><br><span class="line">ps.age  <span class="operator">=</span> <span class="number">18</span>;</span><br><span class="line"><span class="type">NSString</span> <span class="operator">*</span>temp <span class="operator">=</span> <span class="type">NSTemporaryDirectory</span>();</span><br><span class="line"><span class="type">NSString</span> <span class="operator">*</span>fileTemp <span class="operator">=</span> [temp stringByAppendingString:@<span class="string">&quot;person.archive&quot;</span>];</span><br><span class="line">[<span class="type">NSKeyedArchiver</span> archiveRootObject:ps toFile:fileTemp];</span><br><span class="line"></span><br><span class="line"><span class="comment">//--测试解档</span></span><br><span class="line"><span class="type">NSString</span> <span class="operator">*</span>temp <span class="operator">=</span> <span class="type">NSTemporaryDirectory</span>();</span><br><span class="line"><span class="type">NSString</span> <span class="operator">*</span>fileTemp <span class="operator">=</span> [temp stringByAppendingString:@<span class="string">&quot;person.henry&quot;</span>];</span><br><span class="line"><span class="type">Person</span> <span class="operator">*</span>person <span class="operator">=</span> [<span class="type">NSKeyedUnarchiver</span> unarchiveObjectWithFile:fileTemp];</span><br><span class="line"><span class="type">NSLog</span>(@<span class="string">&quot;person-name:%@，person-age:%ld&quot;</span>,person.name,person.age); </span><br><span class="line"><span class="comment">//person-name:梧雨北辰，person-age:18</span></span><br></pre></td></tr></table></figure>



<h4 id="九、实现字典与模型的转换"><a href="#九、实现字典与模型的转换" class="headerlink" title="九、实现字典与模型的转换"></a>九、实现字典与模型的转换</h4><p>字典数据转模型的操作在项目开发中很常见，通常我们会选择第三方如<code>YYModel</code>；其实我们也可以自己来实现这一功能，主要的思路有两种：<code>KVC</code>、<code>Runtime</code>，总结字典转化模型过程中需要解决的问题如下：</p>
<img src="http://182.92.228.41/wp-content/uploads/Runtime_use_dic_model_analyze.png" width="600" hegiht="300" align=center>

<p>现在，我们使用<code>Runtime</code>来实现字典转模型的操作，大致的思路是这样：</p>
<p>借助<code>Runtime</code>可以动态获取成员列表的特性，遍历模型中所有属性，然后以获取到的属性名为<code>key</code>，在<code>JSON</code>字典中寻找对应的值<code>value</code>；再将每一个对应<code>Value</code>赋值给模型，就完成了字典转模型的目的。</p>
<p>首先准备下面的<code>JSON</code>数据用于测试：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;id&quot;</span>:<span class="string">&quot;2462079046&quot;</span>,</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;梧雨北辰&quot;</span>,</span><br><span class="line">    <span class="string">&quot;age&quot;</span>:<span class="string">&quot;18&quot;</span>,</span><br><span class="line">    <span class="string">&quot;weight&quot;</span>:<span class="number">140</span>,</span><br><span class="line">    <span class="string">&quot;address&quot;</span>:&#123;</span><br><span class="line">            <span class="string">&quot;country&quot;</span>:<span class="string">&quot;中国&quot;</span>,</span><br><span class="line">            <span class="string">&quot;province&quot;</span>: <span class="string">&quot;河南&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">    <span class="string">&quot;courses&quot;</span>:[&#123;</span><br><span class="line">               <span class="string">&quot;name&quot;</span>:<span class="string">&quot;Chinese&quot;</span>,</span><br><span class="line">               <span class="string">&quot;desc&quot;</span>:<span class="string">&quot;语文课&quot;</span></span><br><span class="line">    &#125;,&#123;</span><br><span class="line">               <span class="string">&quot;name&quot;</span>:<span class="string">&quot;Math&quot;</span>,</span><br><span class="line">               <span class="string">&quot;desc&quot;</span>:<span class="string">&quot;数学课&quot;</span></span><br><span class="line">    &#125;,&#123;</span><br><span class="line">               <span class="string">&quot;name&quot;</span>:<span class="string">&quot;English&quot;</span>,</span><br><span class="line">               <span class="string">&quot;desc&quot;</span>:<span class="string">&quot;英语课&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体的代码实现流程如下：</p>
<h5 id="步骤1：创建NSObject的类目NSObject-ZSModel，用于实现字典转模型"><a href="#步骤1：创建NSObject的类目NSObject-ZSModel，用于实现字典转模型" class="headerlink" title="步骤1：创建NSObject的类目NSObject+ZSModel，用于实现字典转模型"></a>步骤1：创建NSObject的类目NSObject+ZSModel，用于实现字典转模型</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@interface</span> <span class="type">NSObject</span> (<span class="type">ZSModel</span>)</span><br><span class="line"><span class="operator">+</span> (instancetype)zs_modelWithDictionary:(<span class="type">NSDictionary</span> <span class="operator">*</span>)dictionary;</span><br><span class="line"><span class="meta">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ZSModel协议，协议方法可以返回一个字典，表明特殊字段的处理规则</span></span><br><span class="line"><span class="meta">@protocol</span> <span class="type">ZSModel</span>&lt;<span class="type">NSObject</span>&gt;</span><br><span class="line"><span class="meta">@optional</span></span><br><span class="line"><span class="operator">+</span> (nullable <span class="type">NSDictionary</span>&lt;<span class="type">NSString</span> *, id&gt; <span class="operator">*</span>)modelContainerPropertyGenericClass;</span><br><span class="line"><span class="meta">@end</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">#<span class="keyword">import</span> &quot;NSObject+ZSModel.h&quot;</span><br><span class="line">#<span class="keyword">import</span> &lt;objc/runtime.h&gt;</span><br><span class="line"><span class="meta">@implementation</span> <span class="type">NSObject</span> (<span class="type">ZSModel</span>)</span><br><span class="line"><span class="operator">+</span> (instancetype)zs_modelWithDictionary:(<span class="type">NSDictionary</span> <span class="operator">*</span>)dictionary&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建当前模型对象</span></span><br><span class="line">    id object <span class="operator">=</span> [[<span class="keyword">self</span> alloc] <span class="keyword">init</span>];</span><br><span class="line">    <span class="comment">//1.获取当前对象的成员变量列表</span></span><br><span class="line">    unsigned int count <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">Ivar</span> <span class="operator">*</span>ivarList <span class="operator">=</span> class_copyIvarList([<span class="keyword">self</span> <span class="keyword">class</span>], <span class="operator">&amp;</span>count);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.遍历ivarList中所有成员变量，以其属性名为key，在字典中查找Value</span></span><br><span class="line">    <span class="keyword">for</span> (int i<span class="operator">=</span> <span class="number">0</span>; i<span class="operator">&lt;</span>count; i<span class="operator">++</span>) &#123;</span><br><span class="line">        <span class="comment">//2.1获取成员属性</span></span><br><span class="line">        <span class="type">Ivar</span> ivar <span class="operator">=</span> ivarList[i];</span><br><span class="line">        <span class="type">NSString</span> <span class="operator">*</span>ivarName <span class="operator">=</span> [<span class="type">NSString</span> stringWithUTF8String:ivar_getName(ivar)] ;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.2截取成员变量名：去掉成员变量前面的&quot;_&quot;号</span></span><br><span class="line">        <span class="type">NSString</span> <span class="operator">*</span>propertyName <span class="operator">=</span> [ivarName substringFromIndex:<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.3以属性名为key，在字典中查找value</span></span><br><span class="line">        id value <span class="operator">=</span> dictionary[propertyName];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3.获取成员变量类型, 因为ivar_getTypeEncoding获取的类型是&quot;@\&quot;NSString\&quot;&quot;的形式</span></span><br><span class="line">        <span class="comment">//所以我们要做以下的替换</span></span><br><span class="line">        <span class="type">NSString</span> <span class="operator">*</span>ivarType <span class="operator">=</span> [<span class="type">NSString</span> stringWithUTF8String:ivar_getTypeEncoding(ivar)];<span class="comment">// 替换:</span></span><br><span class="line">        <span class="comment">//3.1去除转义字符：@\&quot;name\&quot; -&gt; @&quot;name&quot;</span></span><br><span class="line">        ivarType <span class="operator">=</span> [ivarType stringByReplacingOccurrencesOfString:@<span class="string">&quot;<span class="subst">\&quot;</span>&quot;</span> withString:@<span class="string">&quot;&quot;</span>];</span><br><span class="line">        <span class="comment">//3.2去除@符号</span></span><br><span class="line">        ivarType <span class="operator">=</span> [ivarType stringByReplacingOccurrencesOfString:@<span class="string">&quot;@&quot;</span> withString:@<span class="string">&quot;&quot;</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4.对特殊成员变量进行处理：</span></span><br><span class="line">        <span class="comment">//判断当前类是否实现了协议方法，获取协议方法中规定的特殊变量的处理方式</span></span><br><span class="line">        <span class="type">NSDictionary</span> <span class="operator">*</span>perpertyTypeDic;</span><br><span class="line">        <span class="keyword">if</span>([<span class="keyword">self</span> respondsToSelector:<span class="meta">@selector</span>(modelContainerPropertyGenericClass)])&#123;</span><br><span class="line">            perpertyTypeDic <span class="operator">=</span> [<span class="keyword">self</span> performSelector:<span class="meta">@selector</span>(modelContainerPropertyGenericClass) withObject:<span class="literal">nil</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4.1处理：字典的key与模型属性不匹配的问题，如id-&gt;uid</span></span><br><span class="line">        id anotherName <span class="operator">=</span> perpertyTypeDic[propertyName];</span><br><span class="line">        <span class="keyword">if</span>(anotherName <span class="operator">&amp;&amp;</span> [anotherName isKindOfClass:[<span class="type">NSString</span> <span class="keyword">class</span>]])&#123;</span><br><span class="line">            value <span class="operator">=</span>  dictionary[anotherName];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4.2.处理：模型嵌套模型</span></span><br><span class="line">        <span class="keyword">if</span> ([value isKindOfClass:[<span class="type">NSDictionary</span> <span class="keyword">class</span>]] <span class="operator">&amp;&amp;</span> <span class="operator">!</span>[ivarType hasPrefix:@<span class="string">&quot;NS&quot;</span>]) &#123;</span><br><span class="line">            <span class="type">Class</span> modelClass <span class="operator">=</span> <span class="type">NSClassFromString</span>(ivarType);</span><br><span class="line">            <span class="keyword">if</span> (modelClass <span class="operator">!=</span> <span class="literal">nil</span>) &#123;</span><br><span class="line">                <span class="comment">//将被嵌套字典数据也转化成Model</span></span><br><span class="line">                value <span class="operator">=</span> [modelClass zs_modelWithDictionary:value];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4.3处理：模型嵌套模型数组</span></span><br><span class="line">        <span class="comment">//判断当前Vaue是一个数组，而且存在协议方法返回了perpertyTypeDic</span></span><br><span class="line">        <span class="keyword">if</span> ([value isKindOfClass:[<span class="type">NSArray</span> <span class="keyword">class</span>]] <span class="operator">&amp;&amp;</span> perpertyTypeDic) &#123;</span><br><span class="line">            <span class="type">Class</span> itemModelClass <span class="operator">=</span> perpertyTypeDic[propertyName];</span><br><span class="line">            <span class="comment">//封装数组：将每一个子数据转化为Model</span></span><br><span class="line">            <span class="type">NSMutableArray</span> <span class="operator">*</span>itemArray <span class="operator">=</span> @[].mutableCopy;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">NSDictionary</span> <span class="operator">*</span>itemDic  <span class="keyword">in</span> value) &#123;</span><br><span class="line">                id model <span class="operator">=</span> [itemModelClass zs_modelWithDictionary:itemDic];</span><br><span class="line">                [itemArray addObject:model];</span><br><span class="line">            &#125;</span><br><span class="line">            value <span class="operator">=</span> itemArray;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//5.使用KVC方法将Vlue更新到object中</span></span><br><span class="line">        <span class="keyword">if</span> (value <span class="operator">!=</span> <span class="literal">nil</span>) &#123;</span><br><span class="line">            [object setValue:value forKey:propertyName];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    free(ivarList); <span class="comment">//释放C指针</span></span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@end</span></span><br></pre></td></tr></table></figure>



<h5 id="步骤2：分别创建各个数据模型Student、Address、Course"><a href="#步骤2：分别创建各个数据模型Student、Address、Course" class="headerlink" title="步骤2：分别创建各个数据模型Student、Address、Course"></a>步骤2：分别创建各个数据模型Student、Address、Course</h5><p><strong>Student类</strong>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//.h文件</span></span><br><span class="line">#<span class="keyword">import</span> &quot;NSObject+ZSModel.h&quot;</span><br><span class="line">#<span class="keyword">import</span> &quot;AddressModel.h&quot;</span><br><span class="line">#<span class="keyword">import</span> &quot;CourseModel.h&quot;</span><br><span class="line"><span class="meta">@interface</span> <span class="type">StudentModel</span> : <span class="type">NSObject</span>&lt;<span class="type">ZSModel</span>&gt; <span class="comment">//遵循协议</span></span><br><span class="line"><span class="comment">//普通属性</span></span><br><span class="line"><span class="meta">@property</span> (nonatomic, copy) <span class="type">NSString</span> <span class="operator">*</span>uid;</span><br><span class="line"><span class="meta">@property</span>(nonatomic,copy)<span class="type">NSString</span> <span class="operator">*</span>name;</span><br><span class="line"><span class="meta">@property</span> (nonatomic, assign) <span class="type">NSInteger</span> age;</span><br><span class="line"><span class="comment">//嵌套模型</span></span><br><span class="line"><span class="meta">@property</span> (nonatomic, strong) <span class="type">AddressModel</span> <span class="operator">*</span>address;</span><br><span class="line"><span class="comment">//嵌套模型数组</span></span><br><span class="line"><span class="meta">@property</span> (nonatomic, strong) <span class="type">NSArray</span> <span class="operator">*</span>courses;</span><br><span class="line"><span class="meta">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// .m文件</span></span><br><span class="line">#<span class="keyword">import</span> &quot;StudentModel.h&quot;</span><br><span class="line"><span class="meta">@implementation</span> <span class="type">StudentModel</span></span><br><span class="line"><span class="operator">+</span> (<span class="type">NSDictionary</span> <span class="operator">*</span>)modelContainerPropertyGenericClass &#123;</span><br><span class="line">    <span class="comment">//需要特别处理的属性</span></span><br><span class="line">    <span class="keyword">return</span> @&#123;@<span class="string">&quot;courses&quot;</span> : [<span class="type">CourseModel</span> <span class="keyword">class</span>],@&quot;<span class="title class_">uid</span>&quot;:@&quot;<span class="title class_">id</span>&quot;&#125;;</span><br><span class="line">&#125;</span><br><span class="line">@<span class="title class_">end</span></span><br></pre></td></tr></table></figure>

<p><strong>Address类</strong>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AddressModel.h文件</span></span><br><span class="line"><span class="meta">@interface</span> <span class="type">AddressModel</span> : <span class="type">NSObject</span></span><br><span class="line"><span class="meta">@property</span> (nonatomic, copy) <span class="type">NSString</span> <span class="operator">*</span>country;  <span class="comment">//国籍</span></span><br><span class="line"><span class="meta">@property</span> (nonatomic, copy) <span class="type">NSString</span> <span class="operator">*</span>province; <span class="comment">//省份</span></span><br><span class="line"><span class="meta">@property</span> (nonatomic, copy) <span class="type">NSString</span> <span class="operator">*</span>city;     <span class="comment">//城市</span></span><br><span class="line"><span class="meta">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//-----------------优美的分割线------------------------</span></span><br><span class="line"><span class="comment">//AddressModel.m文件</span></span><br><span class="line">#<span class="keyword">import</span> &quot;AddressModel.h&quot;</span><br><span class="line"><span class="meta">@implementation</span> <span class="type">AddressModel</span></span><br><span class="line"><span class="meta">@end</span></span><br></pre></td></tr></table></figure>

<p><strong>Course类</strong>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取JSON数据</span></span><br><span class="line"><span class="type">NSDictionary</span> <span class="operator">*</span>jsonData <span class="operator">=</span> [<span class="type">FileTools</span> getDictionaryFromJsonFile:@<span class="string">&quot;Student&quot;</span>];</span><br><span class="line"><span class="type">NSLog</span>(@<span class="string">&quot;%@&quot;</span>,jsonData);</span><br><span class="line"></span><br><span class="line"><span class="comment">//字典转模型</span></span><br><span class="line"><span class="type">StudentModel</span> <span class="operator">*</span>student <span class="operator">=</span> [<span class="type">StudentModel</span> zs_modelWithDictionary:jsonData];</span><br><span class="line"><span class="type">CourseModel</span> <span class="operator">*</span>courseModel <span class="operator">=</span> student.courses[<span class="number">0</span>];</span><br><span class="line"><span class="type">NSLog</span>(@<span class="string">&quot;%@&quot;</span>,courseModel.name);</span><br></pre></td></tr></table></figure>



<h5 id="步骤3：测试字典转模型操作"><a href="#步骤3：测试字典转模型操作" class="headerlink" title="步骤3：测试字典转模型操作"></a>步骤3：测试字典转模型操作</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取JSON数据</span></span><br><span class="line"><span class="type">NSDictionary</span> <span class="operator">*</span>jsonData <span class="operator">=</span> [<span class="type">FileTools</span> getDictionaryFromJsonFile:@<span class="string">&quot;Student&quot;</span>];</span><br><span class="line"><span class="type">NSLog</span>(@<span class="string">&quot;%@&quot;</span>,jsonData);</span><br><span class="line"></span><br><span class="line"><span class="comment">//字典转模型</span></span><br><span class="line"><span class="type">StudentModel</span> <span class="operator">*</span>student <span class="operator">=</span> [<span class="type">StudentModel</span> zs_modelWithDictionary:jsonData];</span><br><span class="line"><span class="type">CourseModel</span> <span class="operator">*</span>courseModel <span class="operator">=</span> student.courses[<span class="number">0</span>];</span><br><span class="line"><span class="type">NSLog</span>(@<span class="string">&quot;%@&quot;</span>,courseModel.name);</span><br></pre></td></tr></table></figure>

<p>效果如下：<br><img src="http://182.92.228.41/wp-content/uploads/Runtime_use_dic_model_result.png" width="600" align=center></p>
<h4 id="最后总结"><a href="#最后总结" class="headerlink" title="最后总结"></a>最后总结</h4><p>以上就是我们在实际开发中常用的<code>Runtime</code>的操作了，<code>Runtime</code>的强大作用远不止如此。深入的了解和学习<code>Runtime</code>，不仅仅有助于<code>iOS</code>开发，而且对于理解编程语言的底层原理也十分有用，Keep Learning！~</p>
<p>参考链接：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://halfrost.com/how_to_use_runtime/">如何正确使用 Runtime</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008048">Objective-C Runtime Programming Guide</a></li>
<li><a href="%5Bhttp://nshipster.cn/method-swizzling/%5D(http://nshipster.cn/method-swizzling/)">Method Swizzling</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wuqh-iOS/p/4846811.html">iOS数据持久化存储:归档</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/ibireme/YYModel">YYModel源码</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Author</p>
  <div class="site-description" itemprop="description">iOS Developer, Beijing China</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">38</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Author</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  


</body>
</html>
