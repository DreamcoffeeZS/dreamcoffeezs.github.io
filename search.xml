<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ReactiveCocoa函数响应式编程-应用篇]]></title>
    <url>%2F2018%2F04%2F03%2FReactiveCocoa%E5%87%BD%E6%95%B0%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B-%E5%BA%94%E7%94%A8%E7%AF%87%2F</url>
    <content type="text"><![CDATA[使用RAC其实就是一个创建信号订阅信号的过程。上篇ReactiveCocoa函数响应式编程-基础篇，主要简单介绍了RAC的信号机制，本篇则以信号为核心，就信号常用的类、操作信号的方法，替换响应处理等方面总结RAC的使用。 目录：一、RAC中常用的类二、RAC中常用的宏三、RAC中信号的常用操作四、RAC常用的处理事件响应的方法五、本篇总结 本篇还提供了关于RAC使用的两个测试工程，结合代码学习更加直观：项目1：1.测试RAC对信号的各类操作。2.使用RAC改进一个普通的登录界面。项目2：MVVM架构结合RAC响应式编程的开发示例。实现登录界面和的分页数据界面。效果图如下： 一、RAC中常用的类1.RACSubjectRACSubject是信号RACSignal的一个子类，但它的底部实现与RACSignal有所不同。其订阅信号subscribeNext的方法只是使用nextBlock创建了一个订阅者并保存起来待用，多次调用subscribeNext会保存多个订阅者。只有发送信号sendNext方法执行时，订阅者才会执行nextBlock里的内容，多个订阅者会执行多次。使用示例： 123456789101112131415161718//1.创建信号//创建RACSubject不需要block参数RACSubject *subject = [RACSubject subject];//2.订阅信号//这里信号被订阅两次，那么订阅者也创建了两次，保存在RACSubject的subscribers属性数组中。//那么每当信号有新值发出的时候，每个订阅者都会执行。 [subject subscribeNext:^(id x) &#123; //block在信号发出新值时调用 NSLog(@"第一个订阅者:%@",x);&#125;];[subject subscribeNext:^(id x) &#123; NSLog(@"第二个订阅者:%@",x);&#125;]; //3.发送信号[subject sendNext:@"6”]; 123控制台打印：2018-03-24 13:07:51.425569+0800 ZSTest[2840:124915] 第一个订阅者:62018-03-24 13:07:51.426113+0800 ZSTest[2840:124915] 第二个订阅者:6 应用示例：替换代理我们测试这样一个功能：在当前视图控制器A中点击按钮调转到下一视图控制器B，在B的文本框中输入内容，点击编辑完成按钮回到A，显示B中输入的内容到A的UILabel上。通常我们使用代理来解决这样的问题，那么现在我们可以利用RACSubject的特性来代替常用的代理的功能，其实就跟我们使用block回调一样。具体代码如下： 12345//1.下一视图控制中添加RACSubject属性。//SecondViewController.h文件@interface SecondViewController : BaseViewController@property (nonatomic, strong) RACSubject *racSubject;@end 12345678//2.点击编辑完成按钮时，检查代理信号并发送消息，这里传递出一个字典(包含输入的文字)//SecondViewController.m文件- (IBAction)completeBtnClick:(id)sender &#123; if(self.racSubject)&#123; [self.racSubject sendNext:@&#123;@"text":self.txtField.text&#125;]; &#125; [self.navigationController popViewControllerAnimated:YES];&#125; 1234567891011121314//3.当前视图控制器A的跳转按钮响应方法中，创建secondVC，并为其添加信号属性和订阅信号。//TestViewCotroller.m文件- (IBAction)testBtnClick:(id)sender &#123; SecondViewController *secondVC = [[SecondViewController alloc] initWithNibName:@"SecondViewController" bundle:nil]; //为secondVC设置RACSubject属性，并订阅信号 secondVC.racSubject = [RACSubject subject]; __weak typeof(self) weakSelf = self; //定阅信号的block会更新文字的显示 [secondVC.racSubject subscribeNext:^(id _Nullable x) &#123; NSDictionary *infoDic =(NSDictionary *)x; weakSelf.showLabel.text = infoDic[@"text"]; &#125;]; [self.navigationController pushViewController:secondVC animated:YES]; &#125; 2.RACTuple与RACSequenceRACTuple：类似OC的数组，是RAC中用来封装值的元组类，可以配合RACTupleUnpack解元组。RACSequeue：数组和字典经过rac_sequence方法会被转化为RACSequeue类型，并进一步转为我们常用的信号。订阅此类信号的时候，信号就会被激活并遍历其中的所有值。 使用示例： 123456789101112//遍历数组NSArray *characters = @[@"A",@"C",@"B",@"E",@"D"]; [characters.rac_sequence.signal subscribeNext:^(id _Nullable x) &#123; NSLog(@"char:%@",x);&#125;];控制台打印：char:Achar:Cchar:Bchar:Echar:D 123456789101112//遍历字典NSDictionary *myInfoDic = @&#123;@"name":@"zs",@"nickname":@"FengZi",@"age":@"18"&#125;;\[myInfoDic.rac_sequence.signal subscribeNext:^(id _Nullable x) &#123; //解元组，注意一一对应 RACTupleUnpack(NSString *key,NSString *value) = x; NSLog(@"myInfoDic:%@-%@",key,value);&#125;];控制台打印：myInfoDic:name-zsmyInfoDic:nickname-FengZimyInfoDic:age-18 3.RACMulticastConnectionRACMulticastConnection用于解决一个信号被多次订阅后，创建信号中的block被重复调用的问题，所以在实际开发中，使用RACMulticastConnection可以解决网络重复请求的问题。测试1:普通的信号 12345678910111213141516171819RACSignal *signalA = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; NSLog(@"发送信号A"); [subscriber sendNext:@"发送信号A"]; return nil;&#125;];[signalA subscribeNext:^(id _Nullable x) &#123; NSLog(@"第一次订阅：%@",x);&#125;]; [signalA subscribeNext:^(id _Nullable x) &#123; NSLog(@"第二次订阅：%@",x);&#125;];控制台打印：2018-03-28 10:02:00.702607+0800 ZSTest[2446:48444] 发送信号A2018-03-28 10:02:00.702856+0800 ZSTest[2446:48444] 第一次订阅：发送信号A2018-03-28 10:02:00.703069+0800 ZSTest[2446:48444] 发送信号A2018-03-28 10:02:00.703325+0800 ZSTest[2446:48444] 第二次订阅：发送信号A 测试2：使用RACMulticastConnection 12345678910111213141516171819202122232425262728//1.创建信号RACSignal *signalB = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; NSLog(@"发送信号B"); [subscriber sendNext:@"发送信号B"]; return nil;&#125;]; //2.连接信号：publish或者muticast方法//连接后的信号使用订阅方法时，并不能激活信号，而是将其订阅者保存到数组中。//在连接对象执行connect方法时，信号中的订阅者会统一调用sendNext方法。RACMulticastConnection *signalBconnect = [signalB publish]; //3.订阅信号//使用signalBconnect而不再是signalB[signalBconnect.signal subscribeNext:^(id _Nullable x) &#123; NSLog(@"第一次订阅：%@",x);&#125;];[signalBconnect.signal subscribeNext:^(id _Nullable x) &#123; NSLog(@"第二次订阅：%@",x);&#125;];//4.连接后激活信号[signalBconnect connect];控制台打印：2018-03-28 10:02:00.704209+0800 ZSTest[2446:48444] 发送信号B2018-03-28 10:02:00.704368+0800 ZSTest[2446:48444] 第一次订阅：发送信号B2018-03-28 10:02:00.704543+0800 ZSTest[2446:48444] 第二次订阅：发送信号B 4.RACCommand：用于处理事件的类RACCommand可以把事件如何处理，如何传递都封装到类中，之后就可以方便的调起它的执行方法。在实际开发中，我们可以用它来封装一个网络操作。注意：1.创建方法中block返回一个信号，且不能为nil，但是可以使用[RACSignal empty]表示空信号2.RACCommand必须被强引用，否则容易被释放 12345678910111213141516171819202122232425262728293031323334353637383940//1.创建RACCommand：initWithSignalBlockself.command = [[RACCommand alloc] initWithSignalBlock:^RACSignal * _Nonnull(id _Nullable input) &#123; //我们常在这里创建一个网络请求的信号，也就是封装一个请求数据的操作。 RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt; _Nonnull subscriber) &#123; [subscriber sendNext:@"网络请求的信号"]; //数据传递完成，必须调用sendComplleted.,否则永远处于执行中。 [subscriber sendCompleted]; return nil; &#125;]; return signal;&#125;]; //2.订阅RACCommand中的信号，要等到RACCommand执行后，才能收到消息[self.command.executionSignals subscribeNext:^(id _Nullable x) &#123; //这里是一个信号中信号 [x subscribeNext:^(id _Nullable x) &#123; NSLog(@"收到信号：%@",x); &#125;];&#125;];//改进订阅方法：switchToLatest可以直接获取信号中信号[self.command.executionSignals.switchToLatest subscribeNext:^(id _Nullable x) &#123; NSLog(@"改进-收到信号：%@",x);&#125;]; //3.监听RACCommand命令是否执行完毕的信号//默认会监测一次，所以可以使用skip表示跳过第一次信号。//这里可以用于App网络请求时，控制加载提示视图的隐藏或者显示[[self.command.executing skip:1] subscribeNext:^(NSNumber * _Nullable x) &#123; if([x boolValue] == YES)&#123; NSLog(@"RACCommand命令正在执行..."); &#125;else&#123; NSLog(@"RACCommand命令不在执行中！！！") &#125;&#125;]; //4.执行RACComand//方法：- (RACSignal *)execute:(id)input[self.command execute:@""]; 12345控制台打印：2018-03-24 14:43:06.571968+0800 ZSTest[3725:171859] RACCommand命令正在执行...2018-03-24 14:43:06.572526+0800 ZSTest[3725:171859] 收到信号：网络请求的信号2018-03-24 14:43:06.572662+0800 ZSTest[3725:171859] 改进-收到信号：网络请求的信号2018-03-24 14:43:06.573506+0800 ZSTest[3725:171859] RACCommand命令不在执行中！！！ 二、RAC常用的宏定义1.RAC(对象，对象属性)：绑定属性输入框背景色绑定了映射后的validUserNameSignal信号，信号变化时背景色更新 123RAC(self.userNameTxtField,backgroundColor) = [validUserNameSignal map:^id _Nullable(NSNumber *userNameValid) &#123; return [userNameValid boolValue] ? [UIColor whiteColor] : [UIColor yellowColor];&#125;]; 2.RACObserve(被观察的对象，被观察对象的属性) ：代替KVO监听某个对象的某个属性123456[RACObserve(self.view, backgroundColor) subscribeNext:^(id _Nullable x) &#123; NSLog(@"测试：%@",x);&#125;];//颜色变化时将打印self.view.backgroundColor = [UIColor whiteColor];self.view.backgroundColor =[UIColor redColor]; 3.RACTuplePack与RACTupleUnpackRACTuplePack：将数据封装成元组RACTupleUnpack：将元组解包为数据 1234567//使用RACTuplePack封装元组RACTuple *racTuple = RACTuplePack(@"字符串1",@"字符串2");NSLog(@"测试racTuple:%@",racTuple);//使用RACTupleUnpack解元组RACTupleUnpack(NSString *str1,NSString *str2) = racTuple;NSLog(@"测试RACTupleUnpack：%@-%@",str1,str2); 123456控制台打印：2018-03-26 19:27:27.568399+0800 ZSTest[23113:380213] 测试racTuple:&lt;RACTwoTuple: 0x60400000ed70&gt; ( "\U5b57\U7b26\U4e321", "\U5b57\U7b26\U4e322")2018-03-26 19:27:27.568623+0800 ZSTest[23113:380213] 测试RACTupleUnpack：字符串1-字符串2 4.@weakify、@strongifyRAC中使用@weakify、@strongify解决Block循环引用的问题。在block内部使用@strongify(self)后就可以使用self操作属性了，但是一定注意这两个宏定义一定要配合使用，可参考源码分析。 1234567@weakify(self);//RAC处理手势，点击页面，隐藏键盘[self.tapGesture.rac_gestureSignal subscribeNext:^(__kindof UIGestureRecognizer * _Nullable x) &#123; @strongify(self); //经过宏定义处理后就可以使用self了，但此self非彼self。具体可查看源码分析 [self.view endEditing:YES];&#125;]; 三、RAC中关于信号的常用操作本节整理了以下几种常用信号操作：1.信号映射：map与flattenMap2.信号过滤：filter、ignore、 distinctUntilChanged3.信号合并： combineLatest、reduce、merge、zipWith4.信号连接：concat、then5.信号操作时间：timeout、interval、dely6.信号取值：take、takeLast、takeUntil、7.信号跳过：skip8.信号发送顺序：donext、cocompleted9.获取信号中的信号：switchToLatest10.信号错误重试：retry11.信号节流：throttle12.信号操作多线程：deliverON、subscribeOn 1.信号映射：map与flattenMapmap：将信号内容修改为另一种新值。改变了传递的值flattenMap：将源信号映射修改为另一种新的信号。修改了信号本身 1.1、map将信号文本值修改为文本长度 1234567//block中return的是你希望接收到的值[[self.txtField.rac_textSignal map:^id _Nullable(NSString * _Nullable value) &#123; return @(value.length);//必须返回一个对象&#125;] subscribeNext:^(id _Nullable x) &#123; //输入abcd，打印了输入字符的长度 NSLog(@"打印x:%@",x);&#125;]; 12345控制台打印：2018-03-23 10:52:41.831785+0800 ZSTest[1143:44274] 打印x:12018-03-23 10:52:42.575238+0800 ZSTest[1143:44274] 打印x:22018-03-23 10:52:43.602008+0800 ZSTest[1143:44274] 打印x:32018-03-23 10:52:44.054940+0800 ZSTest[1143:44274] 打印x:4 1.2、flattenMapflattenMap的block返回的是你想要的信号 1234567891011121314151617181920212223242526//创建一个普通信号RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt; _Nonnull subscriber) &#123; [subscriber sendNext:@"发送信号：1"]; [subscriber sendCompleted]; return nil;&#125;];//创建一个发送信号的信号，信号的信号RACSignal *signalOfSignals = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt; _Nonnull subscriber) &#123; [subscriber sendNext:signal]; [subscriber sendCompleted]; return nil;&#125;]; //订阅信号中的信号[signalOfSignals subscribeNext:^(id _Nullable x) &#123; //不使用flattenMap，会打印出内部信号 NSLog(@"订阅signalOfSignals：%@",x);&#125;]; [[signalOfSignals flattenMap:^__kindof RACSignal * _Nullable(id _Nullable value) &#123; return value; &#125;] subscribeNext:^(id _Nullable x) &#123; //使用flattenMap，会打印内部信号的值 NSLog(@"使用flattenMap后订阅signalOfSignals：%@",x);&#125;]; 123控制台打印：2018-03-23 11:23:42.920455+0800 ZSTest[1363:61658] 订阅signalOfSignals：&lt;RACDynamicSignal: 0x60400023a320&gt; name: 2018-03-23 11:23:42.920791+0800 ZSTest[1363:61658] 使用flattenMap后订阅signalOfSignals：发送信号：1 特别说明：信号中信号常出现在我们封装一个网络请求为信号的时候，这时候注意flattenMap的使用。 2.信号过滤：filter、ignore、 distinctUntilChanged2.1、filter过滤信号，符合条件的信号才能发出消息。示例：输入1234，当输入到4(文本长度大于3)的时候才开始打印如下的信息 12345678[[self.txtField.rac_textSignal filter:^BOOL(NSString * _Nullable value) &#123; return value.length &gt; 3; &#125;] subscribeNext:^(NSString * _Nullable x) &#123; NSLog(@"打印x：%@",x);&#125;];控制台打印：2018-03-23 11:39:23.371432+0800 ZSTest[1428:68939] 打印x：1234 2.2、ignore忽略信号，针对信号值的某一种状态进行忽略，忽略时不会发送消息。示例：监听每次的输入，但是当文本框内的内容是”a”时不会打印 123[[self.txtField.rac_textSignal ignore:@"a"] subscribeNext:^(NSString * _Nullable x) &#123; NSLog(@"ignore测试打印：%@",x);&#125;]; 2.3、distinctUntilChanged当上次的值与当前值有变化时才会发出消息，否则信息被忽略 12345678910111213141516//为了方便测试，我们监测控制器的currentText属性来修改Label的文本值。__weak typeof(self)weakSelf = self;[[RACObserve(self, currentText) distinctUntilChanged] subscribeNext:^(id _Nullable x) &#123; NSLog(@"使用%@更新testLabel的值",x); weakSelf.testLabel.text = x;&#125;];//currentTxt未被赋初值，所以第一次打印null,我们自己修改三次值，只打印两次self.currentText = @"hello";self.currentText = @"world";self.currentText = @"world";控制台打印:2018-03-23 16:43:54.617385+0800 ZSTest[3598:220992] 使用(null)更新testLabel的值2018-03-23 16:43:54.618026+0800 ZSTest[3598:220992] 使用hello更新testLabel的值2018-03-23 16:43:54.618380+0800 ZSTest[3598:220992] 使用world更新testLabel的值 3.信号合并：combineLatest、reduce、merge、zipWith为了便于测试，这里先创建两个RACSubject类型的信号用于测试，此类信号只有发送信号sendNext方法执行时，订阅者才会执行nextBlock里的内容; 123456789RACSubject *signalOne = [RACSubject subject];[signalOne subscribeNext:^(id _Nullable x) &#123; NSLog(@"订阅信号one：%@",x);&#125;];RACSubject *signalTwo = [RACSubject subject];[signalTwo subscribeNext:^(id _Nullable x) &#123; NSLog(@"订阅信号Two：%@",x);&#125;]; 3.1、combineLatest：合并信号合并信号的效果就是，这多个信号都至少有过一次订阅信号sendNext的操作，才会触发合并的信号。下面的测试如果只有signalOne执行sendNext方法，那么combineLatest后的信号不会被触发。 12345678[[RACSignal combineLatest:@[signalOne,signalTwo]] subscribeNext:^(RACTuple * _Nullable x) &#123; //解元组：合并信号得到的是一个元组,里面存放的是两个信号发送的消息 RACTupleUnpack(NSString *str1,NSString *str2) = x; NSLog(@"combineLatest:str1-%@,str2-%@",str1,str2);&#125;];[signalOne sendNext:@"1"];[signalTwo sendNext:@"2”]; 1234567控制台打印：2018-03-23 14:29:53.198724+0800 ZSTest[2172:143774] 订阅信号one：12018-03-23 14:29:53.199673+0800 ZSTest[2172:143774] 订阅信号Two：22018-03-23 14:29:53.200075+0800 ZSTest[2172:143774] combineLatest:&lt;RACTuple: 0x60000000d9a0&gt; ( 1, 2) 3.2、reduce：聚合信号combineLatest合并后的信号订阅后，得到的是一个元组(包含每个被合并信号的新值)。然而在开发中，我们往往需要检测多个信号合并后的效果(比如用户名和密码信号有效时，登录按钮才可以点击)，这里就用到了reduce来实现信号聚合。reduce聚合操作中的block参数个数随合并信号的数量而定，有多少个信号被合并，blcok中的参数就有多少个。这些参数一一对应被合并的信号，是它们对应的新值。 1234567[[RACSignal combineLatest:@[signalOne,signalTwo] reduce:^id(NSString *strOne,NSString *strTwo)&#123; return [NSString stringWithFormat:@"%@-%@",strOne,strTwo];&#125;] subscribeNext:^(id _Nullable x) &#123; NSLog(@"combineLatest-reduce：%@",x);&#125;];[signalOne sendNext:@"1"];[signalTwo sendNext:@"2"]; 1234控制台打印：2018-03-23 14:40:08.977580+0800 ZSTest[2288:149816] 订阅信号one：12018-03-23 14:40:08.978566+0800 ZSTest[2288:149816] 订阅信号Two：22018-03-23 14:40:08.979587+0800 ZSTest[2288:149816] combineLatest-reduce：1-2 3.3、merge：合并信号当合并后的信号被订阅时，就会订阅里面所有的信号测试1：将多个信号合并之后，当其中任何一个信号发送消息时，都能被监测到。 123456RACSignal *mergeSignal = [signalOne merge:signalTwo];[mergeSignal subscribeNext:^(id _Nullable x) &#123; NSLog(@"mergeSignal：%@",x);&#125;];//只调用其中一个信号,就会触发merge合并的信号[signalOne sendNext:@"测试信号1"]; 123控制台打印：2018-03-23 14:53:34.342899+0800 ZSTest[2577:160009] 订阅信号one：测试信号12018-03-23 14:53:34.343124+0800 ZSTest[2577:160009] mergeSignal：测试信号1 测试2：当合并后的信号被订阅时，就会订阅里面所有的信号 1234567891011121314RACSignal *signal1 = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@"signal1"]; return nil;&#125;];RACSignal *signal2 = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@"signal2"]; return nil;&#125;];RACSignal *mergeSignals = [signal1 merge:signal2]; [mergeSignals subscribeNext:^(id x) &#123; NSLog(@"mergeSignals：%@",x);&#125;]; 123控制台打印：2018-03-23 18:10:29.623099+0800 ZSTest[4444:270816] mergeSignals：signal12018-03-23 18:10:29.623721+0800 ZSTest[4444:270816] mergeSignals：signal2 3.4、zipWith：压缩信号1.zipWith把两个信号压缩成为一个信号。2.只有当两个信号同时发出信号时，两个信号的内容才会被合并为一个元组，触发压缩流的next事件。比如：当一个界面多个请求的时候，要等所有请求完成才更新UI。元组内元素顺序只与压缩信号的顺序有关，与发送信号的顺序无关。 123456789RACSignal *zipSignal = [signalOne zipWith:signalTwo];[zipSignal subscribeNext:^(id _Nullable x) &#123; //解元组：合并信号得到的是一个元组,里面存放的是两个信号发送的消息 RACTupleUnpack(NSString *str1,NSString *str2) = x; NSLog(@"zipSignal：str1-%@,str2-%@",str1,str2);&#125;];[signalOne sendNext:@"测试zipSignalMsgOne"];[signalTwo sendNext:@"测试zipSignalMsgTwo"]; 1234控制台打印：2018-03-23 15:23:58.989780+0800 ZSTest[2926:177798] 订阅信号one：测试zipSignalMsgOne2018-03-23 15:23:58.990012+0800 ZSTest[2926:177798] 订阅信号Two：测试zipSignalMsgTwo2018-03-23 15:23:58.991056+0800 ZSTest[2926:177798] zipSignal：str1-测试zipSignalMsgOne,str2-测试zipSignalMsgTwo 4.信号拼接：concat、then4.1、concat1.使用concat可以按序拼接多个信号，拼接后的信号按序执行。2.使用concat连接信号后，每个信号无需再单独订阅，其内部会按序自动订阅3.前面的信号必须执行sendCompleted，后面的信号才会被激活 1234567891011121314151617181920212223RACSignal *signalOne = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt; _Nonnull subscriber) &#123; [subscriber sendNext:@"signalOne"]; [subscriber sendCompleted]; return nil;&#125;]; RACSignal *signalTwo = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt; _Nonnull subscriber) &#123; [subscriber sendNext:@"signalTwo"]; [subscriber sendCompleted]; return nil;&#125;];RACSignal *signalThree = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt; _Nonnull subscriber) &#123; [subscriber sendNext:@"signalThree"]; [subscriber sendCompleted]; return nil;&#125;]; //拼接了三个信号，订阅之后，三个信号依次激活RACSignal *concatSignal = [[signalOne concat:signalThree] concat:signalTwo];[concatSignal subscribeNext:^(id _Nullable x) &#123; NSLog(@"信号被激活:%@",x);&#125;]; 1234控制台打印：2018-03-22 17:36:47.565105+0800 ZSTest[6018:274201] 信号被激活:signalOne2018-03-22 17:36:47.565403+0800 ZSTest[6018:274201] 信号被激活:signalThree2018-03-22 17:36:47.565609+0800 ZSTest[6018:274201] 信号被激活:signalTwo 4.2、then:连接信号使用then连接信号，上一个信号完成后，才会连接then返回的信号，所以then连接的上一个信号必须使用sendCompleted，否则后续信号无法执行。then连接的多个信号与concat不同的是：之前的信号会被忽略掉，即订阅信号只会接收到最后一个信号的值 1234567891011121314151617181920212223[[[[RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; NSLog(@"信号1"); [subscriber sendNext:@"发送信号1"]; [subscriber sendCompleted]; return nil; &#125;] then:^RACSignal *&#123; return [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; NSLog(@"信号2"); [subscriber sendNext:@"发送信号2"]; [subscriber sendCompleted]; return nil; &#125;]; &#125;]then:^RACSignal * _Nonnull&#123; return [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; NSLog(@"信号3"); [subscriber sendNext:@"发送信号3"]; [subscriber sendCompleted]; return nil; &#125;]; &#125;] subscribeNext:^(id x) &#123; //只能接收到最后一个信号的值 NSLog(@"订阅信号：%@",x);&#125;]; 12345控制台打印：2018-03-23 16:53:52.819003+0800 ZSTest[3668:227466] 信号12018-03-23 16:53:52.819762+0800 ZSTest[3668:227466] 信号22018-03-23 16:53:52.820008+0800 ZSTest[3668:227466] 信号32018-03-23 16:53:52.820139+0800 ZSTest[3668:227466] 订阅信号：发送信号3 5.信号操作时间：timeout、interval、dely5.1、interval创建定时器信号，每固定时间发送一次信号 1234567RACSignal *intervalSignal = [RACSignal interval:1 onScheduler:[RACScheduler currentScheduler]];//只知道使用take结束定时器这一种方法，不知道还有没有其他方法[[intervalSignal take:5]subscribeNext:^(id _Nullable x) &#123; //订阅定时器信号，启动定时器，只打印5次 NSLog(@"interval,定时器打印"); &#125;]; 5.2、timeout可以设置超时操作，让一个信号在规定时间之后自动报错创建信号时不能使用sendCompleted，因为这样的话一旦发送了消息就取消订阅了。 123456789101112131415RACSignal *timeOutSignal = [[RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt; _Nonnull subscriber) &#123; [subscriber sendNext:@"timeOutSignal发送信号"]; //[subscriber sendCompleted]; return nil;&#125;] timeout:5 onScheduler:[RACScheduler currentScheduler]]; [timeOutSignal subscribeNext:^(id _Nullable x) &#123; NSLog(@"timeOutSignal:%@",x); &#125; error:^(NSError * _Nullable error) &#123; //5秒后执行打印： //timeOutSignal:出现Error-Error Domain=RACSignalErrorDomain Code=1 "(null)" NSLog(@"timeOutSignal:出现Error-%@",error);&#125; completed:^&#123; NSLog(@"timeOutSignal:complete");&#125;]; 5.3、delay延迟发送sendNext 123456789RACSignal *delaySignal = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt; _Nonnull subscriber) &#123; [subscriber sendNext:@"delaySignal-sendNext"]; return nil;&#125;]; //10秒后才收到消息，执行打印[[delaySignal delay:10] subscribeNext:^(id _Nullable x) &#123; NSLog(@"delaySignal:%@",x);&#125;]; 6.信号取值take、takeLast、takeUntil首先创建一个signal来测试这三个方法： 12345678RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt; _Nonnull subscriber) &#123; [subscriber sendNext:@"发送消息1"]; [subscriber sendNext:@"发送消息2"]; [subscriber sendNext:@"发送消息3"]; [subscriber sendNext:@"发送消息4"]; [subscriber sendCompleted]; return nil;&#125;]; 6.1、take：从开始共取N次的next值1234567[[signal take:2] subscribeNext:^(id _Nullable x) &#123; NSLog(@"订阅信号:%@",x);&#125;];控制台打印：2018-03-23 17:15:09.865290+0800 ZSTest[3835:237999] 订阅信号:发送消息12018-03-23 17:15:09.865617+0800 ZSTest[3835:237999] 订阅信号:发送消息2 6.2、takeLast：从最后共取值N次next的值12345678[[signal takeLast:3]subscribeNext:^(id _Nullable x) &#123; NSLog(@"订阅信号：%@",x);&#125;];控制台打印：2018-03-23 17:19:51.343909+0800 ZSTest[3933:241042] 订阅信号：发送消息22018-03-23 17:19:51.344063+0800 ZSTest[3933:241042] 订阅信号：发送消息32018-03-23 17:19:51.344177+0800 ZSTest[3933:241042] 订阅信号：发送消息4 6.3、takeUntil:(RACSignal *)使用RACSubject类型的信号来测试，直到某个信号执行完成 ,才获取信号 12345678910111213141516171819RACSubject *signalA = [RACSubject subject];[signalA subscribeNext:^(id _Nullable x) &#123; NSLog(@"订阅信号A：%@",x);&#125;]; __weak typeof(self)weakSelf = self;//[RACObserve(self, currentText)发送消息知道signalA信号结束[[RACObserve(self, currentText) takeUntil:signalA] subscribeNext:^(id _Nullable x) &#123; NSLog(@"使用%@更新testLabel的值",x); weakSelf.testLabel.text = x;&#125;];self.currentText = @"0";self.currentText = @"1";self.currentText = @"2";[signalA sendCompleted];//信号A结束之后，监听testLabel文本的信号也不在发送消息了self.currentText = @"3";NSLog(@"代码执行到此行。。。。"); 123456控制台打印：2018-03-23 17:31:08.907925+0800 ZSTest[4044:247412] 使用(null)更新testLabel的值2018-03-23 17:31:08.908531+0800 ZSTest[4044:247412] 使用0更新testLabel的值2018-03-23 17:31:08.908957+0800 ZSTest[4044:247412] 使用1更新testLabel的值2018-03-23 17:31:08.909194+0800 ZSTest[4044:247412] 使用2更新testLabel的值2018-03-23 17:31:08.909725+0800 ZSTest[4044:247412] 代码执行到此行。。。。 7.信号跳过：skip使用skip跳过几个信号 123456789101112131415RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt; _Nonnull subscriber) &#123; [subscriber sendNext:@"第一次发送消息"]; [subscriber sendNext:@"第二次发送消息"]; [subscriber sendNext:@"第三次发送消息"]; [subscriber sendNext:@"第四次发送消息"]; return nil;&#125;];[[signal skip:2] subscribeNext:^(id _Nullable x) &#123; NSLog(@"%@",x);&#125;];控制台打印：2018-03-23 17:48:06.479104+0800 ZSTest[4284:259095] 第三次发送消息2018-03-23 17:48:06.479376+0800 ZSTest[4284:259095] 第四次发送消息 8.信号发送顺序：doNext、doCompleted发送信号前与发送信号后操作：doNext、doCompleteddoNext：在订阅者发送消息sendNext之前执行doCompleted：在订阅者发送完成sendCompleted之后执行 12345678910111213RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt; _Nonnull subscriber) &#123; [subscriber sendNext:@"发送信号：1"]; [subscriber sendCompleted]; return nil;&#125;]; [[[signal doNext:^(id _Nullable x) &#123; NSLog(@"执行doNext");&#125;] doCompleted:^&#123; NSLog(@"执行doComplete");&#125;] subscribeNext:^(id _Nullable x) &#123; NSLog(@"订阅信号：%@",x);&#125;]; 1234控制台打印：2018-03-28 11:20:42.881535+0800 ZSTest[2656:81106] 执行doNext2018-03-28 11:20:42.881841+0800 ZSTest[2656:81106] 订阅信号：发送信号：12018-03-28 11:20:42.882583+0800 ZSTest[2656:81106] 执行doComplete 9.获取信号中的信号：switchToLatestswitchToLatest只能用于信号中的信号(否则崩溃)，获取最新发送的信号。 12345678910111213141516171819//创建一个普通信号RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt; _Nonnull subscriber) &#123; [subscriber sendNext:@"发送信号：1"]; [subscriber sendCompleted]; return nil;&#125;];//创建一个发送信号的信号，信号的信号RACSignal *signalOfSignals = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt; _Nonnull subscriber) &#123; [subscriber sendNext:signal]; [subscriber sendCompleted]; return nil;&#125;]; //订阅最近发出的信号[signalOfSignals.switchToLatest subscribeNext:^(id _Nullable x) &#123; //控制台打印：switchToLatest打印：发送信号：1 NSLog(@"switchToLatest打印：%@",x);&#125;]; 特别说明：可以看出switchToLatest和flattenMap的功能很相似，但是它们有一主要区别： 10.信号错误重试：retryretry：只要失败就重新执行信号 12345678910111213141516171819static int signalANum = 0;RACSignal *signalA = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt; _Nonnull subscriber) &#123; if (signalANum == 5) &#123; [subscriber sendNext:@"signalANum is 5"]; [subscriber sendCompleted]; &#125;else&#123; NSLog(@"signalANum错误！！!"); [subscriber sendError:nil]; &#125; signalANum++; return nil;&#125;]; [[signalA retry] subscribeNext:^(id _Nullable x) &#123; NSLog(@"StringA-Next：%@",x);&#125; error:^(NSError * _Nullable error) &#123; //特别注意：这里并没有打印 NSLog(@"signalA-Errror");&#125;] ; 1234567控制台打印：2018-03-24 09:46:38.996888+0800 ZSTest[818:14322] signalANum错误！！!2018-03-24 09:46:39.063427+0800 ZSTest[818:14322] signalANum错误！！!2018-03-24 09:46:39.064203+0800 ZSTest[818:14322] signalANum错误！！!2018-03-24 09:46:39.064567+0800 ZSTest[818:14322] signalANum错误！！!2018-03-24 09:46:39.064819+0800 ZSTest[818:14322] signalANum错误！！!2018-03-24 09:46:39.065199+0800 ZSTest[818:14322] StringA-Next：signalANum is 5 11.信号节流：throttle当某个信号发送比较频繁时，可以使用throttle节流，在某一段时间不发送信号内容，过了一段时间获取信号的最新内容发出。 1234567891011121314151617181920212223[[[RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt; _Nonnull subscriber) &#123; [subscriber sendNext:@"发送消息11"]; dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; [subscriber sendNext:@"发送消息21"]; [subscriber sendNext:@"发送消息22"]; &#125;); dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; [subscriber sendNext:@"发送消息31"]; [subscriber sendNext:@"发送消息32"]; [subscriber sendNext:@"发送消息33"]; &#125;); dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(4 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; [subscriber sendNext:@"发送消息41"]; [subscriber sendNext:@"发送消息42"]; [subscriber sendNext:@"发送消息43"]; [subscriber sendNext:@"发送消息44"]; &#125;); return nil; &#125;] throttle:2] subscribeNext:^(id _Nullable x) &#123; NSLog(@"Next:%@",x); &#125;]; 123控制台打印：2018-03-24 11:05:48.411464+0800 ZSTest[2063:62521] Next:发送消息112018-03-24 11:05:52.426162+0800 ZSTest[2063:62521] Next:发送消息44 12.信号关于线程的操作副作用：关于信号与线程,我们把在创建信号时block中的代码称之为副作用。deliverON：切换到指定线程中，可用于回到主线中刷新UI,内容传递切换到指定线程中，subscribeOn：内容传递和副作用都会切换到指定线程中。deliverOnMainThread：能保证原信号subscribeNext，sendError，sendCompleted都在主线程MainThread中执行。 1234567891011121314151617181920212223242526272829303132333435//测试1：系统并行队列中异步执行,未使用deliverON切换线程 dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; [[RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt; _Nonnull subscriber) &#123; [subscriber sendNext:@"测试1-endNext"]; NSLog(@"测试1-当前线程：%@",[NSThread currentThread]); return nil; &#125;] subscribeNext:^(id _Nullable x) &#123; NSLog(@"测试1-Next:%@",x); NSLog(@"测试1-Next当前线程：%@",[NSThread currentThread]); &#125;]; &#125;) ; //测试2：系统并行队列中异步执行,使用deliverON切换线程 dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; [[[RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt; _Nonnull subscriber) &#123; [subscriber sendNext:@"测试2-endNext"]; NSLog(@"测试2-当前线程：%@",[NSThread currentThread]); return nil; &#125;] deliverOn:[RACScheduler mainThreadScheduler]] subscribeNext:^(id _Nullable x) &#123; NSLog(@"测试2-Next:%@",x); NSLog(@"测试2-Next当前线程：%@",[NSThread currentThread]); &#125;]; &#125;) ; //测试3：系统并行队列中异步执行,使用subscribeOn切换线程 dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; [[[RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt; _Nonnull subscriber) &#123; [subscriber sendNext:@"测试3-sendNext"]; NSLog(@"测试3-sendNext当前线程：%@",[NSThread currentThread]); return nil; &#125;] subscribeOn:[RACScheduler mainThreadScheduler]] subscribeNext:^(id _Nullable x) &#123; NSLog(@"测试3-Next:%@",x); NSLog(@"测试3-Next当前线程：%@",[NSThread currentThread]); &#125;]; &#125;) ; 123456789101112控制台打印：2018-03-24 12:37:48.025872+0800 ZSTest[2624:109537] 测试1-Next:测试1-endNext2018-03-24 12:37:48.026152+0800 ZSTest[2624:109537] 测试1-Next当前线程：&lt;NSThread: 0x60400046e640&gt;&#123;number = 5, name = (null)&#125;2018-03-24 12:37:48.026746+0800 ZSTest[2624:109537] 测试1-sendNext当前线程：&lt;NSThread: 0x60400046e640&gt;&#123;number = 5, name = (null)&#125;2018-03-24 12:37:48.027784+0800 ZSTest[2624:109537] 测试2-sendNext当前线程：&lt;NSThread: 0x60400046e640&gt;&#123;number = 5, name = (null)&#125;2018-03-24 12:37:48.073294+0800 ZSTest[2624:109360] 测试2-Next:测试2-sendNext2018-03-24 12:37:48.073890+0800 ZSTest[2624:109360] 测试2-Next当前线程：&lt;NSThread: 0x60400006a280&gt;&#123;number = 1, name = main&#125;2018-03-24 12:37:48.074181+0800 ZSTest[2624:109360] 测试3-Next:测试3-sendNext2018-03-24 12:37:48.074511+0800 ZSTest[2624:109360] 测试3-Next当前线程：&lt;NSThread: 0x60400006a280&gt;&#123;number = 1, name = main&#125;2018-03-24 12:37:48.074646+0800 ZSTest[2624:109360] 测试3-sendNext当前线程：&lt;NSThread: 0x60400006a280&gt;&#123;number = 1, name = main&#125; 分析：测试1：未切换线程，发送消息与接收消息都在异步线程中测试2：使用deliverON，发送消息还在原来的线程，但是接收消息切换到主线程。测试2：使用subscribeON，发送消息和接收消息都被切换到了主线程中执行。 四、RAC常用的处理事件响应的方法1.代替代理的使用基础篇里已经有一种使用RACSubject替换代理的方法，这里是另一种形式的替换。在视图控制中添加自定义视图CustomView，其上有一按钮testBtn添加了响应方法testBtnClick:。此时可以使用RAC在不使用代理的情况下，在视图控制中监听自定义视图中按钮的点击:关键方法：rac_signalForSelector使用说明：1.通过rac_signalForSelector方法，以按钮响应方法为参数，得到一个信号。2.订阅信号，在按钮点击时会发出信号。经过测试，即使testBtnClick方法没有在自定义视图的.h文件中声明，执行也是正常的。 123[[_customView rac_signalForSelector:@selector(testBtnClick:)] subscribeNext:^(RACTuple * _Nullable x) &#123; NSLog(@"testBtn点击了。。。");&#125;]; 2.代替按钮等控制视图的响应事件创建一个类似按钮的响应控件，我们可以不必再为其添加响应方法。使用RAC可以将按钮点击事件转化为信号，点击按钮会发送信号，执行订阅方法。关键方法：rac_signalForControlEvents 123[[testBtn rac_signalForControlEvents:UIControlEventTouchUpInside] subscribeNext:^(__kindof UIControl * _Nullable x) &#123; NSLog(@"testBtn点击了。。。");&#125;]; 3.代替KVO，监听对象属性变化关键方法：rac_valuesAndChangesForKeyPath使用说明：1.自定义视图_customView属性frame的变化被转化信号，frame发生变化的时候，会发送信号。2.observer可以为nil,但是会报警告。 1234[[_customView rac_valuesAndChangesForKeyPath:@"frame" options:NSKeyValueObservingOptionNew observer: nil] subscribeNext:^(id x) &#123; NSLog(@"CustomView的Frame值变化了：%@",x);&#125;];_customView.frame = CGRectZero; 4.监听文本输入变化关键方法：rac_textSignalUITextField与UITextView输入视图内容的变化，我们也可以采用RAC的方法来监听 123[[_testTxtView rac_textSignal] subscribeNext:^(NSString * _Nullable x) &#123; NSLog(@"当前文本输入内容：%@",x);&#125;]; 5.代替通知的使用关键方法：rac_addObserverForName 1234567891011//步骤1： 添加通知[[[NSNotificationCenter defaultCenter] rac_addObserverForName:@"SecondVCNotificaitonName" object:nil] subscribeNext:^(NSNotification * _Nullable x) &#123; NSDictionary *objectDic = (NSDictionary *)x.object; NSLog(@"获取到通知里的文本：%@",objectDic[@"text"]);&#125;];//步骤2：发起通知//SecondVC中点击按钮，将输入框中的文本封装成字典，将其作为参数发起通知- (IBAction)completeBtnClick:(id)sender &#123; [[NSNotificationCenter defaultCenter] postNotificationName:@"SecondVCNotificaitonName" object:@&#123;@"text":self.txtField.text&#125;];&#125; 6.多请求汇总处理关键方法：rac_liftSelector：withSignals： 123456789101112131415161718192021//下载任务1RACSignal *downLoad1 = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt; _Nonnull subscriber) &#123; [subscriber sendNext:@&#123;@"data2":@"value1"&#125;]; [subscriber sendCompleted]; return nil;&#125;];//下载任务2RACSignal *downLoad2 = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt; _Nonnull subscriber) &#123; [subscriber sendNext:@&#123;@"data2":@"value2"&#125;]; [subscriber sendCompleted]; return nil;&#125;]; //多信号对应多参数，注意顺序与格式[self rac_liftSelector:@selector(handleAllTasksWithT1:withT2:) withSignals:downLoad1,downLoad2, nil];//集中处理所有的请求- (void)handleAllTasksWithT1:(id)data1 withT2:(id)data2&#123; NSLog(@"下载任务全部完成：%@，%@",data1,data2);&#125; 五、本篇总结写到这里，其实RAC还是有好多东西没有在这里涉及，本篇也只是对于它最常用的部分进行了归纳总结，尤其是我对于RAC在MVVM架构中的使用还不太熟练。RAC的学习，这仅仅是一个开始，继续努力吧！ 参考链接：1.RAC核心元素与信号流2.iOS常用API整理]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>移动开发</tag>
        <tag>iOS</tag>
        <tag>Reactive</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ReactiveCocoa函数响应式编程-基础篇]]></title>
    <url>%2F2018%2F04%2F03%2FReactiveCocoa%E5%87%BD%E6%95%B0%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B-%E5%9F%BA%E7%A1%80%E7%AF%87%2F</url>
    <content type="text"><![CDATA[目录：一、了解函数响应式编程二、ReactiveCocoa简介三、ReactiveCocoa集成四、理解什么是信号五、从源码理解RAC的信号机制六、本篇总结 一、了解函数响应式编程 函数式编程(Funcational Programming)使用高阶函数编程，即函数可采用多种函数作为它们的参数和返回值。 响应式编程(Reactive Programming)一种面向数据流和变化传播的编程范式 函数响应式编程(Funcational Reacitve Programming)简称FRP，ReactiveCocoa就是一个典型的FRP框架，响应式的编程思想，函数式的代码形式。 二、ReactiveCocoa简介ReactiveCocoa(简称RAC)，Reactive表示响应式，Cocoa是苹果整个框架的简称，许多苹果框架都以Cocoa结尾。所以RAC是Github上为我们提供函数响应式编程方法的iOS开发框架。 iOS开发中，我们需要使用按钮点击、代理、通知等这些方法来处理响应事件。而RAC框架使用Category为很多基本的UIKit控件添加信号Signal，这样我们可以通过信号来监听数据流与变化传播，把将监听的代码与处理代码放在一起，从而方便我们管理。利用此特点结合MVVM架构，RAC也有十分显著的作用。 三、ReactiveCocoa集成RAC.5.0相对于之前版本对于自身项目结构进行了较大调整，被拆分ReactiveCocoa、ReactiveSwift、ReactiveObjC、ReactiveObjCBridge四个库，我们需要根据不同的情况来集成。GitHub地址：https://github.com/ReactiveCocoa/ReactiveCocoa通常，我们都使用Cocoapods集成RAC，需要注意的是Podfile文件中必须使用user_framework!，然后，针对于不同的代码环境，有三种集成情况： 1.纯OC工程ReactiveObjc库包含原RAC2的全部代码，在纯OC工程中使用 12345platform :ios, '8.0'use_frameworks! #必须添加target 'ZSTest' do #工程名#pod 'ReactiveObjC' #默认导入最新的RAC版本 end 2.纯Swift工程纯Swfit工程继续使用ReactiveCocoa，但RAC依赖ReactiveSwift，所以相当于引入两个库。集成方法同上，只不过将ReactiveObjc换成ReactiveCocoa。 3.OC与Swift混编工程混编工程需要同时引入ReactiveCocoa与ReactiveObjCBridge，但是ReactiveObjCBridge库依赖于ReactiveObjc库，所以相当于同时引入四个库了。示例如下： 1234567platform :ios, '8.0'use_frameworks! #必须添加target 'ZSTest' do #工程名pod 'ReactiveCocoa'pod 'ReactiveObjC' pod 'ReactiveObjCBridge'end 四、ReactiveCocoa信号理解我觉得学习RAC的第一个关口就是理解信号RACSignal了，什么是信号也许是困惑我们的第一个问题。 作为RAC中最为核心的一个类，信号可以理解为传递数据变化信息的工具，信号会在数据发生变化时发送事件流给它的订阅者，然后订阅者执行响应方法。信号本身不具备发送信号的能力，而是交给一个订阅者去发出。 首先上一段代码，演示信号的一个基本使用。测试场景：我们要对一个用于输入用户名的UITextFiled进行检测，每次输入内容变化的时候都打出输入框的内容，使用RAC来实现此操作的关键代码如下： 123[self.userNameTxtField.rac_textSignal subscribeNext:^(NSString * _Nullable x) &#123; NSLog(@"测试：%@",x);&#125;]; 1234控制台打印：2018-03-23 17:57:00.497956+0800 ZSTest[4351:263810] 测试：12018-03-23 17:57:00.498237+0800 ZSTest[4351:263810] 测试：122018-03-23 17:57:00.498375+0800 ZSTest[4351:263810] 测试：123 没错的，不使用代理方法，也没有action的响应处理，我们仅仅使用了一行方法就实现了对文本框输入内容的实时打印。由此，RAC的实用性可见一斑。 五、ReactiveCocoa信号机制我们会对上面的代码产生疑问，RAC是怎么做到上述代码功能的呢？而且我们常说的订阅者又在哪里呢？ 其实RAC已经使用Category的形式为我们基本的UI控件创建了信号(如上例中的rac_textSignal)，所以这里我们才可以很方便的实现信号订阅，而且订阅者在整个过程中也是对于我们隐藏的。 现在我们使用自定义信号的方法，从创建信号到订阅信号细致的了解一下这个过程。首先上一段创建信号的测试代码如下： 12345678910111213141516171819202122232425//创建信号RACSignal *testSignal = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt; _Nonnull subscriber) &#123; //1.订阅者发送信号内容 [subscriber sendNext:@"发送信号内容"]; //2.订阅者发送信号完成的信息，不需要再发送数据时，最好发送信号完成，可以内部调起清理信号的操作。 [subscriber sendCompleted]; //3.创建信号的Block参数，需要返回一个RACDisposable对象 ，可以返回nil。 //RACDisposable对象用于取消订阅信号，此block在信号完成或者错误时调用。 RACDisposable *racDisposable = [RACDisposable disposableWithBlock:^&#123; NSLog(@"信号Error或者Complete时销毁"); &#125;]; return racDisposable;&#125;]; //订阅信号[testSignal subscribeNext:^(id _Nullable x) &#123; //新变化的值 NSLog(@"订阅信号：subscribeNext:%@",x);&#125; error:^(NSError * _Nullable error) &#123; //信号错误，被取消订阅,被移除观察 NSLog(@"订阅信号：Error:%@",error.description);&#125; completed:^&#123; //信号已经完成，被取消订阅，被移除观察 NSLog(@"订阅信号：subscribeComplete");&#125;]; 1234控制台打印:2018-03-23 17:57:00.497956+0800 ZSTest[4351:263810] 订阅信号：subscribeNext:发送信号内容2018-03-23 17:57:00.498237+0800 ZSTest[4351:263810] 订阅信号：subscribeComplete2018-03-23 17:57:00.498375+0800 ZSTest[4351:263810] 信号Error或者Complete时销毁 我们通过观察源码来理解整个过程: 1.创建信号创建信号，我们需要使用RACSignal的类方法createSignal。该方法需要一个Block作为参数。查看源码，我们就会发现RACSignal最终是通过调用自己子类RACDynamicSignal的createSignal方法，将这个Block设置给了自己的didSubscribe属性的。 1234//RACSignal.m文件+ (RACSignal *)createSignal:(RACDisposable * (^)(id&lt;RACSubscriber&gt; subscriber))didSubscribe &#123; return [RACDynamicSignal createSignal:didSubscribe];&#125; 12345//RACDynamicSignal.h文件@interface RACDynamicSignal ()// The block to invoke for each subscriber.@property (nonatomic, copy, readonly) RACDisposable * (^didSubscribe)(id&lt;RACSubscriber&gt; subscriber);@end 123456//RACDynamicSignal.m文件+ (RACSignal *)createSignal:(RACDisposable * (^)(id&lt;RACSubscriber&gt; subscriber))didSubscribe &#123; RACDynamicSignal *signal = [[self alloc] init]; signal-&gt;_didSubscribe = [didSubscribe copy]; return [signal setNameWithFormat:@"+createSignal:"];&#125; didSubscribe：这是创建信号时候需要传入的一个block，它的传入参数是订阅者subscriber，而返回值是需要是一个RACDisposable对象。创建信号后的didSubscrib是一个等待执行的block。 RACSubscriber：表示订阅者，创建信号时订阅者发送信号，这里的订阅者是一个协议而非一个类。信号需要订阅者帮助其发送数据。查看RACSubscriber的协议，我可以看到以下几个方法： 12345678//发送信息- (void)sendNext:(nullable id)value;//发送错误消息- (void)sendError:(nullable NSError *)error;//发送完成信息- (void)sendCompleted;//- (void)didSubscribeWithDisposable:(RACCompoundDisposable *)disposable; 在创建一个信号的时候，订阅者使用sendNext发送信息。而且如果我们不再发送数据，最好在这里执行一次sendCompleted方法，这样的话，信号内部会自动调用对应的方法取消信号订阅。 RACDisposable：这个类用于取消订阅信号和清理资源，在信号出现错误或者信号完成的时候，信号会自动调起RACDisposable对象的block方法。在代码中我们也可以看到，创建RACDisposable对象是使用disposableWithBlock方法设置了一个block操作，执行block操作之后，信号就不再被订阅了。 总结：创建信号就是使用createSignal方法，创建一个信号，并为信号设置了一个didSubscribe属性(也就是一系列订阅者需要做的操作)。 2.订阅信号进入订阅信号的源码我们看到如下代码： 12345678- (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock error:(void (^)(NSError *error))errorBlock completed:(void (^)(void))completedBlock &#123; NSCParameterAssert(nextBlock != NULL); NSCParameterAssert(errorBlock != NULL); NSCParameterAssert(completedBlock != NULL); RACSubscriber *o = [RACSubscriber subscriberWithNext:nextBlock error:errorBlock completed:completedBlock]; return [self subscribe:o];&#125; 在此方法中，我们可以看到订阅信号有两个过程：过程1：使用subscribeNext的方法参数，创建出一个订阅者subscriber。过程2：信号对象执行了订阅操作subscribe，方法中传入参数是刚创建的订阅者。 注：这也就解释了我们常提起却看不见的订阅者存在哪里的问题。真实开发中我们只关心订阅者需要发送的值就行了，而不需要关心其内部订阅的过程。 继续打开信号的subscribe方法，看到源码如下： 12345678910111213- (RACDisposable *)subscribe:(id&lt;RACSubscriber&gt;)subscriber &#123; NSCParameterAssert(subscriber != nil); RACCompoundDisposable *disposable = [RACCompoundDisposable compoundDisposable]; subscriber = [[RACPassthroughSubscriber alloc] initWithSubscriber:subscriber signal:self disposable:disposable]; if (self.didSubscribe != NULL) &#123; RACDisposable *schedulingDisposable = [RACScheduler.subscriptionScheduler schedule:^&#123; RACDisposable *innerDisposable = self.didSubscribe(subscriber); [disposable addDisposable:innerDisposable]; &#125;]; [disposable addDisposable:schedulingDisposable]; &#125; return disposable;&#125; 上面的代码中我们不难看出：除了对于订阅者和清理对象的再次封装外，最重要的就是创建信号时为信号设置Block(didSubscribe)被调用了，而且Block参数使用了我们创建的订阅者。 六、本篇总结1.自创建信号会传入一个Block(didSubscribe)，Block中遵循协议的订阅者会调用sendNext方法发送消息。而在订阅信号subscribeNext时，会在内部创建一个订阅者，并将其传递给原先赋值的didSubscribe，并执行这个Block。 2.但是我们应该注意：上述的分析只是其中信号机制的一种情况罢了。RAC对于UI组件信号的封装可能有所不同，比如之前我们看到的输入框信号，执行订阅信号subscribeNext时并不立即执行打印，而是监听到输入时打印。这其实是该信号使用了concat又做了一系列的操作。对于不同的信号我们只需要理解上述分析中提到几个关键属性，就可以结合源码很好的理解信号机制的使用了。 本篇的重点在于对RAC的基本介绍，是为了更好的理解信号机制，这仅相当于打开一个切入口来认识RAC。关于RAC的详细用法可以参考下一篇：ReactiveCocoa函数响应式编程-应用篇，这里将总结RAC关于信号的各种用法。 其他参考链接：1.ReactiveCocoa入门教程：第一部分2.最快让你上手ReactiveCocoa之基础篇3.这样好用的ReactiveCocoa,根本停不下来4.函数式编程与面向对象的比较]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>ReactiveCocoa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建个人博客网站Github、Hexo与Next]]></title>
    <url>%2F2018%2F02%2F28%2F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99Github%E3%80%81Hexo%E4%B8%8ENext%2F</url>
    <content type="text"><![CDATA[过年回家前在公司的最后一天，说实话有点心不在焉了。整个2017也就这样恍然过去，很多事都来不及回想。在这最后的时间里，想起把自己使用Hexo搭建个人博客网站的流程整理成篇，前段时间为了这个也是找了好多资料，遇到不少坑，将它记录在这里就算是旧年里的最后一个节点，毕竟春节过后新的一年就要真正开始了。 温馨提示：由于本篇是后期整理的文章，一些在实际操作中遇到的错误可能会遗漏，但都是可以百度到的，当然，我也欢迎大家留言问题，以供完善记录。 效果展示：梧雨北辰的博客 目录一、准备工作二、搭建博客(远程与本地)三、发布博客四、更换主题五、博客网站美化六、在不同电脑管理hexo博客七、遇到问题八、其他方案 一、准备工作1.了解HexoHexo是高效的静态站点生成框架，她基于Node.js。 通过 Hexo 你可以轻松地使用 Markdown 编写文章，除了 Markdown 本身的语法之外，还可以使用 Hexo 提供的标签插件来快速的插入特定形式的内容，而且相对于其他框架，Hexo在速度上也有很大优势。 2. 搭建Node.js环境我们了解到Hexo基于Node.js的，那么我们搭建博客网站首先需要安装Node.js环境。 Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境，可以在非浏览器环境下，解释运行 JS 代码。下载地址：http://nodejs.cn/download测试安装：命令行使用node -v 、mpm -v，查看显示版本号即成功。 3.安装Hexo博客框架工具Hexo是一个建站工具，可以帮助我们快速生成基本的博客文件，安装它需要在控制台下使用如下命令：1npm install hexo-cli -g 若报错，请尝试在命令前加上sudo 4.安装Git版本工具Git是目前世界上最流行的分布式版本控制系统，是的，没有之一。使用Git可以帮助我们把本地的网页和文章等内容提交到Gihub上，实现同步。下载地址：https://git-scm.com/downloadsWindows系统需下载，Mac系统因为自带Git无需操作。测试安装：git - -version，查看显示版本号即成功。 5.注册Github账号gitHub是一个面向开源及私有软件项目的托管平台，因为只支持git 作为唯一的版本库格式进行托管，故名gitHub。这里用到Github，是因为我们需要通过Github得到自己的博客网站域名，而且需要使用gitHub同步我们个人博客的相关文件。注册地址：https://github.com注册流程：https://www.baidu.com，百度一下，你就知道啦。 注意：注册Github的时候一定要选择一个合适的名字，因为后来博客网站的域名也会用到这个名字。虽然Github用户名支持后期修改，但是还是会带来很多不必要的麻烦。github的使用在网上有很多教程，这里也就不再累述了。 二、开始搭建博客1.开启GitHub Pages服务搭建我们的个人博客需要一个唯一的域名，当然我们可以申请购买一个域名来使用，但是在不是太必要的情况下，我们也可以通过Github Pages获得一个免费使用的域名，这需要我们在Github上新建一个仓库，如下： 这个过程和建立普通的仓库没什么区别，关键在于新仓库的名字，一定要是UserName+“github.io”的形式。这也是之前强调的要起一个好的用户名的原因。这样之后我们最后的博客网站的链接就会是：https://UserName.github.io的形式。注意：固定新仓库的名字格式并非必须，只是这样操作生成的博客域名比较短小简洁，另起他名生成博客域名会很冗长。 点击Create Repository之后，随后选择Setting进入设置，找到Github Pages如下： 这里我们需要点击Choose a theme任意选择一个选择主题，然后界面会跳转到仓库，我们看到有两个文件如下： 此时若再查看setting，我们会看到开启GitHub Pages之后得到的域名如下： 现在，我们就可以使用https://UserName.github.io，访问自己的博客网站了，打开链接我们会看到默认主题的个人博客样式如下(虽然有点点丑，是吧)： 2.创建本地博客站点上述的步骤相当于我们使用Github page，创建了一个默认的博客页，并且得到了一个可外部访问的域名。但是这个博客页很Low。我们的目的是创建自己个性化的博客网站，所以我们使用Hexo在本地先创建一个本地博客站点，优化后再把它部署到github上。接下来我们使用控制台命令在本地一个合适的位置创建博客站点文件夹如下：1hexo init myHexoBlog //myHexoBlog是项目名 下面来测试本地博客站点，在本地博客根目录下使用控制台命令：123hexo g //g是generetor的缩写，生成博客hexo s //s是server的缩写，启动服务 此时打开浏览器，输入 http://localhost:4000/，我们将会看到Hexo自带默认主题显示的博客样式如下(呃，是好看了那么一点点)： 3.同步Github,允许公共访问在本地我们已经搭建了博客，但是还只能自己本地访问。若要别人也能看到，那就需要我们将其同步部署到GitHub上了。还记得我们之前准备的Github仓库吗，这里就要用到了。首先找到我们的博客仓库，并拷贝仓库地址： 然后修改本地博客目录的配置：修改本次博客根目录下的_config.yml文件，修改deploy下的配置如下： 最后执行控制台命令：123npm install hexo-deployer-git —save //安装部署插件hexo d //部署到github 现在，我们再次访问链接：https://userName.github.io，就会发现这里的界面和本地的一样了。如此一来我们搭建的个人博客网站就基本完成了。 三、发布博客激动人心的时候到了，终于可以发布自己的第一篇博客了。来尝试一下以下的步骤：在本地博客文件夹根目录输入：12345hexo new &quot;我个人博客的第一篇博客，哈哈哈...&quot;hexo g //生成网页hexo d //部署到远端(github) 查看我们本地的博客文件夹，将会看到我们创建一个条新的博客文章： 现在打开我们的博客网站：http://UserName.github.io,会看到网页如下(显示可能会延时，不如先喝杯茶放松下吧)： 这就是我们发布博客的方法啦，当然这里是为了演示，真正做的时候我们要找到_posts里的博客原文，先编辑内容，然后再部署到github上。 四、更换主题现在我们已经看见个人博客的雏形了，但是现在的博客网页一点也不高大上。为了让它看起来更美观一些，我们可以为其更换主题（当然也可以自己在默认主题下自己编写美化博客界面，可是我还不太会前端，以后再突破吧）。这里以使用github上的next主题为例： 1.创建next文件夹切换到本地博客根目录下，在主题文件thems下创建一个新文件夹next存放即将下载的next主题1mkdir themes/next 2.下载主题Next1curl -s [https://api.github.com/repos/iissnan/hexo-theme-next/releases/latest](https://api.github.com/repos/iissnan/hexo-theme-next/releases/latest) | grep tarball_url | cut -d &apos;&quot;&apos; -f 4 | wget -i - -O- | tar -zx -C themes/next --strip-components=1 此步骤可参考：https://github.com/iissnan/hexo-theme-next 下载成之后我们会看到next的主题已经存在thems里了如下： 3.修改博客配置文件，更换主题配置修改博客根目录(不是next主题)下的_config.yml文件，搜索theme字段，并将其值修改为next。 然后在控制台下输入如下命令：12345hexo clean //清理缓存hexo g //重新生成博客代码hexo d //部署到本地 再次打开我们的博客网站：https://UserName.github.io，将会看到更换主题后的博客网页如下： 五、博客网站美化终于我们的博客也算像点样子了，如果你和我一样是个完美主义者，那我们来继续美化它吧。这需要我们对博客中的各种配置进行修改。 首先说明一下：在Hexo中有两份主要的配置文件，其名称都是 _config.yml。 其中，一份位于站点根目录下，主要包含 Hexo本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。 1.站点配置：在本地的博客根目录下找到_config.yml，用编辑器打开，如下： 这里可以修改博客网站的标题、描述，语言等属性，上面更换主题也是在这个文件中修改的。大家可以在这里稍作设置。 2.主题设置关于博客主题的配置这块本来想着自己写下呢，却发现官方文档更加详尽。大家可以参考Next文档来学习。文档地址：http://theme-next.iissnan.com/getting-started.html其他参考：hexo的next主题个性化教程打造个性超赞博客Hexo+Next+githubPages的超深度优化 3.更多主题选择next只是众多Hexo主题的一种，还有很多优秀的主题可供我们选择，参考以上的更换及配置方法我们就可以进一步美化我们的个人博客网站了。更多主题选择：https://github.com/hexojs/hexo/wiki/Themes 六、在不同电脑管理hexo博客其实，这也是我在使用Hexo搭建博客遇到的一个问题，如果我们检查自己博客在Github上的文件就会发现，github仓库里的文件和我们本地博客站点的文件夹是不同的，确切来说是少了很多内容。如果我们想在不同的电脑上管理自己的博客，就必须有源文件存在远端供我们随时下载、然后修改后重新部署到远端。 我们要理解这样一个过程：hexo -d是把本地博客源文件生成的静态网页文件同步到github上，实现部署。但是博客网站的源文件仍需要我们自己保存。这里主要有两种思路可以选择： 1.在github存放我们博客静态网页文件的仓库里另建分支brach，单独用于存放源文件。2.将本地博客文件存放在码云上。 这些都是关于git的操作，所以这里不用细说了。单对于这两种方法来说，我更倾向于第二种。因为毕竟这些都是我们搭建个人博客的源文件，将来还要在网站上发表文章，很多数据都在这里。使用码云我们可以创建私有仓库，将这些源文件私有存放更好一些，而且源文件和静态博客网页文件分开存放也避免使用分支频繁切换。 七、遇到问题 ####1.修改了配置，网站没有变化 这种情况，大多因为修改后配置后我们直接部署，没有执行hexo clean。 ####2.代码无法高亮显示 在Hexo的next主题下，我们使用markDown编辑文章，如果代码无法高亮，这有可能是我们没有在标记语言后添加语言类型，我需要在添加代码片段的时候使用如下的样式： 类似其他语言用：java、python… 八、其他方案 还有一种搭建博客网站的方案是Jekyll，还没有细致研究呢，先记在这里为以后扩展思路。 终于写完了，祝新的一年越来越好，加油！- 2018-02-13]]></content>
      <categories>
        <category>闲暇所学</category>
      </categories>
      <tags>
        <tag>个人博客</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS多Target开发相似App]]></title>
    <url>%2F2018%2F02%2F10%2FiOS%E5%A4%9ATarget%E5%BC%80%E5%8F%91%E7%9B%B8%E4%BC%BCApp%2F</url>
    <content type="text"><![CDATA[我们在iOS开发中可能会遇到同时开发多个类似项目的情况。这些项目大同小异，有诸多代码可以共用，如果每个项目都分别开发，这在后期的迭代中会十分繁琐。为了解决这个问题，使用多Target开发是一种比较好的选择，本文就这一技术实现进行简要总结。 一、理解项目中的Porject与Target使用Xcode来开发项目，其中的Project是一个整体项目相当于一个仓库，包括了所有的代码和资源文件。而Target相当于一个具体的产品，包含了对于代码，资源文件的具体使用规则和配置。一个Project可以包含多个Target，也就是说通过不同Target我们可以生成不同的APP。 二、多Target开发项目的实践步骤使用多Target来创建项目，就以我当前正在开发的亲戚买房APP为例。需求是这样的：亲戚买房是一个为买房人提供砍价服务的APP，APP的用户需要区分为用户，专家和砍价师三个用户群体。所以这里以Customer，Consul，Bargain三个Target来开发应用 1.以QQMF(亲戚买房)为名创建一个新的工程如下: 2.创建三种Target创建新Target的方式有两种：第一种：依次选择File-&gt;New-&gt;Target，然后选择一个模板(通常是Single View App)来创建。只是这样创建的target带有Appdelegate和main等文件，在这里并不会用到这些文件，所以我们采用第二种方式创建。第二种：在Targets中点击已有的Target，右键选择Duplicate可以复制生成一个copy的新Target，并且在文件目录中生成对应的copy-Info.plist文件。这样生成的target与被拷贝的target相似度很大，减少了过多的修改。通常为了减少后期的修改，我们也会首先在原有的Target中修改一些配置之后再Duplicate。 执行了Duplicate操作之后的效果如下： 3.修改Targe和plist文件的名称为自己需要的名称在Target里可以直接修改Target的名称，在文件目录下也可以直接修改plist文件的名称。如果我们不想文件结构那么乱，也可以像其他文件一样移动plist文件的位置并重新引用到工程中，如下：特别注意：我们在移动文件的时候可能需要重新引用文件到工程中，此时add文件的时候一定要注意选择Target，如果是共用文件一定要勾选对应的Target，类似AppDelegate这样文件的操作如下： 4.修改Xcode左上角的Target名称选中Xcode左上角的创建工程时的Target(QQMF)，选择Manage schemes在如下的schemes中修改Target的名称，这里也可以删除多余的最初的QQMF 特别说明：QQMF是我们创建工程自带的Target,其实也可以修改它的名字以供自定义使用，而这里我们是直接删掉了它，这样之后，项目自带的info.plist也是没用的了，也可以删掉。 5.设置Target与plist文件对应切换到Target目录下，我们可以在这里删掉用不到的QQMF，选择其中一个Target之后并选择general，然后可以看到每个Target的右侧都有对应的choose info.plist file选项，点击可以选择与Target对应的plist文件。这也就相当于不同的Target项目对应了不同的plist配置。 6.为每个Target设置Display Name，Bundle Identifier等信息点击Target-&gt;选择General，我们分别设置不同项目的名称和BundleID信息，以及证书等 7.同一份代码区分不同Target的操作使用多Target是为了共用一部分代码，但是有些共用的文件在不同的Target下是有细微不同的，那么我们在具体实现的时候就需要作出区分。这里解决的方法是针对不同的Target定义宏。首先选择一个Target,如Customer，依次选择Build Settings -&gt;搜索PreprocessorMacros, 在找到PreprocessorMacros之后，我们分别在Debug和Release中设置TargetType=1如下图进行设置： 其他的Target也是同样的设置方式，只是要区分TargetType的值，分别是2，3(TargetType及其值都是自定义的)。然后就是在代码中的使用如下图，分别选择Xcode左上角不同的Target运行，查看控制台验证是否成功。 8.解决使用Cocoapods的问题因为存在多个Target，我们需要区别的设置不同target需要的第三方库，如下图。这里可能出现的问题是如果有很多类似AFNetworking这样的被多个Target需要的类库，我们在删除和增加的时候就会频繁的操作而且会代码冗余。解决上述问题的比较优雅的做法是如下： 三、遇到的问题 问题：invalid token at start of a preprocessor expression原因：这是我在pch文件中判断target类型出现的错误，这句话的大致意思是：在预编译阶段，代码并未运行，无法判断宏定义的值。最后查找到原因是我在上述步骤设置宏定义的时候，手误设置了TargetType==1，这本是一句需要执行才能得到结果的代码。所以无法在#if的条件编译中通过。解决：在条件编译中不使用代码运行时才生成的量即可。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>移动开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发中的CPU架构问题]]></title>
    <url>%2F2018%2F02%2F10%2FiOS%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84CPU%E6%9E%B6%E6%9E%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[首先，之所以提到CPU架构的问题，其实是因为我们iOS开发使用的静态库与动态库与之紧密相连。每一个开发的App都要运行在模拟器或者真机上，在编译的时候，Xcode需要去分析当前运行平台的CPU架构，然后确定所使用的静态库是否支持这个CPU架构。如果不支持就会报错。 一、什么是CPU架构“CPU架构是CPU厂商给属于同一系列的CPU产品定的一个规范，主要目的是为了区分不同类型CPU的重要标示。目前市面上的CPU分类主要分有两大阵营，一个是intel、AMD为首的复杂指令集CPU，另一个是以IBM、ARM为首的精简指令集CPU。两个不同品牌的CPU，其产品的架构也不相同，例如，Intel、AMD的CPU是X86架构的，而IBM公司的CPU是PowerPC架构，ARM公司是ARM架构”（摘自百度）通常，我们知道电脑的CPU架构有X86和X64等，但是手机的主流CPU架构是ARM架构，因为采用ARM架构的CPU是一种微处理器，这种处理器功耗低，体积小，更适合手机使用，iPhone的CPU也是如此。 二、iPhone移动设备默认指令集那么，总结iPhone设备默认指令集的使用情况如下： 三、有关指令集使用特点 上述arm处理器指令集，在原则上它们都是向下兼容的。比如iPhone6s的CPU默认指令集是arm64,但是也同时支持armv7s等以前版本的指令集，只是效率变低了而已。 xcode模拟器其实是在电脑上的，所以iOS模拟器并没有使用arm指令集。它编译运行使用的是x86指令集(或者i386)。而在真机上使用的才是arm类型的指令集。 在Xcode中设置二进制包所支持的指令集，对于编译后的二进制包的大小影响显著，设置支持的指令集个数越少，安装包也越小。 四、Xcode中关于指令集的配置与使用具体在Xcode中的使用，我们在Xcode中选择将要设置的target，然后打开build setting, 可以看到有关指令集设置的Architectures选项。 在这里的关键设置有三个，可以通过这里设置Xcode生成二进制包的指令集 1.Architectures:作用：设置工程被编译后将支持哪些指令集，支持指令集是通过编译生成对应的二进制数据包实现的。特点：设置支持的指令集数据越多，编译出的二进制包包含的指令集代码越多，这样就会使最后编译的包很大。 2.valid Architectures：作用：设置可能支持的指令集，这里的指令集选项和Architectures列表中指令集选项的交集，将决定最后Xcode生成二进制包所支持的指令集。举例：Architectures支持armv7, Valid Architecture支持armv7、armv7s、armv64，那么Xcode只会生成一个armv7指令集的二进制包。 3.build Active Architecture only作用：设置是否只编译当前使用设备所对应的arm指令集。也就是说当该项设置为YES的时候，上述规则(Architectures和valid Architectures交集决定二进制包所支持指令集)将被打破。举列：设置该选项是YES,并且连接一个armv7指令集设备，无论前面两项如何设置，Xcode最终生成armv7指令集的二进制包。不过设置为YES生效有个前提条件就是，Xcode必须成功连接了调试的设备。 一般的情况下，build Active Architecture only选项默认在Debug模式下是YES, Release模式下是NO，但是我们在开发的时候，有时候也会遇到一些第三方文件找不到路径的问题，这时要求我们设置Debug模式下也为NO。 五、遇到的问题在这里记录一个在开发中遇到的问题。曾经在使用CocoaPods管理第三方的时候，遇到了“library not found for -lXXX”的错误，当时使用了Masonry的库。Xcode报错如下：其实这是因为CocoaPods在引入第三方类库的时候，默认build Active Architecture only在Debug模式下是YES导致的，修改为NO就可以了。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>移动开发</tag>
        <tag>架构</tag>
        <tag>CPU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Charles抓包HTTP、HTTPS]]></title>
    <url>%2F2018%2F02%2F10%2FCharles%E6%8A%93%E5%8C%85HTTP%E3%80%81HTTPS%2F</url>
    <content type="text"><![CDATA[抓包分析数据在移动开发中十分重要，可以帮助我们更快的了解数据构成，提高开发效率。但是在苹果要求上线的App必须使用HTTS之后，HTTPS数据包的抓取分析较为麻烦，在此总结了在mac上使用Charles抓包的详细步骤。 首先我们下载最先版本的Charles官网下载：https://www.charlesproxy.com/download/免费版下载：http://xclient.info/search/s/charles/ 一、开启网络请求记录，设置系统网络代理安装Charles之后，我们选择Proxy-&gt;Start Recording，开始记录网络请求，然后勾选MacOS Proxy(和其他的代理对象如：Mozilla Firefox Proxy火狐浏览器）,将系统代理设置通过Charles Proxy。 此时打开系统偏好设置-&gt;网络-&gt;高级，我们可以看到本机HTTP和HTTPS请求被代理到127.0.0.1，端口号是8888。至此，我们已经完成了基本的网路请求设置，通过此Mac发起的HTTP请求，我们都可以通过Charles分析。 注：在Charles关闭的时候，这里的web代理和安全web代理也会变成无勾选状态。保证无代理时，Mac也能够访问网络。 二、iPhone数据包的抓取1.打开Charles的代理功能为了使用Charles抓取到iPhone设备的数据包，我们首先要打开Charles的代理功能。选择Proxy -&gt;Proxy Setting，设置Port:8888，选择Enable TransParent HTTP Proxying。 2.获取本机电脑IP接下来我们要将手机的网络代理IP设置为Charles运行所在的电脑IP，获取本机电脑的IP方法如下：方法一：Mac电脑上使用Control +空格键，并输入Terminal 可以进入控制台，然后键入 ifconfig en0命令 ，我们查看到当前电脑的IP地址。 方法二：通过Charles查看本机的IP地址：打开Charles -&gt;Help-&gt;Local IP Address 3. 设置手机网络代理IP我们依次打开iphone “设置-&gt;无线局域网”，点击当前连接Wifi右侧的详情按钮。这里显示了当前连接Wifi的基本信息，我们需要将这里底部的HTTP代理改为手动，然后填上Charles运行所在电脑的IP和端口号8888。如图： 此时，iPhone的网络代理就设置完成了，手机上请求将会被代理到mac上，我们可以很方便的通过Charles查看到手机应用发起的网络请求数据包。 三、抓取HTTPS数据包相对于HTTP类的网络请求，HTTPS请求更加安全，这也使得抓取这类的数据包进行分析要麻烦一些。抓取HTTPS请求数据包进行分析，关键的步骤如下： 1.安装Charles根证书打开charles,依次点击Help -&gt; SSL Proxying -&gt; Install Charles Root Certificate，安装根证书 2.设置证书信任在安装证书之后，我们查看钥匙串。选择所有项目，我们会看到一个带有红叉标记不被信任的Charles证书。Charles证书默认是不信任的，需要我们手动设置。右键-&gt;显示简介-&gt;点击信任，我们如图设置始终信任。 3.设置 SSL 代理打开charles应用，选择Proxy-&gt;SSL Proxying Settings,我们在这里设置SSL Proxy,点击面板上的add，如下图： 在这里我们设置主机地址Host是*,使用通配符表示检测所有网络请求。然后设置端口号是443 4.iOS设备安装证书最后我们还需要在iOS设备上安装证书。点击 Charles 的顶部菜单，选择 Help –&gt; SSL Proxying–&gt; Install Charles Root Certificate on a Mobile Device or Remote Browser，然后就可以看到 Charles 显示如下弹窗： 然后我们需要打开safari ,输入网址： http://charlesproxy.com/getssl，这时候会弹出安装证书的界面，我们点击安装证书，如图：目前为止，我们就完成了Charles抓取HTTPS数据包的所有设置了。查看Charles,我们可以看到数据包的内容了。 5.失败请求的处理iOS10.3之后，在上述设置完成之后，所有的https请求都会失败。提示错误：Failure SSLHandshake: Received fatal alert: unknown_ca 和You may need to configure your browser or application to trust the Charles Root Certificate.原因：charles的根证书虽然已经在安装列表中,但在iOS 10.3之后,安装新的自定义证书默认是不受信任的。如果要信任已安装的自定义证书,需要手动打开开关以信任证书。解决：设置-&gt;通用-&gt;关于本机-&gt;证书信任设置-&gt; 找到charles proxy custom root certificate然后信任该证书即可. 模拟器也是这样处理。 四、使用Charles遇到的问题我在使用Charles抓包https之后，在使用applicationLoader上传ipa包的时候遇到了下面的问题：Communication error. Please use diagnostic mode to check connectivity. You need to have outbound access to TCP port 443. 解决：将charles关闭，然后再上传ipa文件。至于原因我也没弄明白，如果哪位朋友知道也可以告诉我一下。]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>开发工具</tag>
        <tag>移动开发</tag>
        <tag>网络</tag>
        <tag>抓包</tag>
      </tags>
  </entry>
</search>
